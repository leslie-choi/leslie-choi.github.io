---
title: HTTP和TCP
date: 2019-02-12 22:06:14
tags: Interview
categories: network
---

# TCP协议

![markdown](https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/TCP.png)

互联网由一整套协议构成。

图片说明：顶层协议是应用层协议 => TCP协议 => IP协议 => 以太网协议（应用层=>传输层=>网络层=>链路层）

以太网协议：最底层的协议，可以解决子网内部的点对点通讯。

IP协议：IP协议，可以解决多个局域网之间互通，可以连接多个局域网，定义了一套自己的地址规则，实现了路由的功能，允许某个局域网的A主机，向另一个局域网的B主机发送消息。（PS：路由器就是基于IP协议。所以局域网之间要靠路由器连接）

题外话：路由原理就是路由器内部有一张路由表，规定A段IP地址走出口一，B段IP地址走出口二。。。根据这样实现了数据包的转发。

TCP协议：IP协议只是一个地址协议，并不能保证数据的完整性。如果缓存满了，新进来的数据包就会丢失，所以这个时候需要发现丢了哪一个包，以及如何重新发送这个包，所以这个时候需要使用到TCP协议。以太网数据包的负载是1500字节，TCP数据包的负载在1400字节左右。

## TCP建立连接（三次握手）

HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。

* 第一次握手：建立连接时，客户端发送syn包（syn=1,seq=x）到服务器，并进入 SYN_SENT 状态，**服务端得到结论：客户端的发送能力、服务端的接收能力正常。**
* 第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=x+1,seq=y），同时自己也发送一个 SYN 包，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态，客户端接收到，**于是客户端得到结论：服务端的接收和发送能力正常，客户端的接收发送能力正常，但是此时服务器并不能确认客户端的接收能力是否正常**
* 第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=y+1,seq=z），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP连接成功）状态，**服务端得到结论：客户端和服务端的接收发送能力都正常，完成三次握手。**

![markdown](https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/sanwo.png)

## TCP关闭连接（四次挥手）

由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

TCP 的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。

* 客户端 A 发送一个 FIN，用来关闭客户 A 到服务器B的数据传送，但是仍然可以接收数据( Fin_wait_1 )
* 服务器 B 收到这个 FIN，它发回一个 ACK 应答，表明接收到请求但是还未准备关闭连接，然后确认序号为收到的序号加1。和 SYN 一样，一个 FIN 将占用一个序号(服务端 closed_wait，客户端 Fin_wait_2)
* 服务器 B 关闭与客户端 A 的连接，发送一个 FIN 给客户端 A(服务端 Last_ack,客户端 time_wait)
* 客户端 A 发回 ACK 报文确认，并将确认序号设置为收到序号加1 (服务端 closed，然后经过 2MSL后服务端进入 closed)

![markdown](https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/sihui.png)

## UDP和TCP（User Datagram Protocol，用户数据报协议）的区别

1. 都是位于传输层，TCP 是面向连接的，而**udp 是无连接的**，即发送数据前不需要先建立连接
2. TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达；UDP 尽最大努力交付，即不保证可靠交付。并且 TCP 可靠，面向连接不会丢失数据适合大数据量的传输
3. TCP 面向字节流，UDP 面向报文，并且网络阻塞不会使得发送的速率降低，所以会出现丢包（适合视频会议或者直播）。　
4. TCP 只能是一对一的，而 UDP 可以一对多
5. TCP 首部较大为20字节，UDP 只有8字节

## 如何实现UDP的可靠传输

TCP 是通过确认机制和超时重传机制实现可靠传输

UDP 它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用 UDP 较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照 tcp 可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。

关键在于两点，从应用层角度考虑：

1. 提供超时重传，能避免数据包丢失。

2. 提供确认序列号，可以对数据报进行确认和排序。

**RUDP**

RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。在不干扰协议的实时特性的同时，可靠 UDP 的拥塞控制机制允许 TCP 方式下的流控制行为。

# http协议

![markdown](https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/http.jpg)

HTTP 协议是**Hyper Text Transfer Protocol（超文本传输协议）**的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议，也就是说所有的 www 服务器都必须要遵循这个标准。

HTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。

HTTP 协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。

HTTP 请求由三部分组成，分别是：**请求行、请求头、请求正文**

## http 的两个重要特点

**无连接：** 限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。（但是随着网络的发展，每次都要建立一次 TCP 连接就显得很低效，后来，Keep-Alive 被提出用来解决这效率低的问题。）

**无状态：** 指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是发送完，不会记录任何信息，于是，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。（简单场景购物车）

## http 报文

用于 HTTP 协议交互的信息被称为 http 报文。HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CE+LF）来划分。通常，并不一定要有报文主体。在 http1.1 中，报文是通信的基本单位，由8位组字节流组成，用于 HTTP 通信。（http2.0采用二进制分帧）

![markdown](https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/%E6%8A%A5%E6%96%872.png)

### http请求报文

* 请求行：包含用于请求的方法，请求 uri 和 http 版本   （GET/HTTP/1.1）
* 请求头
* 空行
* 请求体：根据实际请求需要可能包含一个消息实体

### http响应报文

* 状态行：包含表明响应结果的 http 版本和状态码，状态描述 （HTTP/1.1 200 OK）
* 响应头：包括通用头部、响应头部和实体头部
* 空行
* 响应体

## get 和 post 的主要区别

![markdown](https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/get%26post.jpeg)

**1. get在浏览器回退时是无害的，而post会再次请求。**
**2. get产生的url地址可以被收藏（即书签），而post不会。**
3. get请求会被浏览器主动缓存，而post不会，除非手动设置。
4. get请求只能进行url编码，而post支持多种编码方式。
**5. get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。**
**6. get 请求在url中传送的参数有长度限制（一般限制在2kb~8kb之间，但是更加常见的是在1kb之内，这个⻓度限制是浏览器规定的），而post没有（实际大小根据服务器情况而定）**
7. 对参数的数据类型，get只接受ascll字符，而post没有限制。
8. post比get更安全，因为参数直接暴露在url上，所以不能用来传递敏感信息。
**9. get参数通过url传递，poet放在request body中。**
10. GET产生一个TCP数据包;POST产生两个TCP数据包。

对于GET方式的请求，浏览器会把**http header和data一并发送出去**，服务器响应200(返回数据)

而对于POST，浏览器先发送**header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)**，这也就是为什么GET请求产生一个TCP数据包，而POST请求产生两个数据包。
但是在网络环境较好的情况下，发送一次包的时间和发送两次包的时间差别几乎是可以无视的。而在网络环境较差的情况下，发送两次包的TCP在验证数据包的完整性上，有非常大的优点。（但是并不是所有的浏览器都会在POST请求中发送两次包，Firefox就只发送一次。）

HTTP缺点：
1. 通信使用明文（ 不加密） ， 内容可能会被窃听。
2. 不验证通信方的身份， 因此有可能遭遇伪装。
3. 无法证明报文的完整性， 所以有可能已遭篡改。

## Http的版本

1. HTTP 0.9作为HTTP协议的第一个版本。是非常弱的。请求(Request)只有一行,比如: GET www.leautolink.com。
2. HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上。
3. HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。

![markdown](https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/httpVersion.png)

## http管线化

在使用持久连接（因此低于HTTP1.1版本无法开启管线化）的情况下，某个连接消息的传递类似于

请求1 -> 响应1 -> 请求2 -> 响应2 -> 请求3 - > 响应3

管线化：某个连接上的消息变成了类似这样 

请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3

1. 那么持久连接和管线化的区别在于：

持久连接的一个缺点是请求和响应式是顺序执行的，只有在请求1的响应收到之后，才会发送请求2，而管线化不需要等待上一次请求得到响应就可以进行下一次请求。**实现并行发送请求。** 

2. 只有GET和HEAD要求可以进行管线化，而POST则有所限制。

3. 初次创建连接时也不应启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议。

4. HTTP1.1要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败，并且开启管线化很可能不会带来大幅度的性能提升，而且现在很多服务器端和代理程序对管线化的支持并不好，现代浏览器Chrome和Firefox默认并未开启管线化支持。

## http 1.1 做了哪些升级

**缓存处理：** 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。

**带宽优化及网络连接的使用：** HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

**错误通知的管理：** 在 HTTP1.1 中新增了24个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

**Host头处理：** 在HTTP1.0 中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。

**长连接（持久连接）：** HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection：keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。

## Http 1.1 中的八种方法

* OPTIONS:
这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用 '*' 来代替资源名称,向 Web 服务器发送 OPTIONS 请求,可以测试服务器功能是否正常运作。

* HEAD:
与 GET 方法一样,都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于,使用这个方法可以在不必传输全部内容的情况下,就可以获取其中“关于该资源的信息”(元信息或称元数据)。

* GET:
向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据,而不应当被用于产生“副作用”的操作中,例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访问。参见安全方法

* POST:
向指定资源提交数据,请求服务器进行处理(例如提交表单或者上传文件)。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源,或二者皆有。

* PUT:
向指定资源位置上传其最新内容。

* DELETE:
请求服务器删除 Request-URI 所标识的资源。

* TRACE:
回显服务器收到的请求,主要用于测试或诊断。

* CONNECT:
把请求连接转换到透明的 TCP/IP 通道。通常用于 SSL 加密服务器的链接(经由非加密的 HTTP 代理服务器)。

## 几个常见的Content-Type

**第一类：raw 原始类型，可以上传任意格式的文本，比如 text、json、xml、html（中文不进行编码）**

* text/html  ：HTML格式
* text/plain ：纯文本格式      
* text/xml   ：XML格式

* image/gif  ：gif图片格式    
* image/jpeg ：jpg图片格式 
* image/png  ：png图片格式

* application/xml     ： XML数据格式
* application/json    ： JSON数据格式
* application/pdf     ： pdf格式  
* application/msword  ： Word文档格式
* application/octet-stream ： 二进制流数据（如文件下载）

**第二类：application/x-www-form-urlencoded，会将表单内的数据转换拼接成 key-value 对**

* application/x-www-form-urlencoded ：

`<form encType="">`中默认的encType，
form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）。
服务器收到的raw body会是，name=aaa&key=bbb。

**第三类：multipart/form-data，将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件**

* multipart/form-data ： 表单上传文件

## 常用的 HTTP 请求头与响应头

请求头：

* Accept            可接受的响应内容类型（Content-Types）           Accept: text/plain
* Accept-Language   可接受的响应内容语言列表                        Accept-Language: en-US
* Cache-Control     用来指定当前的请求/回复中的，是否使用缓存机制     Cache-Control: no-cache
* Host              表示服务器的域名以及服务器所监听的端口号          Host: www.itbilu.com:80
* Origin            发起一个针对跨域资源共享的请求                   Origin: http://www.itbilu.com
* If-Modified-Since 允许在对应的资源未被修改的情况下返回304未修改     If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT	

响应头：

* Access-Control-Allow-Origin     指定哪些网站可以跨域源资源共享      Access-Control-Allow-Origin: *
* ETag     对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列  ETag: "737060cd8c284d8af7ad3082f209582d"	
* Last-Modified        所请求的对象的最后修改日期          Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT
* Expires              指定一个日期/时间，超过该时间则认为此回应已经过期  Expires: Thu, 01 Dec 1994 16:00:00 GMT

# Https

Https协议其实是基于Http的，多了个s其实就是Secure，所以也就是**Hypertext Transfer Protocol Secure（超文本传输安全协议）**
相对于HTTP协议，具有以下优点：
1. 内容加密：采用混合加密技术，中间者无法直接查看明文内容。
2. 验证身份：通过证书认证客户端访问的是自己的服务器。
3. 保护数据完整性：防止传输的内容被中间人冒充或者篡改。
![markdown](https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/https.png)

## SSL和TLS

HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。TLS与SSL在传输层对网络连接进行加密，在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。

**对称加密（通信过程）：**

对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。
这种加密方式固然很好，但是问题就在于如何让双方知道秘钥。因为传输数据都是走的网络，如果将秘钥通过网络的方式传递的话，一旦秘钥被截获就没有加密的意义的。

**非对称加密（认证过程）：**

有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道（服务端）。
这种加密方式就可以完美解决对称加密存在的问题。假设现在两端需要使用对称加密，那么在这之前，可以先使用非对称加密交换秘钥。

简单流程如下：首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了。

## SSL/TLS 四次握手

四次握手主要交换了3个信息：

1. 数字证书：该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是信赖的CA签发的，或者与本地的证书相比，来判断证书是否可信，防止身份被冒充。
2. 三个随机数。
3. 加密通信协议。

**四次握手过程**

* 客户端发送通信请求，和第一个随机数 N1。
* 服务器确定加密通信协议的版本，然后返回 CA 机构签发的数字证书和公钥以及第二个随机数 N2，确认加密方法。
* 客户端验证证书的合法性，使用证书中的公钥和 HASH 算法对消息进行加密，返回服务端第三个随机数 N3。
* 服务端使用私密对消息进行解密，验证 HASH，N1+N2+N3 生成对话密钥，进行对称通信。

理论上只要服务端私钥不泄露就无法被破解。

**HTTPS优缺点:**

**优点：**
* 内容加密：无法直接查看明文内容
* 验证身份：CA 签发证书判断是否访问自己的服务器
* 保证数据完整性：防止传输内容被窜改
* 在谷歌 搜索引擎中排名更高

**缺点：**
* 成本高，证书费用大
* 握手耗时延长 50%，耗电增加 10%到20%
* 连接缓存不如 http 高效，会增加性能功耗
* SSL 证书需要绑定 IP，不能在同一个 IP 上绑定多个域名

# http2.0 

HTTP/2 相比于 HTTP/1，可以说是大幅度提高了网页的性能。

## 二进制分帧

HTTP/2 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP/2 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。

帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

## 多路复用

在 HTTP/1 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。

多路复用允许同时通过单一的HTTP/2 连接发起多重的请求响应消息。有了新的分帧后。HTTP/2 不再依赖多个TCP连接去实现多流并行了，每个数据流拆分成很多互不依赖的帧，还可以分优先级。不必通过多个 TCP 连接去实现并行执行，避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

## header压缩

HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP/2 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。

## 服务端推送

服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确地请求。

可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。

# http3.0

虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，虽然这个问题并不是它本身造成的，而是底层支撑的 TCP 协议的问题。

因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。

因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。

那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。

**基于这个原因，Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。**

## QUIC

UDP 这个协议虽然效率很高，但是并不是那么的可靠。QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。

### 多路复用

虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。

并且 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是**基于 IP 和端口**去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。

### 0-RTT

通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。

### 纠错机制

假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。

**当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。**

当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。

# 常见问题

## 为什么连接的时候是三次握手，关闭的时候却是四次挥手？

ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当 Server 端收到FIN报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉 Client 端，"你发的 FIN 报文我收到了"。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四次挥手。

## 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

虽然按道理，四个报文都发送完毕，我们可以直接进入 CLOSE 状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。在 Client 发送出最后的ACK回复，但该 ACK 可能丢失。Server 如果没有收到 ACK，将不断重复发送FIN片段。所以 Client 不能立即关闭，它必须确认 Server 接收到了该 ACK。Client 会在发送出ACK之后进入到 TIME_WAIT 状态。Client会设置一个计时器，等待 2MSL 的时间。如果在该时间内再次收到 FIN，那么 Client 会重发 ACK 并再次等待 2MSL。所谓的 2MSL 是两倍的 MSL(Maximum Segment Lifetime)。MSL 指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到FIN，那么 Client 推断ACK已经被成功接收，则结束 TCP 连接。

## 为什么不能用两次握手进行连接？

3 次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

**现在把三次握手改成仅需要两次握手，死锁是可能发生的。**作为例子，考虑计算机 S 和 C 之间的通信，假定 C 给 S 发送一个连接请求分组，S 收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C 在 S 的应答分组在传输中被丢失的情况下，将不知道 S 是否已准备好，不知道 S 建立什么样的序列号，C 甚至怀疑 S 是否收到自己的连接请求分组。在这种情况下，C 认为连接还未建立成功，将忽略 S 发来的任何数据分 组，只等待连接确认应答分组。而 S 在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。


## 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP 还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若 2 小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75S 发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

## HTTP/2的多路复用和HTTP1.1中的长连接复用有什么区别？

HTTP/1.0 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；
HTTP/1.1 Pipeling 解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；
HTTP/2 多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行； 
