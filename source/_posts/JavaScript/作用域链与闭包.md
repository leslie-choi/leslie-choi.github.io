---
title: javaScript中的作用域链与闭包
date: 2019-05-22 19:21:12
tags: Interview
categories: JavaScript
---

# 作用域链

JS中，只有全局作用域和局部作用域（eval开发中比较少使用不做讨论），并且作用域和执行上下文其实是完全不同的两个概念，在执行上下文这前两篇文章中也有谈到。

**作用域链，是由当前环境与上层环境的一系列变量对象组成，作用是保证了当前执行环境对符合访问权限的变量和函数的有序访问。**作⽤域链的变量只能 向上访问，变量访问到 window 对象即被终⽌，作⽤域链向下访问变量是不被允许的。


```javaScript
var a = 20;

function test() {
    var b = a + 10;
    function innerTest() {
        var c = 10;
        return b + c;
    }
    return innerTest();
}

test();
```

当代码在一个环境中执行时，会创建变量对象的一个作用域链（作用域形成的链条）

* 作用域链的前端，始终都是当前执行的代码所在环境的变量对象
* 作用域链中的下一个对象来自于外部环境，而在下一个变量对象则来自下一个外部环境，一直到全局执行环境
* 全局执行环境的变量对象始终都是作用域链上的最后一个对象

内部环境可以通过作用域链访问所有外部环境，但外部环境不能访问内部环境的任何变量和函数

如函数的执行，形成一个私有作用域，形参和当前私有作用域中声明的变量都是私有变量，保存在内部的一个变量对象中，其下一个外部环境可能是函数，也就包含了函数的内部变量对象，直到全局作用域。

当在内部函数中，需要访问一个变量的时候，首先会访问函数本身的变量对象，是否有这个变量，如果没有，那么会继续沿作用域链往上查找，直到全局作用域。如果在某个变量对象中找到则使用该变量对象中的变量值。

由于变量的查找是沿着作用域链来实现的，**所以也称作用域链为变量查找的机制。**

这个机制也说明了访问局部变量要比访问全局变量更快，因为中间的查找过程更短。但是 JavaScript 引擎在优化标识符查询方面做得很好，因此这个差别可以忽略不计

```javascript

var n = 10;
function outer(){
  function inner(){
    function center(){
      console.log(n);
    }
    center();
  }
  inner();
  var n = 15;
}
outer(); // 在内层作用域中变量提升，所以输出 undefined

```

# 闭包

1. 什么是闭包

闭包按照mdn的定义是可以访问自由变量的函数。自由变量指的是不在该函数内部声明的变量。

闭包的形式：

```javascript

    function a() {
        var num = 1
        function b() {
            console.log(num++)
        }
        return b
    }
    var c1 = a()
    c1() // '1'
    c1() // '2'
    var c2 = a()
    c2() // '1'
    c2() // '2'

```

**a、运行函数a**

* 创建函数a的全局变量对象VO(Varibale Object)，包括变量num和函数b
* 定义函数b的时候，会保存a的变量对象VO和全局变量对象到[[scope]]中
* 返回函数b，保存到c1

**b、运行c1**

* 创建c1的作用域链，该作用域链保存了a的变量对象VO
* 创建c1的VO
* 运行c1，这是发现需要访问变量num，在当前VO中不存在，于是通过作用域链进行访问，找到了保存在a的VO中的num，对它进行操作，num的值被设置成2

**c 再次运行c1，重复第二步的操作，num的值设置成3**

2. 闭包的应用

匿名自执行函数：我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量：造成全局对象过于庞大，影响访问速度（因为变量的取值是需要从原型链上遍历的）。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行1次，其内部变量无需维护，可以用闭包。

结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。

但是，有时候需要得到函数内部的局部变量，就可以通过闭包的方法，利用js变量作用域的特点,如在函数内部定义子函数，对于子函数来说，父函数就是它的全局，子函数可以访问父函数里的变量(对于整个js代码来说又是局部变量)。

闭包由两个部分组成，最典型的就是函数模式的闭包了。
它由两部分组成。执行上下文(代号parent)，以及在该执行上下文中创建的函数（代号child）。
当child执行时，如果访问了parent中变量对象中的值，那么闭包就会产生。在这里可以把child函数当作一个闭包，这个函数是连接函数内部和外部的桥梁，所以在这里函数外部可以访问到函数内的num。

```javascript

function parent(){
    var num = 50;
    function child(){
        console.log(num);
    }
    return child;
}
    var f1 = parent();  //将结果保存在全局里
    
    f1();       //50

```

函数child代指这里生成的闭包。

闭包有个优点，就是可以缓存数据，延长作用域链（不会被垃圾回收机制回收）。由于闭包的内存不会被垃圾回收机制回收，所以在使用闭包的时候要谨慎。那又是为什么不会垃圾回收机制回收呢？

举个例子：

```javaScript
	    function foo() {
	        var a = 2;
	        function innnerFoo() {
	            console.log(a);
	        }
	        return innnerFoo; 
	    }

	    var fn = foo();
	    fn();
```

在正常情况下，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。
上面的例子中。foo()执行完毕之后，按照常理，其执行环境生命周期会结束，所占内存被垃圾收集器释放。但是通过返回innerFoo，函数innerFoo的引用被保留了下来，将foo复制给了全局变量fn。全局变量（无法被回收机制清除，不知道以后会不会还会用）
这个行为，导致了foo中的变量对象a，也被保留了下来。于是，函数fn执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。
所以可以把innerFoo当成一个闭包，下图是foo的作用域链：
![markdown](https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/foo.PNG)

经典例子
```javascript
function foo(x){
    var tmp = 3;
    function bar(y){
        alert(x+y+(++tmp));
    }
    bar(10);
}

foo(2);            //永远是16
foo(2);            //永远是16
foo(2);            //永远是16
```

```javascript
function foo(x){
    var tmp = 3;
    return function(y){
        alert(x+y+(++tmp));
    }
}
var bar = foo(2);
bar(10);        //16
bar(10);        //17
bar(10);        //18
```

由于闭包的使用内存不会被回收，所以滥用闭包在低版本IE浏览器中可能会导致内存泄漏
导致内存泄漏的几种情况：

* 意外的全局变量（没有通过var声明，导致被挂在window上）：使用严格模式避免。
* 未销毁的定时器或者回调函数：手动删除定时器
* 不规范使用闭包(循环引用)：注意程序逻辑，避免“死循环”之类

```javascript
    function bindEvent() 
    { 
        var obj=document.createElement("XXX"); 
        obj.οnclick=function(){ 
            //Even if it's a empty function 
        } 
    }
    //转化为以下函数
    function bindEvent() 
    { 
        var obj=document.createElement("XXX"); 
        obj.οnclick=onclickHandler; 
    } 
    function onclickHandler(){ 
        //do something 
    }
```

# 垃圾回收机制

必要性：由于字符串、对象和数组没有固定大小，所以当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。

现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数（已经淘汰）。

## 引用计数

不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个**引用类型**赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。

```javascript
    var a = {}; //a的引用次数为0，需要时一个引用类型的值
    var b = a; //a的引用次数为1
    var c = a;//a的引用次数为2
    var b = {};  //a的引用次数减1 为 1
```

但是引用计数存在以下问题：

```javascript
    function problem() {
        var objA = new Object();
        var objB = new Object();

        objA.someOtherObject = objB;
        objB.anotherObject = objA;
    }
```
在这个例子中，**objA和objB通过各自的属性相互引用；**也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA和objB还将会继续存在，**因为他们的引用次数永远不会是0,陷入死循环。**这样的相互引用如果说很大量的存在就会导致大量的内存泄露。

## 标记清除

这是javascript中最常用的垃圾回收方式。当变量进入执行环境时（例如在函数中声明一个变量），就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。

```javascript
    function test(){
      var a = 10;//被标记进入环境  
    }
    test();//执行结束后被标记离开环境 被回收
```

该算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始（在JS中就是全局对象）扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。
此算法可以分为两个阶段，一个是标记阶段（mark），一个是清除阶段(sweep)。

1. 标记阶段，垃圾回收器会从根对象开始遍历。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。
2. 清除阶段，垃圾回收器会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。

![markdown](https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/swip.png)

在标记阶段，从根对象1可以访问到B，从B又可以访问到E，那么B和E都是可到达对象，同样的道理，F、G、J和K都是可到达对象。

在回收阶段，所有未标记为可到达的对象都会被垃圾回收器回收。

**何时开始垃圾回收?**
 
通常来说，在使用标记清除算法时，未引用对象并不会被立即回收。取而代之的做法是，垃圾对象将一直累计到内存耗尽为止。当内存耗尽时，程序将会被挂起，垃圾回收开始执行。

补充: 从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。

**标记清除算法缺陷**

* 那些无法从根对象查询到的对象都将被清除

* 垃圾收集后有可能会造成大量的内存碎片，像上面的图片所示，垃圾收集后内存中存在三个内存碎片，假设一个方格代表1个单位的内存，如果有一个对象需要占用3个内存单位的话，那么就会导致Mutator一直处于暂停状态，而Collector一直在尝试进行垃圾收集，直到Out of Memory

## Chrome V8 垃圾回收算法

Chrome 浏览器所使用的 V8 引擎就是采用的分代回收策略。目的是通过区分「临时」与「持久」对象；多回收「临时对象区」（新生代younggeneration），少回收「持久对象区」（老生代 tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。

V8的内存分代:

在V8中，主要将内存分为新生代和老生代，新生代内存 存储的为存活时间较短的对象，老生代内存 存储的为存活时间较长或常驻内存的对象，如下图：

![markdown](https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/laji.png)

### V8新生代算法（Scavenge）

在分代基础上，新生代中的对象主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法
Cheney算法是一种采用复制的方式实现的垃圾回收算法。

它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。

当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而(From空间内的)非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换(即以前的From空间释放后变为To;To空间在复制存活的对象后,变为From空间)。简而言之，在垃圾回收过程中，就是通过将存活对象在两个semispace空间之间进行复制。

Scavenge的缺点:
只能使用堆内存中的一半，这是由划分空间和复制机制所决定的。

Scavenge的优点:
Scavenge由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现。 

**Scavenge是典型的牺牲空间换取时间的算法**， 所以无法大规模地应用到所有的垃圾回收中。但可以发现，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。

### V8老生代算法（Mark-Sweep 标记清除 && Mark-Compact 标记管理）

对于老生代中的对象，由于存活对象占较大比重，再采用Scavenge的方式会有两个问题：一个是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。为此，V8在老生代中主要采用Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。

#### Mark-Sweep:

Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。与Scavenge相比，Mark-Sweep并不将内存空间划分为两半，所以不存在浪费一半空间的行为。与Scavenge复制活着的对象不同，Mark-Sweep在标记阶段遍历堆中所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。 可以看出，Scavenge中只复制活着的对象，而Mark-Sweep只清理死亡对象。 活对象在新生代中只占较小部分，死对象在老生代中只占较小部分，这是两种回收方式能高效处理的原因。

下图为Mark-Sweep在老生代空间中标记的示意图，黑色部分标记为死亡对象

![markdown](https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/old.png)

Mark-Sweep最大的问题:

在进行一次标记清除回收后，**内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。**(注意理解这句话,不要把内存想象成液体.而是固体,就像一个个散乱排列的麻将,需要进行排序处理--即后面要讲的 Mark-Compact)

#### Mark-Compact:

为了解决Mark-Sweep的内存碎片问题，Mark-Compact被提出来。Mark-Compact是标记整理的意思，是在Mark-Sweep的基础上演变而来的。它们的差别在于对象在标记为死亡后，**在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。**下图为Mark-Compact完成标记并移动存活对象后的示意图，白色格子为存活对象，深色格子为死亡对象，浅色格子为存活对象移动后留下的空洞。

### Mark-Sweep、Mark-Compact、Scavenge三种主要垃圾回收算法的简单对比

![markdown](https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/duibi.png)

从表格上看，Mark-Sweep和Mark-Compact之间，由于Mark-Compact需要移动对象，所以它的执行速度不可能很快，所以在取舍上，V8主要使用Mark-Sweep，**在空间不足以对从新生代中晋升过来的对象进行分配时才使用Mark-Compact。**

# 参考文章
[前端基础进阶（四）：详细图解作用域链与闭包](https://www.jianshu.com/p/21a16d44f150)
[前端面试查漏补缺--(二) 垃圾回收机制](https://juejin.im/post/5c6bba32f265da2db07382cf)
[JS 作用域与作用域链](https://www.jianshu.com/p/cc79f22b99fe)