---
title: 浏览器的渲染机制
date: 2019-07-06 16:06:24
tags: basic
categories: CSS
---

# DOCTYPE及其作用

由于历史的原因，浏览器对页面的渲染方式是不一样的。在W3C标准出来之前，浏览器对页面的渲染没有同一的标准，产生了差异，quirks mod（混杂模式或者兼容模式），但在W3C标准出台之后，浏览器对页面的渲染有了同一的标准即（严格模式或标准模式）。但是为了保证以前旧的页面仍然正常显示，有的浏览器就保存了这两种渲染模式（标准兼容模式）。那么究竟采用哪一种方式进行渲染，就要看DOCTYPE生命中的DTD。

**文档类型定义（DTD）Document Type Definition** 

简单说 DOCTYPE 是用来声明**文档类型和DTD规范** 的,告知浏览器的解析器用什么文档标准解析这个文档。，一个主要用途就是文件的合法性验证。如果文件代码不合法，那么浏览器解析的时候就会出错。
是一系列的语法规则，用来定义XML或者HTML的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式。
html5不基于 SGML，因此不需要对DTD进行引用，也就没有严格模式与宽松模式的区别，html5有相对宽松的语法，事实上，已经尽可能大的实现了向后兼容（老版本）。

常见的html的DOCTYPE

HTML5 <!DOCTYPE html>

HTML4 严格模式 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"> 

HTML4 宽松模式 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

这里可以看到严格模式和宽松模式的区别主要在于后缀的dtd文件的引用。严格模式不包含展示性和弃用元素（比如font），宽松模式包含所有的HTML元素和属性。

# 浏览器的渲染机制

![markdown](https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/tree.png)

要了解浏览器的渲染机制，需要先明白以下的概念：

1. DOM：Document Object Model（文档对象模型），当我们打开⼀个⽹⻚时，浏览器都会去请求对应的 HTML ⽂件。虽然平时我 们写代码时都会分为 JS 、 CSS 、 HTML ⽂件，也就是字符串，但是计算机 硬件是不理解这些字符串的，所以在⽹络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，浏览器会有html解析器进行解析，它会将这些字节数据转换为 字符串，也就是我们写的代码。（字节流转换成为字符流）

当数据转换为字符串以后，浏览器会先将这些字符串通过**词法分析转换为标记 （ token ）**，这⼀过程在词法分析中叫做标记化（ tokenization ）

那么什么是标记呢？这其实属于编译原理这⼀块的内容了。简单来说，标记还 是字符串，是构成代码的⼩单位。这⼀过程会将代码分拆成⼀块块，并给这 些内容打上标记，便于理解这些⼩单位的代码是什么意思

当结束标记化后，**通过词法分析**，这些标记会紧接着转换为 Node ，这些 Node 会根据 不同 Node 之前的联系构建为树形的数据结构，称为 DOM 树

2. CSSOM：CSS Object Model，浏览器将CSS解析成树形的数据结构，简称CSSOM（步骤类似上一步）

3. Render Tree: DOM和CSSOM合并后生成Render Tree(但是如果遇到script标签的时候，会执行并阻塞渲染)

在这⼀过程中，不是简单的将两者合并就⾏了。渲染树只会包括需要显示的节点和这些节 点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。

4. Layout: 计算出Render Tree每个节点的具体位置。（布局）

5. Painting：通过显卡，开始调用 GPU 绘制，合成图层，将Layout后的节点内容分别呈现到屏幕上。（渲染）

PS：
* css加载不会阻塞DOM树的解析
* css和script的加载会阻塞DOM树的渲染（白屏）
* css加载会阻塞后面js语句的执行，但是不会阻塞外部脚本的加载（因为 Renderer 进程中 JS 线程和渲染线程是互斥的）

# 重排（回流）Reflow **（引起DOM树重新计算的行为）**

DOM结构中的各个元素都有自己的盒子，这些都需要浏览器根据各种样式来计算，并根据计算结果将元素放到它该出现的位置，这个过程称为reflow。
以下是触发reflow的几种方法：

1. 增加、删除、修改DOM节点的时候，会导致Reflow
2. 移动DOM的位置，或者生成动画的时候
3. 修改CSS样式的时候
4. Resize窗口的时候（移动端没有这个问题），或者滚动的时候
5. 修改网页的默认字体时
6. 获取某些属性，包括offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle()，**获取时应当做适当的缓存**

PS: 针对以上的第六点，为什么会导致获取某些属性的时候会导致浏览器的重排？

现代浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是**当你获取布局信息的操作的时候，为了获取更加准确的信息，会强制队列刷新，也刷新了缓冲区域**，所以必要的时候，获取的时候需要做适当的缓存。

# 重绘Repaint **（元素样式的改变触发浏览器的行为）**

当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称为Repaint

触发Repaint
1. DOM改动
2. CSS改动

重排一定会导致重绘（改变网页的位置），但是重绘不一定会导致重排（如颜色的改变）。

减少重排的几个方法：

* 样式集中改变，减少对DOM的操作
* 对于多次重排的元素，使用absolute或者fixed脱离文档流
* 尽量减少使用table布局，因为一个小的改动会导致整个table的重新布局，通常要浪费同等元素的时间的3倍
* 不要在布局信息改变的时候做DOM查询
* 动画元素脱离文档流（浮动、绝对定位和固定定位），减少回流的Render Tree的规模
* 使用opacity 替代visibility，因为visibility 会触发重绘，而使用opacity 不会
* 使用visibility替换display:none，因为前者只会引起重绘，后者会引起回流改变布局
* 通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）


PS：为什么操作DOM非常昂贵？

**操作DOM会导致重排和重绘，重排会占用、消耗CPU; 重绘会占用、消耗GPU。操作频繁会使得电脑卡顿**

# 回流与重绘相关的eventLoop

* 当 Event loop 执⾏完 Microtasks 后，会判断 document 是否需要更新。- 因为浏览 器是 60Hz 的刷新率，每 16ms 才会更新⼀次。 
* 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是⾄少 16ms 才会触发⼀次，并且⾃带节流功能。 
* 判断是否触发了 media query 
* 更新动画并且发送事件
* 判断是否有全屏操作事件 执⾏ requestAnimationFrame 回调 执⾏ IntersectionObserver 回调，该⽅法⽤于判断元素是否可⻅，可以⽤于懒加载上，但是兼容性不好
* 更新界⾯
以上就是⼀帧中可能会做的事情。如果在⼀帧中有空闲时间，就会去执⾏ requestIdleCallback 回调。

# 输入URL到浏览器显示页面发生了什么

1. 在浏览器地址栏输⼊URL
2. 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 
  1. 如果资源未缓存，发起新请求 
  2. 如果已缓存，检验是否⾜够新鲜，⾜够新鲜直接提供给客户端，否则与服务器进⾏验 证。 
  3. 检验新鲜通常有两个HTTP头进⾏控制 Expires 和 Cache-Control ： HTTP1.0提供Expires，值为⼀个绝对时间表示缓存新鲜⽇期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的Y⼤新鲜时间
3. 浏览器解析URL获取协议，主机，端⼝，path 
4. 浏览器组装⼀个HTTP（GET）请求报⽂ 
5. 浏览器获取主机ip地址，过程如下： 
  1. 浏览器缓存 
  2. 本机缓存 
  3. hosts⽂件 
  4. 路由器缓存 
  5. ISP DNS缓存 
  6. DNS递归查询（可能存在负载均衡导致每次IP不⼀样） 

DNS 的作用就是通过域名查询到具体的 IP。

因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。

* 浏览器输入www.google.com时，请求发起后，游览器首先会解析这个域名，首先它会查看**本地硬盘的 hosts 文件**，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。
* 如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到**本地DNS(域名分布系统)服务器**。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。
* 查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向**DNS根服务器进行查询**，DNS根服务器找出负责 com 这个⼀级域名的服务器 
* 根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到**域服务器**上去继续查询，并给出域服务器的地址。这种过程是迭代的过程
* 本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，**也不会直接返回域名和IP地址的对应关系**，而是告诉本地DNS服务器，你的**域名的解析服务器的地址**
* 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。

本地硬盘host文件=>本地DNS服务器(中国移动，中国电信)=>根DNS服务器=>域服务器=>域名的解析服务器的地址=>返回给本地DNS服务器，并作缓存。

6. 打开⼀个socket与⽬标IP地址，端⼝建⽴TCP链接，三次握⼿如下： 
  1. 客户端发送⼀个TCP的SYN=1，Seq=X的包到服务器端⼝ 
  2. 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 
  3. 客户端发送ACK=Y+1， Seq=Z 
9. 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 
10. 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 
11. 服务器将响应报⽂通过TCP连接发送回浏览器，关闭TCP连接四次挥手
12. 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重⽤，关闭TCP连接的四 次握⼿如下： 
  1. 主动⽅发送Fin=1， Ack=Z， Seq= X报⽂ 
  2. 被动⽅发送ACK=X+1， Seq=Z报⽂ 
  3. 被动⽅发送Fin=1， ACK=X， Seq=Y报⽂ 
  4. 主动⽅发送ACK=Y， Seq=X报⽂ 
13. 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同
14. 如果资源可缓存，进⾏缓存 
15. 对响应进⾏解码（例如gzip压缩） 
16. 根据资源类型决定如何处理（假设资源为HTML⽂档）
17. 解析HTML⽂档，构件DOM树，下载资源，构造CSSOM树，执⾏js脚本，这些操作没有严 格的先后顺序，以下分别解释 
18. 构建DOM树： 
  1. Tokenizing：根据HTML规范将字符流解析为标记 
  2. Lexing：词法分析将标记转换为对象并定义属性和规则 
  3. DOM construction：根据HTML标记关系将对象组成DOM树 
19. 解析过程中遇到图⽚、样式表、js⽂件，启动下载 
20. 构建CSSOM树： 
  1. Tokenizing：字符流转换为标记流
  2. Node：根据标记创建节点 
  3. CSSOM：节点创建CSSOM树 
21. 根据DOM树和CSSOM树构建渲染树: 
  1. 从DOM树的根节点遍历所有可⻅节点，不可⻅节点包括：
    1) script , meta 这样本身 不可⻅的标签。
    2)被css隐藏的节点，如 display: none 
  2. 对每⼀个可⻅节点，找到恰当的CSSOM规则并应⽤ 
  3. 发布可视节点的内容和计算样式 
22. js解析如下： 
  1. 浏览器创建Document对象并解析HTML，将解析到的元素和⽂本节点添加到⽂档中，此 时document.readystate为loading 
  2. HTML解析器遇到没有async和defer的script时，将他们添加到⽂档中，然后执⾏⾏内 或外部脚本。这些脚本会同步执⾏，并且在脚本下载和执⾏时解析器会暂停。这样就可 以⽤document.write()把⽂本插⼊到输⼊流中。同步脚本经常简单定义函数和注册事件 处理程序，他们可以遍历和操作script和他们之前的⽂档内容 
  3. 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析⽂档。脚本会在它 下载完成后尽快执⾏，但是解析器不会停下来等它下载。异步脚本禁⽌使⽤ document.write()，它们可以访问⾃⼰script和之前的⽂档元素 
  4. 当⽂档完成解析，document.readState变成interactive 
  5. 所有defer脚本会按照在⽂档出现的顺序执⾏，延迟脚本能访问完整⽂档树，禁⽌使⽤ document.write() 
  6. 浏览器在Document对象上触发DOMContentLoaded事件 
  7. 此时⽂档完全解析完成，浏览器可能还在等待如图⽚等内容加载，等这些内容完成载⼊ 并且所有异步脚本完成载⼊和执⾏，document.readState变为complete，window触发 load事件
23. 显示⻚⾯（HTML解析过程中会逐步显示⻚⾯）


# requestAnimationFrame

传统的 javascript 动画是通过定时器 setTimeout 或者 setInterval 实现的。但是定时器动画一直存在两个问题，第一个就是动画的循时间环间隔不好确定，设置长了动画显得不够平滑流畅，设置短了浏览器的重绘频率会达到瓶颈，推荐的最佳循环间隔是17ms（大多数电脑的显示器刷新频率是60Hz，1000ms/60）；第二个问题是定时器第二个时间参数只是指定了多久后将动画任务添加到浏览器的UI线程队列中，如果**UI线程处于忙碌状态，那么动画不会立刻执行（UI线程和JS线程也是互斥的）。**为了解决这些问题，H5 中加入了 requestAnimationFrame

**优点：**

1. requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率
2. 在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量
3. requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销

须注意的是，requestAnimationFrame也属于宏任务。使用方法和setTimeout一样。

# 浏览器的工作原理

## 进程和线程的概念

* 进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位（进程是一个工厂，工厂有它的独立资源，并且工厂之间相互独立）

* 线程：是进程中的一部分，一个没有线程的进程也可以被看作是单线程的，是CPU调度的一个基本单位（线程是工厂中的工人，多个工人协作完成任务，一个工厂可以有一个或者多个工人，工人之间共享空间）

进程之间的通信方式：

* 无名管道：半双工通信方式（即数据只能在一个方向上流动），数据只能单向流动并且只能在具有亲缘关系的进程间使用
* 有名管道：也是半双工通信方式，但是允许没有亲缘进程之间的通信
* 高级管道：将另一个程序当作一个新的程序在当前程序进程中启动，则这个进程算是当前程序的子进程
* 信号：用于通知接受进程某个事件已经发生
* 消息队列：是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识
* 共享内存：指两个或多个进程共享一个给定的存储区

## 浏览器的进程

### 浏览器的单进程时代

在前端处于刀耕火种的年代，微软通过在它的电脑设备上绑定了ie浏览器，逐渐的打败了昔日强敌网景，独霸整个pc时代。以ie6为例，这款浏览器就是典型的单进程浏览器，而且还是单线程浏览器。所以你可以想象，这个浏览器是奇慢无比，一个网页挂了就会导致浏览器里所有的页面都挂了。于是乎在后面的ie浏览器，通过多线程技术来试图提升浏览器的速度，但其实单进程无论怎么魔改，都会涉及到这些问题：

1. 不稳定。毕竟只要一个线程挂了就整个浏览器挂了，所以整个浏览器很不稳定。
2. 不流畅。比如在通过网络获取资源，到渲染流程，如果浏览器上还有插件则还要考虑插件的运行，如果有一个脚本是死循环的，则导致所有页面都要等待这个脚本执行完毕，会导致整个页面十分的不流畅。并且单进程浏览器关闭一个页面也会存在内存泄漏的问题，毕竟不是多进程。多进程关掉一个页面相当于关掉一个进程，系统会自动回收资源。所以这样子会导致浏览器开的越久就越占用内存。
3. 不安全。上面说到线程是可以共享进程里的资源的，如果一个插件是恶意的，它可以影响到整个浏览器，甚至可以控制你的电脑，来盗取账号密码。除了插件外，还有一些脚本可以通过钻漏洞来获取权限，引发很多严重的后果。

### 浏览器的多进程时代

现代浏览器以chrome浏览器为例，目前的浏览器的多进程架构大致上是这样的：

1. 浏览器进程。该进程主要是负责界面显示、用户交互、子进程管理，同时提供存储等功能。
2. 网络进程。该进程主要负责页面的网络资源加载，比如在地址栏输入一个网页地址，网络进程会将请求后得到的资源交给渲染进程处理。
3. 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。（浏览器的渲染进程是多线程的）
4. GPU进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
5. 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限


# webWorker实现多线程

Web Worker 是HTML5标准的一部分，这一规范定义了一套 API，它允许一段JavaScript程序运行在主线程之外的另外一个线程中。工作线程允许开发人员编写能够长时间运行而不被用户所中断的后台程序， 去执行事务或者逻辑，并同时保证页面对用户的及时响应，可以将一些大量计算的代码交给web worker运行而不冻结用户界面，web worker 就是为了解决这种花费大量时间的复杂运算而诞生的！

* 允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）

* JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）

所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，
只待计算出结果后，将结果返回给主线程即可。
而且注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。

Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。

# 参考文章：

[现代浏览器工作原理（一）——浏览器进程](https://juejin.im/post/5d765572e51d45621320318e)