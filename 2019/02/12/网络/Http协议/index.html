<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yoursite.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta name="description" content="TCP协议 互联网由一整套协议构成。 图片说明：顶层协议是应用层协议 &#x3D;&gt; TCP协议 &#x3D;&gt; IP协议 &#x3D;&gt; 以太网协议（应用层&#x3D;&gt;传输层&#x3D;&gt;网络层&#x3D;&gt;链路层） 以太网协议：最底层的协议，可以解决子网内部的点对点通讯。 IP 协议：IP 协议，可以解决多个局域网之间互通，可以连接多个局域网，定义了一套自己的地址规则，实现了路由的功能，允许某个局域网的 A 主机，">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP和TCP">
<meta property="og:url" content="http://yoursite.com/2019/02/12/%E7%BD%91%E7%BB%9C/Http%E5%8D%8F%E8%AE%AE/index.html">
<meta property="og:site_name" content="404 not found">
<meta property="og:description" content="TCP协议 互联网由一整套协议构成。 图片说明：顶层协议是应用层协议 &#x3D;&gt; TCP协议 &#x3D;&gt; IP协议 &#x3D;&gt; 以太网协议（应用层&#x3D;&gt;传输层&#x3D;&gt;网络层&#x3D;&gt;链路层） 以太网协议：最底层的协议，可以解决子网内部的点对点通讯。 IP 协议：IP 协议，可以解决多个局域网之间互通，可以连接多个局域网，定义了一套自己的地址规则，实现了路由的功能，允许某个局域网的 A 主机，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/TCP.png">
<meta property="og:image" content="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/sanwo.png">
<meta property="og:image" content="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/sihui.png">
<meta property="og:image" content="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/http.jpg">
<meta property="og:image" content="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/%E6%8A%A5%E6%96%872.png">
<meta property="og:image" content="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/get%26post.jpeg">
<meta property="og:image" content="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/httpVersion.png">
<meta property="og:image" content="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/https.png">
<meta property="article:published_time" content="2019-02-12T14:06:14.000Z">
<meta property="article:modified_time" content="2021-04-20T16:53:51.902Z">
<meta property="article:author" content="leslie choi">
<meta property="article:tag" content="Interview">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/TCP.png">


<link rel="canonical" href="http://yoursite.com/2019/02/12/%E7%BD%91%E7%BB%9C/Http%E5%8D%8F%E8%AE%AE/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;02&#x2F;12&#x2F;%E7%BD%91%E7%BB%9C&#x2F;Http%E5%8D%8F%E8%AE%AE&#x2F;&quot;,&quot;path&quot;:&quot;2019&#x2F;02&#x2F;12&#x2F;网络&#x2F;Http协议&#x2F;&quot;,&quot;title&quot;:&quot;HTTP和TCP&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>HTTP和TCP | 404 not found</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">404 not found</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.</span> <span class="nav-text">TCP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%88%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">TCP建立连接（三次握手）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%EF%BC%88%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">TCP关闭连接（四次挥手）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP%E5%92%8CTCP%EF%BC%88User-Datagram-Protocol%EF%BC%8C%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.</span> <span class="nav-text">UDP和TCP（User Datagram Protocol，用户数据报协议）的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0UDP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">1.4.</span> <span class="nav-text">如何实现UDP的可靠传输</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.</span> <span class="nav-text">http协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#http-%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">http 的两个重要特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http-%E6%8A%A5%E6%96%87"><span class="nav-number">2.2.</span> <span class="nav-text">http 报文</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="nav-number">2.2.1.</span> <span class="nav-text">http请求报文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="nav-number">2.2.2.</span> <span class="nav-text">http响应报文</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#get-%E5%92%8C-post-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="nav-number">2.3.</span> <span class="nav-text">get 和 post 的主要区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Http%E7%9A%84%E7%89%88%E6%9C%AC"><span class="nav-number">2.4.</span> <span class="nav-text">Http的版本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http%E7%AE%A1%E7%BA%BF%E5%8C%96"><span class="nav-number">2.5.</span> <span class="nav-text">http管线化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http-1-1-%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8D%87%E7%BA%A7"><span class="nav-number">2.6.</span> <span class="nav-text">http 1.1 做了哪些升级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Http-1-1-%E4%B8%AD%E7%9A%84%E5%85%AB%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">2.7.</span> <span class="nav-text">Http 1.1 中的八种方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84Content-Type"><span class="nav-number">2.8.</span> <span class="nav-text">几个常见的Content-Type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-HTTP-%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8E%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="nav-number">2.9.</span> <span class="nav-text">常用的 HTTP 请求头与响应头</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Https"><span class="nav-number">3.</span> <span class="nav-text">Https</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SSL%E5%92%8CTLS"><span class="nav-number">3.1.</span> <span class="nav-text">SSL和TLS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SSL-TLS-%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">3.2.</span> <span class="nav-text">SSL&#x2F;TLS 四次握手</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http2-0"><span class="nav-number">4.</span> <span class="nav-text">http2.0</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7"><span class="nav-number">4.1.</span> <span class="nav-text">二进制分帧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text">多路复用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#header%E5%8E%8B%E7%BC%A9"><span class="nav-number">4.3.</span> <span class="nav-text">header压缩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A8%E9%80%81"><span class="nav-number">4.4.</span> <span class="nav-text">服务端推送</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http3-0"><span class="nav-number">5.</span> <span class="nav-text">http3.0</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#QUIC"><span class="nav-number">5.1.</span> <span class="nav-text">QUIC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-1"><span class="nav-number">5.1.1.</span> <span class="nav-text">多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-RTT"><span class="nav-number">5.1.2.</span> <span class="nav-text">0-RTT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A0%E9%94%99%E6%9C%BA%E5%88%B6"><span class="nav-number">5.1.3.</span> <span class="nav-text">纠错机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">6.</span> <span class="nav-text">常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%85%B3%E9%97%AD%E7%9A%84%E6%97%B6%E5%80%99%E5%8D%B4%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">为什么连接的时候是三次握手，关闭的时候却是四次挥手？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TIME-WAIT%E7%8A%B6%E6%80%81%E9%9C%80%E8%A6%81%E7%BB%8F%E8%BF%872MSL-%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E6%AE%B5%E7%94%9F%E5%AD%98%E6%97%B6%E9%97%B4-%E6%89%8D%E8%83%BD%E8%BF%94%E5%9B%9E%E5%88%B0CLOSE%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-number">6.2.</span> <span class="nav-text">为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="nav-number">6.3.</span> <span class="nav-text">为什么不能用两次握手进行连接？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">6.4.</span> <span class="nav-text">如果已经建立了连接，但是客户端突然出现故障了怎么办？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-2%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8CHTTP1-1%E4%B8%AD%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%A4%8D%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">6.5.</span> <span class="nav-text">HTTP&#x2F;2的多路复用和HTTP1.1中的长连接复用有什么区别？</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">leslie choi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/%E7%BD%91%E7%BB%9C/Http%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          HTTP和TCP
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-12 22:06:14" itemprop="dateCreated datePublished" datetime="2019-02-12T22:06:14+08:00">2019-02-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-21 00:53:51" itemprop="dateModified" datetime="2021-04-21T00:53:51+08:00">2021-04-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/TCP.png" alt="markdown"></p>
<p>互联网由一整套协议构成。</p>
<p>图片说明：顶层协议是应用层协议 =&gt; TCP协议 =&gt; IP协议 =&gt; 以太网协议（应用层=&gt;传输层=&gt;网络层=&gt;链路层）</p>
<p>以太网协议：最底层的协议，可以解决子网内部的点对点通讯。</p>
<p>IP 协议：IP 协议，可以解决多个局域网之间互通，可以连接多个局域网，定义了一套自己的地址规则，实现了路由的功能，允许某个局域网的 A 主机，向另一个局域网的 B 主机发送消息。（PS：路由器就是基于 IP 协议。所以局域网之间要靠路由器连接）</p>
<p>题外话：路由原理就是路由器内部有一张路由表，规定 A 段 IP 地址走出口一，B 段 IP 地址走出口二。。。根据这样实现了数据包的转发。</p>
<p>TCP 协议：IP 协议只是一个地址协议，并不能保证数据的完整性。如果缓存满了，新进来的数据包就会丢失，所以这个时候需要发现丢了哪一个包，以及如何重新发送这个包，所以这个时候需要使用到 TCP 协议。以太网数据包的负载是 1500 字节，TCP 数据包的负载在 1400 字节左右。</p>
<h2 id="TCP建立连接（三次握手）"><a href="#TCP建立连接（三次握手）" class="headerlink" title="TCP建立连接（三次握手）"></a>TCP建立连接（三次握手）</h2><p>HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</p>
<ul>
<li>第一次握手：建立连接时，客户端发送 syn 包（syn=1,seq=x）到服务器，并进入 SYN_SENT 状态，<strong>服务端得到结论：客户端的发送能力、服务端的接收能力正常。</strong></li>
<li>第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=x+1,seq=y），同时自己也发送一个 ACK 包，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态，客户端接收到，<strong>于是客户端得到结论：服务端的接收和发送能力正常，客户端的接收发送能力正常，但是此时服务器并不能确认客户端的接收能力是否正常</strong></li>
<li>第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=y+1,seq=z），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP连接成功）状态，<strong>服务端得到结论：客户端和服务端的接收发送能力都正常，完成三次握手。</strong></li>
</ul>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/sanwo.png" alt="markdown"></p>
<h2 id="TCP关闭连接（四次挥手）"><a href="#TCP关闭连接（四次挥手）" class="headerlink" title="TCP关闭连接（四次挥手）"></a>TCP关闭连接（四次挥手）</h2><p>由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。</p>
<ul>
<li>客户端 A 发送一个 FIN，用来关闭客户 A 到服务器B的数据传送，但是仍然可以接收数据( Fin_wait_1 )</li>
<li>服务器 B 收到这个 FIN，它发回一个 ACK 应答，表明接收到请求但是还未准备关闭连接，然后确认序号为收到的序号加1。和 SYN 一样，一个 FIN 将占用一个序号(服务端 closed_wait，客户端 Fin_wait_2)</li>
<li>服务器 B 关闭与客户端 A 的连接，发送一个 FIN 给客户端 A(服务端 Last_ack,客户端 time_wait)</li>
<li>客户端 A 发回 ACK 报文确认，并将确认序号设置为收到序号加1 (服务端 closed，然后经过 2MSL后服务端进入 closed)</li>
</ul>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/sihui.png" alt="markdown"></p>
<h2 id="UDP和TCP（User-Datagram-Protocol，用户数据报协议）的区别"><a href="#UDP和TCP（User-Datagram-Protocol，用户数据报协议）的区别" class="headerlink" title="UDP和TCP（User Datagram Protocol，用户数据报协议）的区别"></a>UDP和TCP（User Datagram Protocol，用户数据报协议）的区别</h2><ol>
<li>都是位于传输层，TCP 是面向连接的，而<strong>udp 是无连接的</strong>，即发送数据前不需要先建立连接</li>
<li>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达；UDP 尽最大努力交付，即不保证可靠交付。并且 TCP 可靠，面向连接不会丢失数据适合大数据量的传输</li>
<li>TCP 面向字节流，UDP 面向报文，并且网络阻塞不会使得发送的速率降低，所以会出现丢包（适合视频会议或者直播）。　</li>
<li>TCP 只能是一对一的，而 UDP 可以一对多</li>
<li>TCP 首部较大为20字节，UDP 只有8字节</li>
</ol>
<h2 id="如何实现UDP的可靠传输"><a href="#如何实现UDP的可靠传输" class="headerlink" title="如何实现UDP的可靠传输"></a>如何实现UDP的可靠传输</h2><p>TCP 是通过确认机制和超时重传机制实现可靠传输</p>
<p>UDP 它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用 UDP 较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照 tcp 可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<p>关键在于两点，从应用层角度考虑：</p>
<ol>
<li><p>提供超时重传，能避免数据包丢失。</p>
</li>
<li><p>提供确认序列号，可以对数据报进行确认和排序。</p>
</li>
</ol>
<p><strong>RUDP</strong></p>
<p>RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。在不干扰协议的实时特性的同时，可靠 UDP 的拥塞控制机制允许 TCP 方式下的流控制行为。</p>
<h1 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h1><p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/http.jpg" alt="markdown"></p>
<p>HTTP 协议是<strong>Hyper Text Transfer Protocol（超文本传输协议）</strong>的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议，也就是说所有的 www 服务器都必须要遵循这个标准。</p>
<p>HTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>
<p>HTTP 协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p>HTTP 请求由三部分组成，分别是：<strong>请求行、请求头、请求正文</strong></p>
<h2 id="http-的两个重要特点"><a href="#http-的两个重要特点" class="headerlink" title="http 的两个重要特点"></a>http 的两个重要特点</h2><p><strong>无连接：</strong> 限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。（但是随着网络的发展，每次都要建立一次 TCP 连接就显得很低效，后来，Keep-Alive 被提出用来解决这效率低的问题。）</p>
<p><strong>无状态：</strong> 指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是发送完，不会记录任何信息，于是，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。（简单场景购物车）</p>
<h2 id="http-报文"><a href="#http-报文" class="headerlink" title="http 报文"></a>http 报文</h2><p>用于 HTTP 协议交互的信息被称为 http 报文。HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CE+LF）来划分。通常，并不一定要有报文主体。在 http1.1 中，报文是通信的基本单位，由8位组字节流组成，用于 HTTP 通信。（http2.0采用二进制分帧）</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/%E6%8A%A5%E6%96%872.png" alt="markdown"></p>
<h3 id="http请求报文"><a href="#http请求报文" class="headerlink" title="http请求报文"></a>http请求报文</h3><ul>
<li>请求行：包含用于请求的方法，请求 uri 和 http 版本   （GET/HTTP/1.1）</li>
<li>请求头</li>
<li>空行</li>
<li>请求体：根据实际请求需要可能包含一个消息实体</li>
</ul>
<h3 id="http响应报文"><a href="#http响应报文" class="headerlink" title="http响应报文"></a>http响应报文</h3><ul>
<li>状态行：包含表明响应结果的 http 版本和状态码，状态描述 （HTTP/1.1 200 OK）</li>
<li>响应头：包括通用头部、响应头部和实体头部</li>
<li>空行</li>
<li>响应体</li>
</ul>
<h2 id="get-和-post-的主要区别"><a href="#get-和-post-的主要区别" class="headerlink" title="get 和 post 的主要区别"></a>get 和 post 的主要区别</h2><p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/get%26post.jpeg" alt="markdown"></p>
<p><strong>1. get在浏览器回退时是无害的，而post会再次请求。</strong><br><strong>2. get产生的url地址可以被收藏（即书签），而post不会。</strong><br>3. get请求会被浏览器主动缓存，而post不会，除非手动设置。<br>4. get请求只能进行url编码，而post支持多种编码方式。<br><strong>5. get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。</strong><br><strong>6. get 请求在url中传送的参数有长度限制（一般限制在2kb~8kb之间，但是更加常见的是在1kb之内，这个⻓度限制是浏览器规定的），而post没有（实际大小根据服务器情况而定）</strong><br>7. 对参数的数据类型，get只接受ascll字符，而post没有限制。<br>8. post比get更安全，因为参数直接暴露在url上，所以不能用来传递敏感信息。<br><strong>9. get参数通过url传递，poet放在request body中。</strong><br>10. GET产生一个TCP数据包;POST产生两个TCP数据包。</p>
<p>对于GET方式的请求，浏览器会把<strong>http header和data一并发送出去</strong>，服务器响应200(返回数据)</p>
<p>而对于POST，浏览器先发送**header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)**，这也就是为什么GET请求产生一个TCP数据包，而POST请求产生两个数据包。<br>但是在网络环境较好的情况下，发送一次包的时间和发送两次包的时间差别几乎是可以无视的。而在网络环境较差的情况下，发送两次包的TCP在验证数据包的完整性上，有非常大的优点。（但是并不是所有的浏览器都会在POST请求中发送两次包，Firefox就只发送一次。）</p>
<p>HTTP缺点：</p>
<ol>
<li>通信使用明文（ 不加密） ， 内容可能会被窃听。</li>
<li>不验证通信方的身份， 因此有可能遭遇伪装。</li>
<li>无法证明报文的完整性， 所以有可能已遭篡改。</li>
</ol>
<h2 id="Http的版本"><a href="#Http的版本" class="headerlink" title="Http的版本"></a>Http的版本</h2><ol>
<li>HTTP 0.9作为HTTP协议的第一个版本。是非常弱的。请求(Request)只有一行,比如: GET <a target="_blank" rel="noopener" href="http://www.leautolink.com./">www.leautolink.com。</a></li>
<li>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上。</li>
<li>HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。</li>
</ol>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/httpVersion.png" alt="markdown"></p>
<h2 id="http管线化"><a href="#http管线化" class="headerlink" title="http管线化"></a>http管线化</h2><p>在使用持久连接（因此低于HTTP1.1版本无法开启管线化）的情况下，某个连接消息的传递类似于</p>
<p>请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 - &gt; 响应3</p>
<p>管线化：某个连接上的消息变成了类似这样 </p>
<p>请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3</p>
<ol>
<li>那么持久连接和管线化的区别在于：</li>
</ol>
<p>持久连接的一个缺点是请求和响应式是顺序执行的，只有在请求1的响应收到之后，才会发送请求2，而管线化不需要等待上一次请求得到响应就可以进行下一次请求。<strong>实现并行发送请求。</strong> </p>
<ol start="2">
<li><p>只有GET和HEAD要求可以进行管线化，而POST则有所限制。</p>
</li>
<li><p>初次创建连接时也不应启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议。</p>
</li>
<li><p>HTTP1.1要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败，并且开启管线化很可能不会带来大幅度的性能提升，而且现在很多服务器端和代理程序对管线化的支持并不好，现代浏览器Chrome和Firefox默认并未开启管线化支持。</p>
</li>
</ol>
<h2 id="http-1-1-做了哪些升级"><a href="#http-1-1-做了哪些升级" class="headerlink" title="http 1.1 做了哪些升级"></a>http 1.1 做了哪些升级</h2><p><strong>缓存处理：</strong> 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</p>
<p><strong>带宽优化及网络连接的使用：</strong> HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
<p><strong>错误通知的管理：</strong> 在 HTTP1.1 中新增了24个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<p><strong>Host头处理：</strong> 在HTTP1.0 中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</p>
<p><strong>长连接（持久连接）：</strong> HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection：keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。</p>
<h2 id="Http-1-1-中的八种方法"><a href="#Http-1-1-中的八种方法" class="headerlink" title="Http 1.1 中的八种方法"></a>Http 1.1 中的八种方法</h2><ul>
<li><p>OPTIONS:<br>这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用 ‘*’ 来代替资源名称,向 Web 服务器发送 OPTIONS 请求,可以测试服务器功能是否正常运作。</p>
</li>
<li><p>HEAD:<br>与 GET 方法一样,都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于,使用这个方法可以在不必传输全部内容的情况下,就可以获取其中“关于该资源的信息”(元信息或称元数据)。</p>
</li>
<li><p>GET:<br>向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据,而不应当被用于产生“副作用”的操作中,例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访问。参见安全方法</p>
</li>
<li><p>POST:<br>向指定资源提交数据,请求服务器进行处理(例如提交表单或者上传文件)。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源,或二者皆有。</p>
</li>
<li><p>PUT:<br>向指定资源位置上传其最新内容。</p>
</li>
<li><p>DELETE:<br>请求服务器删除 Request-URI 所标识的资源。</p>
</li>
<li><p>TRACE:<br>回显服务器收到的请求,主要用于测试或诊断。</p>
</li>
<li><p>CONNECT:<br>把请求连接转换到透明的 TCP/IP 通道。通常用于 SSL 加密服务器的链接(经由非加密的 HTTP 代理服务器)。</p>
</li>
</ul>
<h2 id="几个常见的Content-Type"><a href="#几个常见的Content-Type" class="headerlink" title="几个常见的Content-Type"></a>几个常见的Content-Type</h2><p><strong>第一类：raw 原始类型，可以上传任意格式的文本，比如 text、json、xml、html（中文不进行编码）</strong></p>
<ul>
<li><p>text/html  ：HTML格式</p>
</li>
<li><p>text/plain ：纯文本格式      </p>
</li>
<li><p>text/xml   ：XML格式</p>
</li>
<li><p>image/gif  ：gif图片格式    </p>
</li>
<li><p>image/jpeg ：jpg图片格式 </p>
</li>
<li><p>image/png  ：png图片格式</p>
</li>
<li><p>application/xml     ： XML数据格式</p>
</li>
<li><p>application/json    ： JSON数据格式</p>
</li>
<li><p>application/pdf     ： pdf格式  </p>
</li>
<li><p>application/msword  ： Word文档格式</p>
</li>
<li><p>application/octet-stream ： 二进制流数据（如文件下载）</p>
</li>
</ul>
<p><strong>第二类：application/x-www-form-urlencoded，会将表单内的数据转换拼接成 key-value 对</strong></p>
<ul>
<li>application/x-www-form-urlencoded ：</li>
</ul>
<p><code>&lt;form encType=&quot;&quot;&gt;</code>中默认的encType，<br>form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）。<br>服务器收到的raw body会是，name=aaa&amp;key=bbb。</p>
<p><strong>第三类：multipart/form-data，将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件</strong></p>
<ul>
<li>multipart/form-data ： 表单上传文件</li>
</ul>
<h2 id="常用的-HTTP-请求头与响应头"><a href="#常用的-HTTP-请求头与响应头" class="headerlink" title="常用的 HTTP 请求头与响应头"></a>常用的 HTTP 请求头与响应头</h2><p>请求头：</p>
<ul>
<li>Accept            可接受的响应内容类型（Content-Types）           Accept: text/plain</li>
<li>Accept-Language   可接受的响应内容语言列表                        Accept-Language: en-US</li>
<li>Cache-Control     用来指定当前的请求/回复中的，是否使用缓存机制     Cache-Control: no-cache</li>
<li>Host              表示服务器的域名以及服务器所监听的端口号          Host: <a target="_blank" rel="noopener" href="http://www.itbilu.com/">www.itbilu.com:80</a></li>
<li>Origin            发起一个针对跨域资源共享的请求                   Origin: <a target="_blank" rel="noopener" href="http://www.itbilu.com/">http://www.itbilu.com</a></li>
<li>If-Modified-Since 允许在对应的资源未被修改的情况下返回304未修改     If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT    </li>
</ul>
<p>响应头：</p>
<ul>
<li>Access-Control-Allow-Origin     指定哪些网站可以跨域源资源共享      Access-Control-Allow-Origin: *</li>
<li>ETag     对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列  ETag: “737060cd8c284d8af7ad3082f209582d”    </li>
<li>Last-Modified        所请求的对象的最后修改日期          Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT</li>
<li>Expires              指定一个日期/时间，超过该时间则认为此回应已经过期  Expires: Thu, 01 Dec 1994 16:00:00 GMT</li>
</ul>
<h1 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h1><p>Https协议其实是基于Http的，多了个s其实就是Secure，所以也就是<strong>Hypertext Transfer Protocol Secure（超文本传输安全协议）</strong><br>相对于HTTP协议，具有以下优点：</p>
<ol>
<li>内容加密：采用混合加密技术，中间者无法直接查看明文内容。</li>
<li>验证身份：通过证书认证客户端访问的是自己的服务器。</li>
<li>保护数据完整性：防止传输的内容被中间人冒充或者篡改。<br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/https.png" alt="markdown"></li>
</ol>
<h2 id="SSL和TLS"><a href="#SSL和TLS" class="headerlink" title="SSL和TLS"></a>SSL和TLS</h2><p>HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。TLS与SSL在传输层对网络连接进行加密，在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。</p>
<p><strong>对称加密（通信过程）：</strong></p>
<p>对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。<br>这种加密方式固然很好，但是问题就在于如何让双方知道秘钥。因为传输数据都是走的网络，如果将秘钥通过网络的方式传递的话，一旦秘钥被截获就没有加密的意义的。</p>
<p><strong>非对称加密（认证过程）：</strong></p>
<p>有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道（服务端）。<br>这种加密方式就可以完美解决对称加密存在的问题。假设现在两端需要使用对称加密，那么在这之前，可以先使用非对称加密交换秘钥。</p>
<p>简单流程如下：首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了。</p>
<h2 id="SSL-TLS-四次握手"><a href="#SSL-TLS-四次握手" class="headerlink" title="SSL/TLS 四次握手"></a>SSL/TLS 四次握手</h2><p>四次握手主要交换了3个信息：</p>
<ol>
<li>数字证书：该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是信赖的CA签发的，或者与本地的证书相比，来判断证书是否可信，防止身份被冒充。</li>
<li>三个随机数。</li>
<li>加密通信协议。</li>
</ol>
<p><strong>四次握手过程</strong></p>
<ul>
<li>客户端发送通信请求，和第一个随机数 N1。</li>
<li>服务器确定加密通信协议的版本，然后返回 CA 机构签发的数字证书和公钥以及第二个随机数 N2，确认加密方法。</li>
<li>客户端验证证书的合法性，使用证书中的公钥和 HASH 算法对消息进行加密，返回服务端第三个随机数 N3。</li>
<li>服务端使用私密对消息进行解密，验证 HASH，N1+N2+N3 生成对话密钥，进行对称通信。</li>
</ul>
<p>理论上只要服务端私钥不泄露就无法被破解。</p>
<p><strong>HTTPS优缺点:</strong></p>
<p><strong>优点：</strong></p>
<ul>
<li>内容加密：无法直接查看明文内容</li>
<li>验证身份：CA 签发证书判断是否访问自己的服务器</li>
<li>保证数据完整性：防止传输内容被窜改</li>
<li>在谷歌 搜索引擎中排名更高</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>成本高，证书费用大</li>
<li>握手耗时延长 50%，耗电增加 10%到20%</li>
<li>连接缓存不如 http 高效，会增加性能功耗</li>
<li>SSL 证书需要绑定 IP，不能在同一个 IP 上绑定多个域名</li>
</ul>
<h1 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h1><p>HTTP/2 相比于 HTTP/1，可以说是大幅度提高了网页的性能。</p>
<h2 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h2><p>HTTP/2 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP/2 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</p>
<p>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</p>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>在 HTTP/1 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p>
<p>多路复用允许同时通过单一的HTTP/2 连接发起多重的请求响应消息。有了新的分帧后。HTTP/2 不再依赖多个TCP连接去实现多流并行了，每个数据流拆分成很多互不依赖的帧，还可以分优先级。不必通过多个 TCP 连接去实现并行执行，避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p>
<h2 id="header压缩"><a href="#header压缩" class="headerlink" title="header压缩"></a>header压缩</h2><p>HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP/2 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。</p>
<h2 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h2><p>服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确地请求。</p>
<p>可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。</p>
<h1 id="http3-0"><a href="#http3-0" class="headerlink" title="http3.0"></a>http3.0</h1><p>虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，虽然这个问题并不是它本身造成的，而是底层支撑的 TCP 协议的问题。</p>
<p>因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。</p>
<p>因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。</p>
<p>那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。</p>
<p><strong>基于这个原因，Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。</strong></p>
<h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><p>UDP 这个协议虽然效率很高，但是并不是那么的可靠。QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。</p>
<h3 id="多路复用-1"><a href="#多路复用-1" class="headerlink" title="多路复用"></a>多路复用</h3><p>虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。</p>
<p>并且 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是<strong>基于 IP 和端口</strong>去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。</p>
<h3 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h3><p>通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。</p>
<h3 id="纠错机制"><a href="#纠错机制" class="headerlink" title="纠错机制"></a>纠错机制</h3><p>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。</p>
<p><strong>当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。</strong></p>
<p>当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="为什么连接的时候是三次握手，关闭的时候却是四次挥手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次挥手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次挥手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次挥手？</h2><p>ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当 Server 端收到FIN报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉 Client 端，”你发的 FIN 报文我收到了”。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四次挥手。</p>
<h2 id="为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？"><a href="#为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？" class="headerlink" title="为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？"></a>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h2><p>虽然按道理，四个报文都发送完毕，我们可以直接进入 CLOSE 状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。在 Client 发送出最后的ACK回复，但该 ACK 可能丢失。Server 如果没有收到 ACK，将不断重复发送FIN片段。所以 Client 不能立即关闭，它必须确认 Server 接收到了该 ACK。Client 会在发送出ACK之后进入到 TIME_WAIT 状态。Client会设置一个计时器，等待 2MSL 的时间。如果在该时间内再次收到 FIN，那么 Client 会重发 ACK 并再次等待 2MSL。所谓的 2MSL 是两倍的 MSL(Maximum Segment Lifetime)。MSL 指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到FIN，那么 Client 推断ACK已经被成功接收，则结束 TCP 连接。</p>
<h2 id="为什么不能用两次握手进行连接？"><a href="#为什么不能用两次握手进行连接？" class="headerlink" title="为什么不能用两次握手进行连接？"></a>为什么不能用两次握手进行连接？</h2><p>3 次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p>
<p><strong>现在把三次握手改成仅需要两次握手，死锁是可能发生的。</strong>作为例子，考虑计算机 S 和 C 之间的通信，假定 C 给 S 发送一个连接请求分组，S 收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C 在 S 的应答分组在传输中被丢失的情况下，将不知道 S 是否已准备好，不知道 S 建立什么样的序列号，C 甚至怀疑 S 是否收到自己的连接请求分组。在这种情况下，C 认为连接还未建立成功，将忽略 S 发来的任何数据分 组，只等待连接确认应答分组。而 S 在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>
<h2 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>TCP 还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若 2 小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75S 发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h2 id="HTTP-2的多路复用和HTTP1-1中的长连接复用有什么区别？"><a href="#HTTP-2的多路复用和HTTP1-1中的长连接复用有什么区别？" class="headerlink" title="HTTP/2的多路复用和HTTP1.1中的长连接复用有什么区别？"></a>HTTP/2的多路复用和HTTP1.1中的长连接复用有什么区别？</h2><p>HTTP/1.0 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；<br>HTTP/1.1 Pipeling 解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；<br>HTTP/2 多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行； </p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Interview/" rel="tag"># Interview</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/02/12/%E7%BD%91%E7%BB%9C/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" rel="prev" title="跨域问题">
                  <i class="fa fa-chevron-left"></i> 跨域问题
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/02/19/JavaScript/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/" rel="next" title="原型与原型链">
                  原型与原型链 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leslie choi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
