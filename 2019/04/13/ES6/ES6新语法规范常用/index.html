<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yoursite.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta name="description" content="关键字let和constlet关键字的使用let声明的变量只在let命令所在的代码块内有效，是块级作用域的前提，不允许重复声明，不存在变量提升，存在暂时性死区（加粗的是let和const的相同点）。PS：暂时性死区的本质是，只要进入当前作用域，所要使用的变量就已经存在但是不可获取，只有等到变量声明的那一行代码出现，才可以获取和操作该变量。 const声明一个只读的常量，一旦声明，常量的值就不能改变">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6新特性">
<meta property="og:url" content="http://yoursite.com/2019/04/13/ES6/ES6%E6%96%B0%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83%E5%B8%B8%E7%94%A8/index.html">
<meta property="og:site_name" content="404 not found">
<meta property="og:description" content="关键字let和constlet关键字的使用let声明的变量只在let命令所在的代码块内有效，是块级作用域的前提，不允许重复声明，不存在变量提升，存在暂时性死区（加粗的是let和const的相同点）。PS：暂时性死区的本质是，只要进入当前作用域，所要使用的变量就已经存在但是不可获取，只有等到变量声明的那一行代码出现，才可以获取和操作该变量。 const声明一个只读的常量，一旦声明，常量的值就不能改变">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/dizhi.png">
<meta property="article:published_time" content="2019-04-13T15:06:21.000Z">
<meta property="article:modified_time" content="2021-04-11T14:17:47.565Z">
<meta property="article:author" content="leslie choi">
<meta property="article:tag" content="Interview">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/dizhi.png">


<link rel="canonical" href="http://yoursite.com/2019/04/13/ES6/ES6%E6%96%B0%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83%E5%B8%B8%E7%94%A8/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;04&#x2F;13&#x2F;ES6&#x2F;ES6%E6%96%B0%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83%E5%B8%B8%E7%94%A8&#x2F;&quot;,&quot;path&quot;:&quot;2019&#x2F;04&#x2F;13&#x2F;ES6&#x2F;ES6新语法规范常用&#x2F;&quot;,&quot;title&quot;:&quot;ES6新特性&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>ES6新特性 | 404 not found</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">404 not found</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97let%E5%92%8Cconst"><span class="nav-number">1.</span> <span class="nav-text">关键字let和const</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#let%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">let关键字的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.</span> <span class="nav-text">const关键字的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E5%85%AD%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">ES6 声明变量的六种方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES6-%E6%8F%90%E4%BE%9B%E4%BA%86%E5%AF%B9%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">2.</span> <span class="nav-text">ES6 提供了对函数的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6%E4%B8%BA%E5%8F%82%E6%95%B0%E6%8F%90%E4%BE%9B%E4%BA%86%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">2.1.</span> <span class="nav-text">ES6为参数提供了默认值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">箭头函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">3.</span> <span class="nav-text">对象的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AE%80%E5%86%99%E3%80%82"><span class="nav-number">3.1.</span> <span class="nav-text">属性的简写。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E7%AE%80%E5%86%99%EF%BC%8C%E7%9C%81%E7%95%A5%E5%86%92%E5%8F%B7%E4%B8%8Efunction%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.2.</span> <span class="nav-text">方法的简写，省略冒号与function关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-keys-%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">Object.keys()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-values-%E6%96%B9%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">Object.values()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-entries"><span class="nav-number">3.5.</span> <span class="nav-text">Object.entries()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for%E2%80%A6of-%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.6.</span> <span class="nav-text">for…of  循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#for%E2%80%A6in-%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.6.1.</span> <span class="nav-text">for…in 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forEach%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.6.2.</span> <span class="nav-text">forEach循环</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">4.</span> <span class="nav-text">模块化的支持</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.1.</span> <span class="nav-text">五、模板字符串</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E-symbol-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">新增 symbol 基础数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.1.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E-set-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.</span> <span class="nav-text">新增 set 数据类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E-Map-%E6%95%B0%E6%8D%AE"><span class="nav-number">7.</span> <span class="nav-text">新增 Map 数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#class%E3%80%81extends%E3%80%81super"><span class="nav-number">8.</span> <span class="nav-text">class、extends、super</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">9.</span> <span class="nav-text">解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">9.1.</span> <span class="nav-text">数组的解构赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">9.2.</span> <span class="nav-text">对象的解构赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">9.3.</span> <span class="nav-text">字符串的解构赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-number">9.4.</span> <span class="nav-text">解构赋值的用途</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C%E5%B0%BE%E9%80%92%E5%BD%92"><span class="nav-number">10.</span> <span class="nav-text">尾调用和尾递归</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%BE%E8%B0%83%E7%94%A8%EF%BC%88Tail-Call%EF%BC%89"><span class="nav-number">10.1.</span> <span class="nav-text">尾调用（Tail Call）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96"><span class="nav-number">10.2.</span> <span class="nav-text">尾调用优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%BE%E9%80%92%E5%BD%92"><span class="nav-number">10.3.</span> <span class="nav-text">尾递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90%E4%B8%80%EF%BC%9A%E6%B1%82%E9%98%B6%E4%B9%98"><span class="nav-number">10.3.1.</span> <span class="nav-text">例子一：求阶乘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90%E4%BA%8C-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number">10.3.2.</span> <span class="nav-text">例子二:斐波那契数列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E-Map-%E5%92%8C-Set-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">11.</span> <span class="nav-text">新增 Map 和 Set 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Set-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">11.1.</span> <span class="nav-text">Set 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%EF%BC%88%E7%94%A8%E4%BA%8E%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="nav-number">11.1.1.</span> <span class="nav-text">Set 实例的操作方法（用于操作数据）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-%E5%AE%9E%E4%BE%8B%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%EF%BC%88%E7%94%A8%E4%BA%8E%E9%81%8D%E5%8E%86%E6%88%90%E5%91%98%EF%BC%89"><span class="nav-number">11.1.2.</span> <span class="nav-text">Set 实例的遍历方法（用于遍历成员）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">11.2.</span> <span class="nav-text">Map 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="nav-number">11.2.1.</span> <span class="nav-text">Map 实例的属性和操作方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-%E5%AE%9E%E4%BE%8B%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="nav-number">11.2.2.</span> <span class="nav-text">Map 实例的遍历方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-%E5%92%8C%E6%95%B0%E7%BB%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="nav-number">11.2.3.</span> <span class="nav-text">Map 和数组互相转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="nav-number">11.2.4.</span> <span class="nav-text">Map 和对象的互相转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#babel-%E8%BD%AC%E7%A0%81%E5%8E%9F%E7%90%86"><span class="nav-number">12.</span> <span class="nav-text">babel 转码原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Promise"><span class="nav-number">13.</span> <span class="nav-text">Promise</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Proxy"><span class="nav-number">14.</span> <span class="nav-text">Proxy</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">15.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-find-%E7%AE%80%E5%86%99"><span class="nav-number">15.1.</span> <span class="nav-text">Array.find 简写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%BF%94%E5%9B%9E"><span class="nav-number">15.2.</span> <span class="nav-text">隐式返回</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#charAt-%E7%AE%80%E5%86%99"><span class="nav-number">15.3.</span> <span class="nav-text">charAt() 简写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">15.4.</span> <span class="nav-text">有条件的函数的调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math-Floor-%E7%AE%80%E5%86%99"><span class="nav-number">15.5.</span> <span class="nav-text">Math.Floor 简写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math-pow-%E7%AE%80%E5%86%99"><span class="nav-number">15.6.</span> <span class="nav-text">Math.pow 简写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97"><span class="nav-number">15.7.</span> <span class="nav-text">字符串转换为数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#amp-amp-%E8%BF%90%E7%AE%97"><span class="nav-number">15.8.</span> <span class="nav-text">&amp;&amp; 运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#toString-%E7%AE%80%E5%86%99"><span class="nav-number">15.9.</span> <span class="nav-text">toString 简写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BD%A2%E5%BC%8F%E4%BB%A3%E6%9B%BF-switch-%E8%AF%AD%E6%B3%95"><span class="nav-number">15.10.</span> <span class="nav-text">使用对象的形式代替 switch 语法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-number">16.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">leslie choi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/13/ES6/ES6%E6%96%B0%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83%E5%B8%B8%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ES6新特性
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-13 23:06:21" itemprop="dateCreated datePublished" datetime="2019-04-13T23:06:21+08:00">2019-04-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="关键字let和const"><a href="#关键字let和const" class="headerlink" title="关键字let和const"></a>关键字<strong>let</strong>和<strong>const</strong></h1><h2 id="let关键字的使用"><a href="#let关键字的使用" class="headerlink" title="let关键字的使用"></a>let关键字的使用</h2><p>let声明的变量只在let命令所在的<strong>代码块内有效，是块级作用域的前提，不允许重复声明，不存在变量提升，存在暂时性死区</strong>（加粗的是let和const的相同点）。<br>PS：暂时性死区的本质是，只要进入当前作用域，所要使用的变量就已经存在但是不可获取，只有等到变量声明的那一行代码出现，才可以获取和操作该变量。</p>
<p>const声明一个只读的常量，一旦声明，常量的值就不能改变，所以声明的时候必须初始化，同时也不存在变量提升。<br>let的基本用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);   <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">// 报错 ReferenceError: a is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">//  1 </span></span><br><span class="line"><span class="comment">//=========&gt;分割线</span></span><br><span class="line"><span class="comment">//let只能声明一次，而var可以声明多次，所以for的循环计时器适合用let</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Identifier &#x27;a&#x27; has already been declared</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>举一个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出十个 10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出0到9</span></span><br></pre></td></tr></table></figure>

<p>var声明的变量在全局范围内只有一个变量i，循环里的十个 setTimeout 是在循环结束后才执行，用于计数的变量泄露成为全局变量，所以此时的 i 都是 10；<br>变量 j 是用 let 声明的，当前的 j 只在本轮循环中有效，每次循环的 j 其实都是一个新的变量，所以 setTimeout 定时器里面的 j 其实是不同的变量，即最后输出0123456789。（JS引擎内部会记住前一次循环的值），所以这与JS的运行机制并不冲突。</p>
<p>注意点：使用let声明变量。并不存<strong>在变量提升</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//ReferenceError: a is not defined</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;banana&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="const关键字的使用"><a href="#const关键字的使用" class="headerlink" title="const关键字的使用"></a>const关键字的使用</h2><p>const 声明一个只读变量，声明之后不允许改变。意味着，一但声明<strong>必须初始化</strong>，否则会报错。但是如果是一个对象，可以改变对象里面属性值。</p>
<p><strong>const使用的注意点：</strong><br><strong>其实 const保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动</strong>。但是简单类型和复合类型保存值的方式是不同的。对于简单类型（数值 number、字符串 string 、布尔值 boolean）,值就保存在变量指向的那个内存地址，因此 const 声明的简单类型变量等同于常量。而复杂类型（对象 object，数组 array，函数 function），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能<strong>保证指针是固定</strong>的，至于指针指向的数据结构则无法来控制了，所以使用 const 声明复杂类型对象时要慎重。</p>
<p>在 ES6 快速入门中，对于 let 和 const ，建议优先选择 const，尤其是在全局环境中，不应该设置变量，只应设置常量</p>
<ul>
<li>const 可以提醒阅读程序的人，这个变量不应该改变</li>
<li>const 比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算</li>
<li>JavaScript 的编译器会对const 进行优化，所以多使用 const 有利于提高程序的运行效率</li>
</ul>
<h2 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h2><p>ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。</p>
<h1 id="ES6-提供了对函数的扩展"><a href="#ES6-提供了对函数的扩展" class="headerlink" title="ES6 提供了对函数的扩展"></a>ES6 提供了对函数的扩展</h1><h2 id="ES6为参数提供了默认值"><a href="#ES6为参数提供了默认值" class="headerlink" title="ES6为参数提供了默认值"></a>ES6为参数<strong>提供了默认值</strong></h2><p>在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a,b=<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a+b);</span><br><span class="line">&#125;</span><br><span class="line">A(<span class="number">1</span>);    <span class="comment">//2</span></span><br><span class="line">A(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>在es6中，提供了一种简洁的函数写法，我们称作“箭头函数”。</p>
<p>写法：函数名=(形参)=&gt;{……}     当函数体中只有一个表达式时，{}和return可以省略，当函数体中形参只有一个时，()可以省略。所以当函数体内代码多于1行时，必须使用{}，并且使用return语句返回</p>
<p>在函数执行时，<strong>this 总是指向调用该函数的对象</strong>。要判断 this 的指向，其实就是判断 this 所在的函数属于谁</p>
<p><strong>特点：箭头函数使得this的指向固定化，this始终指向箭头函数定义时的离this最近的一个函数，如果没有最近的函数就指向window</strong></p>
<p>箭头函数的注意事项：</p>
<ol>
<li>函数体内的 this 对象就是定义时所在的对象，而不是使用是所在的对象</li>
<li>不可以单作构造函数，所以就不可以使用 new 命令，否则会抛出错误</li>
<li>不可以使用 arguments 对象，该对象在函数体内不存在。如果需要使用可以用 rest 参数代替</li>
<li>不可以使用 yield 命令，因此箭头函数不能作 Generator 函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略写法</span></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="function"><span class="params">f</span> =&gt;</span> &#123; hhh &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//es5写法</span></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hhh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h1><h2 id="属性的简写。"><a href="#属性的简写。" class="headerlink" title="属性的简写。"></a>属性的简写。</h2><p>ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;  <span class="comment">//等同于  var baz = &#123;foo: foo&#125;;</span></span><br></pre></td></tr></table></figure>

<h2 id="方法的简写，省略冒号与function关键字"><a href="#方法的简写，省略冒号与function关键字" class="headerlink" title="方法的简写，省略冒号与function关键字"></a>方法的简写，省略冒号与function关键字</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Object-keys-方法"><a href="#Object-keys-方法" class="headerlink" title="Object.keys()方法"></a>Object.keys()方法</h2><p>获取对象的所有属性名或方法名（不包括原形的内容,for…in循环遍历出原型对象的属性，可以使用hasOwnProperty()判断），返回一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">name</span>: <span class="string">&quot;john&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;21&quot;</span>, <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="built_in">this</span>.name)&#125;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj));    <span class="comment">// [&quot;name&quot;, &quot;age&quot;, &quot;getName&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj).length);    <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys([<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>]));    <span class="comment">//[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(<span class="string">&quot;abcdef&quot;</span>));    <span class="comment">//[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-values-方法"><a href="#Object-values-方法" class="headerlink" title="Object.values()方法"></a>Object.values()方法</h2><p>获取对象的所有属性值，返回一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">name</span>: <span class="string">&quot;john&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;21&quot;</span>, <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="built_in">this</span>.name)&#125;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj))    <span class="comment">// [&quot;john&quot;, &quot;21&quot;, ƒ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj).length)    <span class="comment">//  3</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h2><p>将对象的属性名和属性值作为一个数组的两个元素，插入到另一个空数组中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;james&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sex: <span class="string">&#x27;man&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> man = <span class="built_in">Object</span>.entries(person)</span><br><span class="line"><span class="built_in">console</span>.log(man)  <span class="comment">// [[&#x27;name&#x27;,&#x27;james&#x27;],[&#x27;age&#x27;,18],[&#x27;sex&#x27;,&#x27;man&#x27;]]</span></span><br></pre></td></tr></table></figure>

<h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of  循环"></a>for…of  循环</h2><p>是遍历所有数据结构的统一的方法。for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator 对象，以及字符串。(因为对象没有Iterator接口，所以无法被遍历)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="string">&quot;小林&quot;</span>,<span class="string">&quot;小吴&quot;</span>,<span class="string">&quot;小佳&quot;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> v <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小林 </span></span><br><span class="line"><span class="comment">//小吴 </span></span><br><span class="line"><span class="comment">//小佳</span></span><br></pre></td></tr></table></figure>

<p>PS:其他循环</p>
<h3 id="for…in-循环"><a href="#for…in-循环" class="headerlink" title="for…in 循环"></a>for…in 循环</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123; <span class="comment">// 实际代码中不要这么做，使用for...of循环更合适</span></span><br><span class="line">  <span class="built_in">console</span>.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。如果你使用字符串的 index 去参与某些运算（”2” + 1 == “21”），运算结果可能会不符合预期。</p>
</li>
<li><p>for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。(比如继承关系的时候，就有些麻烦了，遍历的时候会把继承的属性也遍历出来)</p>
</li>
<li><p>某些情况下，for…in循环会以任意顺序遍历键名。</p>
</li>
<li><p>总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组。</p>
</li>
</ul>
<p>PS:如何解决for…in循环遍历出原型对象的属性。使用hasOwnProperty()判断</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Animal()</span><br><span class="line">Animal.prototype.height = <span class="number">99</span></span><br><span class="line">dog.weight = <span class="number">18</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> dog)&#123;</span><br><span class="line">  <span class="keyword">if</span>(dog.hasOwnProperty(item))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//name</span></span><br><span class="line"><span class="comment">//age</span></span><br><span class="line"><span class="comment">//weight,而height是原型对象上的属性，所以不会输出</span></span><br></pre></td></tr></table></figure>

<h3 id="forEach循环"><a href="#forEach循环" class="headerlink" title="forEach循环"></a>forEach循环</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">myArray.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item,index,arr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item,index,arr)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种写法的问题在于，无法中途跳出forEach循环，break命令也不能用return语句从闭包函数中返回，所以没有返回值</p>
<h1 id="模块化的支持"><a href="#模块化的支持" class="headerlink" title="模块化的支持"></a>模块化的支持</h1><p>ES6标准中，JavaScript原生支持模块(module)了。这种将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用。</p>
<p>export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口。</p>
<p>import用于在一个模块中加载另一个含有export接口的模块。</p>
<p>import和export命令只能在模块的顶部，不能在代码块之中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入部分</span></span><br><span class="line"><span class="comment">//全部导入</span></span><br><span class="line"><span class="keyword">import</span> Person <span class="keyword">from</span> <span class="string">&#x27;./example&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//将整个模块所有导出内容当做单一对象，用as起别名</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> example <span class="keyword">from</span> <span class="string">&quot;./example.js&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(example.name)</span><br><span class="line"><span class="built_in">console</span>.log(example.getName())</span><br><span class="line"> </span><br><span class="line"><span class="comment">//导入部分</span></span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;./example&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//导出部分</span></span><br><span class="line"><span class="comment">// 导出默认</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 部分导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="title">extend</span> <span class="title">Component</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="五、模板字符串"><a href="#五、模板字符串" class="headerlink" title="五、模板字符串"></a>五、模板字符串</h2><p>所有的空格和缩进都会被保留在输出之中。。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果说不想要换行，就可以使用trim方法去除空格和换行</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">&#x27;#list&#x27;</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>.trim())</span><br></pre></td></tr></table></figure>

<h1 id="新增-symbol-基础数据类型"><a href="#新增-symbol-基础数据类型" class="headerlink" title="新增 symbol 基础数据类型"></a>新增 symbol 基础数据类型</h1><p>JS中的数据类型分为基本数据类型还有复杂数据类型(引用数据类型)</p>
<p>复杂数据类型：object、function、array、date、基本包装类、内置对象（存放在堆中）<br>基本数据类型：字符串、数字、布尔值、null和undefined。ES6引入了第6种——Symbol（存放栈中）</p>
<p>PS：两种类型的区别是：存储位置不同</p>
<p>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</p>
<p>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/dizhi.png" alt="markdown"></p>
<p>Symbol功能类似于一种标识唯一性的ID</p>
<p>ES5的对象属性名都是字符串，很容易造成属性名冲突。比如，使用了一个他人提供的对象，想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的，这样就从根本上防止了属性名冲突。这就是ES6引入Symbol的原因，防止某一个键被不小心改写或覆盖</p>
<p>通常情况下，我们可以通过调用Symbol()函数来创建一个Symbol实例。</p>
<p>Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()   <span class="comment">//symbol</span></span><br><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>(<span class="string">&quot;first name&quot;</span>)    <span class="comment">//Symbol函数接受一个可选参数，可以添加一段文本来描述即将创建的Symbol，这段描述不可用于属性访问，但是建议在每次创建Symbol时都添加这样一段描述，以便于阅读代码和调试Symbol程序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(person, &#123;</span><br><span class="line">    [firstName]: &#123;</span><br><span class="line">        value: <span class="string">&quot;match&quot;</span>,</span><br><span class="line">        writable: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)                                <span class="comment">// 让该属性变为只读</span></span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>使用Symbol来替代常量</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> TYPE_AUDIO = <span class="string">&#x27;AUDIO&#x27;</span></span><br><span class="line"><span class="keyword">const</span> TYPE_VIDEO = <span class="string">&#x27;VIDEO&#x27;</span></span><br><span class="line"><span class="keyword">const</span> TYPE_IMAGE = <span class="string">&#x27;IMAGE&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用Symbol，就不必一直为起变量的名字头疼了。一下这样定义就可以保证三个变量是完全独一无二的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> TYPE_AUDIO = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> TYPE_VIDEO = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> TYPE_IMAGE = <span class="built_in">Symbol</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用Symbol定义类的私有属性/方法</li>
</ol>
<p>JavaScript中，是没有如Java等面向对象语言的访问控制关键字private的，类上所有定义的属性或方法都是可公开访问的。因此这对我们进行API的设计时造成了一些困扰。<br>有了Symbol以及模块化机制，类的私有属性和方法才变成可能。<br>新建一个a.js文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> PASSWORD = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">username, password</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.username = username</span><br><span class="line">    <span class="built_in">this</span>[PASSWORD] = password</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">checkPassword</span>(<span class="params">pwd</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>[PASSWORD] === pwd</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Login</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另建b.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> login = <span class="keyword">new</span> Login(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"></span><br><span class="line">login.checkPassword(<span class="string">&#x27;123456&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line">login.PASSWORD  <span class="comment">// 无法访问到</span></span><br><span class="line">login[PASSWORD] <span class="comment">// 同上</span></span><br><span class="line">login[<span class="string">&quot;PASSWORD&quot;</span>] <span class="comment">// 同上</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于Symbol常量PASSWORD被定义在a.js所在的模块中，外面的模块获取不到这个Symbol，也不可能再创建一个一模一样的Symbol出来（因为Symbol是唯一的），<strong>因此这个PASSWORD的Symbol只能被限制在a.js内部使用</strong>，所以使用它来定义的类属性是没有办法被模块外访问到的，达到了一个私有化的效果。</p>
<ol start="3">
<li>注册和获取全局Symbol</li>
</ol>
<p>通常情况下，我们在一个浏览器窗口中（window），使用Symbol()函数来定义和Symbol实例就足够了。但是，如果你的应用涉及到多个window（最典型的就是页面中使用了 iframe ），并需要这些window中使用的某些Symbol是同一个，那就不能使用Symbol()函数了，因为用它在不同window中创建的Symbol实例总是唯一的，而我们需要的是在所有这些window环境下保持一个共享的Symbol。这种情况下，我们就需要使用另一个API来创建或获取Symbol，那就是**Symbol.for()**，它可以注册或获取一个window间全局的Symbol实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> gs1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;global_symbol_1&#x27;</span>)  <span class="comment">//注册一个全局Symbol</span></span><br><span class="line"><span class="keyword">let</span> gs2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;global_symbol_1&#x27;</span>)  <span class="comment">//获取全局Symbol</span></span><br><span class="line"></span><br><span class="line">gs1 === gs2  <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样一个Symbol不光在单个window中是唯一的，在多个相关window间也是唯一的了。</p>
<ol start="4">
<li>属性检索</li>
</ol>
<p>Symbol作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.getOwnPropertyNames()、Object.keys()、JSON.stringify()返回。于是，在ES6中添加了一个Object.getOwnpropertySymbols()方法来检索对象中的Symbol属性</p>
<p>Object.getOwnPropertySymbols()方法的返回值是一个包含所有Symbol自有属性的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">&quot;uid&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">    [uid]: <span class="string">&quot;12345&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> symbols = <span class="built_in">Object</span>.getOwnPropertySymbols(object)</span><br><span class="line"><span class="built_in">console</span>.log(symbols.length) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(symbols[<span class="number">0</span>]) <span class="comment">// &quot;Symbol(uid)&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(object[symbols[<span class="number">0</span>]]) <span class="comment">// &quot;12345&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="新增-set-数据类型"><a href="#新增-set-数据类型" class="headerlink" title="新增 set 数据类型"></a>新增 set 数据类型</h1><p>ES6中新增了Set数据结构，类似于数组，但是 它的成员都是唯一的 ，其构造函数可以接受一个数组作为参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(array);</span><br><span class="line"><span class="built_in">console</span>.log(set); <span class="comment">// 此时打印的是set 结构 Set(5) &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(set)); <span class="comment">//将Set结构强制转换为数组</span></span><br></pre></td></tr></table></figure>

<h1 id="新增-Map-数据"><a href="#新增-Map-数据" class="headerlink" title="新增 Map 数据"></a>新增 Map 数据</h1><p>其实数组也是集合, 只不过数组的索引是数值类型.当想用非数值类型作为索引时, 数组就无法满足需要了.</p>
<p>而 Map 集合可以保存多个键-值对(key-value), Set 集合可以保存多个元素.</p>
<p>对Map 和 Set 一般不会逐一遍历其中的元素. Map 一般用来存储需要频繁取用的数据, Set 一般用来判断某个值是否存在其中.<br>键和值都可以是任意类型。键的比较使用的是Object.is()，因此你可以将5与“5”同时作为键，因为他们类型不同。对象也可以作为 key . 这比用对象来模拟的方式就灵活了很多</p>
<ul>
<li>set(key, value): 向其中加入一个键值对</li>
<li>get(key): 若不存在 key 则返回 undefined</li>
<li>has(key):返回布尔值</li>
<li>delete(key): 删除成功则返回 true, 若key不存在或者删除失败会返回 false</li>
<li>clear(): 将全部元素清除</li>
</ul>
<p>Set是无重复值的有序列表。Set会自动移除重复的值，因此你可以使用它来过滤数组中重复的值并返回结果。<br>Map是有序的键值对，其中的键允许是任何类型。<br>Set和Map是es6新增的两个数据集合。</p>
<p>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>
<h1 id="class、extends、super"><a href="#class、extends、super" class="headerlink" title="class、extends、super"></a>class、extends、super</h1><p>这三个特性设计到ES5几个点，就是原型，继承还有多态，确实是令人挺烦的。。但那是ES6之前的事了蛤蛤。</p>
<p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;  <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">prop</span>() &#123;  <span class="comment">// 取值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">prop</span>(<span class="params">value</span>) &#123; <span class="comment">// 存值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line">inst.prop = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"><span class="built_in">console</span>.log(inst.prop);</span><br><span class="line"><span class="comment">// &#x27;getter&#x27;</span></span><br></pre></td></tr></table></figure>

<p>extends用法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y, color</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="built_in">super</span>(x, y);</span><br><span class="line">    <span class="built_in">this</span>.color = color; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在子类的构造函数中，<strong>只有调用super之后</strong>，才可以使用this关键字，否则会报错。</p>
<p>其实 super(…) 做的事情就是绑定 this。因为在原型继承中，如果一个类要继承自另一个类，那就得先实例化一次它的父类作为作为子类的原型。如果不做这件事，子类的原型就不能确定，当然也就无法创建 this。所以如果在 constructor 中没有 super(…) 就企图获取 this 就会报错。</p>
<p>这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。父类的静态方法，也会被子类继承。</p>
<p>注意，super虽然代表了父类Point的构造函数，但是返回的是子类ColorPoint的实例，即super内部的this指的是ColorPoint，因此super()在这里相当于<strong>Point.prototype.constructor.call(this)。</strong></p>
<p>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">m</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>(); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：static 关键字解释：类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用， 这就称为“ 静态方法”。</p>
<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">122</span>,<span class="number">321</span>,<span class="number">344</span>]</span><br><span class="line"><span class="keyword">const</span> [a,b,c] = arr</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c)    <span class="comment">//122,321,344</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> [head,...tail] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"> head  <span class="comment">//1</span></span><br><span class="line"> tail  <span class="comment">//2,3,4</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> [x,y] = [<span class="string">&quot;a&quot;</span>]</span><br><span class="line"> y   <span class="comment">// undefined，如果结构不成功，那么变量的值就是undefined</span></span><br></pre></td></tr></table></figure>
<p>如果右边不是可以遍历的结构，那么将会报错。<strong>事实上只要某种数据结构具有 iterator 接口，都可以使用数组形式的解构赋值</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>并且允许指定默认值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = []</span><br><span class="line">foo <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>]</span><br><span class="line">x <span class="comment">//null，如果一个数组成员是null，那么默认值就不会生效</span></span><br></pre></td></tr></table></figure>

<h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&quot;james&quot;</span>,<span class="attr">age</span>: <span class="number">66</span>&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">name</span>:myName,age&#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(myName,age)   <span class="comment">//james 66</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值是由它的位置决定的；</span></span><br><span class="line"> <span class="comment">//而对象的属性没有次序，变量必须与属性同名才能取到正确的值</span></span><br></pre></td></tr></table></figure>

<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。如果解构失败，变量的值等于undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p>字符串的解构赋值，会使得字符串被转换成一个类似数组的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a,b,c,d,e] = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">a <span class="comment">//  &quot;h&quot;</span></span><br><span class="line">b <span class="comment">//  &quot;e&quot;</span></span><br><span class="line">c <span class="comment">//  &quot;l&quot;</span></span><br><span class="line">d <span class="comment">//  &quot;d&quot;</span></span><br><span class="line">e <span class="comment">//  &quot;o&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="解构赋值的用途"><a href="#解构赋值的用途" class="headerlink" title="解构赋值的用途"></a>解构赋值的用途</h2><ol>
<li>交换变量的值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span></span><br><span class="line">[x, y] = [y, x]    <span class="comment">//交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从函数返回多个值</li>
</ol>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>提取JSON 数据</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, &quot;OK&quot;, [867, 5309]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>遍历 Map 结构</li>
</ol>
<p>任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; is &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="尾调用和尾递归"><a href="#尾调用和尾递归" class="headerlink" title="尾调用和尾递归"></a>尾调用和尾递归</h1><h2 id="尾调用（Tail-Call）"><a href="#尾调用（Tail-Call）" class="headerlink" title="尾调用（Tail Call）"></a>尾调用（Tail Call）</h2><p>是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后一步调用并不是指在函数的尾部，只要是最后异步操作即可：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。</span></span><br><span class="line"><span class="comment">//值得注意的是，以下三种情况均不是尾调用：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = g(x);</span><br><span class="line">  <span class="keyword">return</span> y;   <span class="comment">//   尾调用之后还有操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于调用g(x)后return undefined。</p>
<h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。<br>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面是尾调用例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> b(m + n)</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br><span class="line"><span class="comment">// 上面例子实际上等同于:</span></span><br><span class="line">b(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果函数b不是尾调用，函数f就需要保存内部变量m和n的值、b的调用位置等信息。但由于调用b之后，函数a就结束了，所以执行到最后一步，完全可以删除a(x)的调用帧，只保留b(3)的调用帧。</p>
<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数(即b函数)的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<p><strong>注意，只有不再用到外层函数(函数f)的内部变量，内层函数(函数g)的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b + one;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>显而易见，上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。</p>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<h3 id="例子一：求阶乘"><a href="#例子一：求阶乘" class="headerlink" title="例子一：求阶乘"></a>例子一：求阶乘</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>让我们来理一下上面函数的顺序：<br>进入之后 由于 n !== 1 进入 return n * factorial(n - 1) 即 5 * factorial(4)<br>第二次进入 n === 4 , return 4 * factorial(3)<br>知道 n === 1, return 1出来相当于变成了 5 * 4 * 3 * 2 * 1 = 120<br>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n)(可以理解为调用帧个数) 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br><span class="line"><span class="comment">//也可以直接给total一个默认值等于1，那么调用的时候只给n赋值就可以</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里传了两个参数，第二个参数为total,我们来看一下函数的运作：<br>第一次进入：直接调用 factorial(5-1, 5 * 1) 即 factorial(4, 5)<br>第二次进入：调用 factorial(4-1, 4 * 5) 即 factorial(3, 20)<br>第三次进入：调用 factorial(3-1, 3 * 20) 即 factorial(2, 60)<br>第四次进入：调用 factorial(2-1, 2 * 60) 即 factorial(1, 120)<br>第五次进入：因为n === 1, 所以 return 120</p>
<h3 id="例子二-斐波那契数列"><a href="#例子二-斐波那契数列" class="headerlink" title="例子二:斐波那契数列"></a>例子二:斐波那契数列</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">//不使用尾递归求斐波那契数列</span></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>)</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//上面的例子由于从上到下递归，会有非常多的重复的运算，导致消耗大量的性能</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//提高性能版本</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//数列存放在数组中，第n项对应数组的第n-1个数</span></span><br><span class="line">			<span class="keyword">let</span> result = []</span><br><span class="line">			result[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">			result[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">3</span>;i &lt; n;i++)&#123;</span><br><span class="line">				result[i] = result[i-<span class="number">1</span>] + result[i-<span class="number">2</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		  <span class="keyword">return</span> result[n-<span class="number">1</span>]<span class="comment">//数列的第三项就是数组的第二项</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用ES6的尾递归提高性能</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n, num1 = <span class="number">1</span>,num2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">	 	<span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;<span class="keyword">return</span> num2&#125;</span><br><span class="line">	 	<span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>,num2,num1 + num2)</span><br><span class="line">	&#125;</span><br><span class="line">	Fibonacci(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>值得注意的是：<br><strong>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</strong></p>
<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>
<ul>
<li>func.arguments：返回调用时函数的参数。</li>
<li>func.caller：返回调用当前函数的那个函数。</li>
<li>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</li>
</ul>
<p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<h1 id="新增-Map-和-Set-数据结构"><a href="#新增-Map-和-Set-数据结构" class="headerlink" title="新增 Map 和 Set 数据结构"></a>新增 Map 和 Set 数据结构</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(map))   <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(set))    <span class="comment">//object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Set-数据结构"><a href="#Set-数据结构" class="headerlink" title="Set 数据结构"></a>Set 数据结构</h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;   <span class="comment">// 2 3 5 4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码通过add方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p>
<p>Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>
<p>利用 Set 数据结构的特性，可以实现数组的去重。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)))</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(arr)])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Set实例的属性和方法</strong></p>
<ul>
<li>Set.prototype.constructor：构造函数，默认就是Set函数。</li>
<li>Set.prototype.size：返回Set实例的成员总数。</li>
</ul>
<h3 id="Set-实例的操作方法（用于操作数据）"><a href="#Set-实例的操作方法（用于操作数据）" class="headerlink" title="Set 实例的操作方法（用于操作数据）"></a>Set 实例的操作方法（用于操作数据）</h3><ul>
<li>add(value)：添加某个值，返回 Set 结构本身。</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line"></span><br><span class="line">s.size <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.has(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">3</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s.delete(<span class="number">2</span>);</span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Set-实例的遍历方法（用于遍历成员）"><a href="#Set-实例的遍历方法（用于遍历成员）" class="headerlink" title="Set 实例的遍历方法（用于遍历成员）"></a>Set 实例的遍历方法（用于遍历成员）</h3><ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red green blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red green blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。这意味着，可以省略values方法，直接用for…of循环遍历 Set。</p>
<p>entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>
<p>foreach方法则和数组类似。</p>
<h2 id="Map-数据结构"><a href="#Map-数据结构" class="headerlink" title="Map 数据结构"></a>Map 数据结构</h2><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">p</span>: <span class="string">&#x27;Hello World&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">&#x27;content&#x27;</span>)</span><br><span class="line">m.get(o) <span class="comment">// &quot;content&quot;</span></span><br><span class="line"></span><br><span class="line">m.has(o) <span class="comment">// true</span></span><br><span class="line">m.delete(o) <span class="comment">// true</span></span><br><span class="line">m.has(o) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码使用 Map 结构的set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。</p>
<p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">map.has(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// &quot;Author&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心！！</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set([<span class="string">&#x27;a&#x27;</span>], <span class="number">555</span>);</span><br><span class="line">map.get([<span class="string">&#x27;a&#x27;</span>]) <span class="comment">// undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。</p>
<p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.set(k1, <span class="number">111</span>)</span><br><span class="line">.set(k2, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">map.get(k1) <span class="comment">// 111</span></span><br><span class="line">map.get(k2) <span class="comment">// 222</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量k1和k2的值是一样的，但是它们在 Map 结构中被视为两个键。</p>
<p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），<strong>则只要两个值严格相等，Map 将其视为一个键</strong>，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(-<span class="number">0</span>, <span class="number">123</span>);</span><br><span class="line">map.get(+<span class="number">0</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="literal">true</span>, <span class="number">1</span>);</span><br><span class="line">map.set(<span class="string">&#x27;true&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">map.get(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="literal">undefined</span>, <span class="number">3</span>);</span><br><span class="line">map.set(<span class="literal">null</span>, <span class="number">4</span>);</span><br><span class="line">map.get(<span class="literal">undefined</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="literal">NaN</span>, <span class="number">123</span>);</span><br><span class="line">map.get(<span class="literal">NaN</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Map-实例的属性和操作方法"><a href="#Map-实例的属性和操作方法" class="headerlink" title="Map 实例的属性和操作方法"></a>Map 实例的属性和操作方法</h3><ol>
<li>size 属性</li>
</ol>
<p>size属性返回 Map 结构的成员总数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.set(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>set(key, value)</li>
</ol>
<p>set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">m.set(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">m.set(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>)    <span class="comment">// 键是 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set方法返回的是当前的Map对象，因此可以采用链式写法。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  .set(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  .set(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>get(key)</li>
</ol>
<p>get方法读取key对应的键值，如果找不到key，返回undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);&#125;;</span><br><span class="line">m.set(hello, <span class="string">&#x27;Hello ES6!&#x27;</span>) <span class="comment">// 键是函数</span></span><br><span class="line"></span><br><span class="line">m.get(hello)  <span class="comment">// Hello ES6!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>has(key)</li>
</ol>
<p>has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">m.set(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>);</span><br><span class="line">m.set(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>);</span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line"></span><br><span class="line">m.has(<span class="string">&#x27;edition&#x27;</span>)     <span class="comment">// true</span></span><br><span class="line">m.has(<span class="string">&#x27;years&#x27;</span>)       <span class="comment">// false</span></span><br><span class="line">m.has(<span class="number">262</span>)           <span class="comment">// true</span></span><br><span class="line">m.has(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>delete(key)</li>
</ol>
<p>delete方法删除某个键，返回true。如果删除失败，返回false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line">m.has(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">m.delete(<span class="literal">undefined</span>)</span><br><span class="line">m.has(<span class="literal">undefined</span>)       <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>clear()</li>
</ol>
<p>clear方法清除所有成员，没有返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.set(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line">map.clear()</span><br><span class="line">map.size <span class="comment">// 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Map-实例的遍历方法"><a href="#Map-实例的遍历方法" class="headerlink" title="Map 实例的遍历方法"></a>Map 实例的遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p>
<ul>
<li>keys()：返回键名的遍历器。</li>
<li>values()：返回键值的遍历器。</li>
<li>entries()：返回所有成员的遍历器。</li>
<li>forEach()：遍历 Map 的所有成员。</li>
</ul>
<p>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;T&#x27;</span>,  <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//    [&#x27;F&#x27;, &#x27;no&#x27;],</span></span><br><span class="line"><span class="comment">//    [&#x27;T&#x27;,  &#x27;yes&#x27;]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// &quot;F&quot;</span></span><br><span class="line">  <span class="comment">// &quot;T&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// &quot;no&quot;</span></span><br><span class="line">  <span class="comment">// &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line">  <span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 或者</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line">  <span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等同于使用map.entries()</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line">  <span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Map-和数组互相转换"><a href="#Map-和数组互相转换" class="headerlink" title="Map 和数组互相转换"></a>Map 和数组互相转换</h3><p>Map转换为数组，使用扩展运算符(…)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">[...map.keys()]</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">[...map.values()]</span><br><span class="line"><span class="comment">// [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span></span><br><span class="line"></span><br><span class="line">[...map.entries()]</span><br><span class="line"><span class="comment">// [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span></span><br><span class="line"></span><br><span class="line">[...map]</span><br><span class="line"><span class="comment">// [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span></span><br></pre></td></tr></table></figure>

<p>数组转换为Map 构造函数，将数组传入 Map 构造函数，就可以转为 Map。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="literal">true</span>, <span class="number">7</span>],</span><br><span class="line">  [&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// Map &#123;</span></span><br><span class="line"><span class="comment">//   true =&gt; 7,</span></span><br><span class="line"><span class="comment">//   Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Map-和对象的互相转换"><a href="#Map-和对象的互相转换" class="headerlink" title="Map 和对象的互相转换"></a>Map 和对象的互相转换</h3><p>Map 转为对象</p>
<p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">&#x27;yes&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">  .set(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToObj(myMap)</span><br><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>
<p>对象转为 Map</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToStrMap</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToStrMap(&#123;<span class="attr">yes</span>: <span class="literal">true</span>, <span class="attr">no</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="babel-转码原理"><a href="#babel-转码原理" class="headerlink" title="babel 转码原理"></a>babel 转码原理</h1><p>babel的转译过程分为三个阶段：parsing(解析)、transforming(转换)、generating(产生)</p>
<p>具体过程：</p>
<ol>
<li>编写ES6代码</li>
<li>babylon进行解析，解析得到AST</li>
<li>plugin用babel-traverse对AST树进行遍历转译，得到新的AST树</li>
<li>用babel-generator通过AST树生成ES5代码</li>
</ol>
<p>需注意的一点就是，babel默认只是转译新标准引入的语法，比如ES6的箭头函数，不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。</p>
<p>举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p>Proxy 是 ES6 中新增的功能，可以⽤来⾃定义对象中的操作。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler); <span class="comment">// `target` 代表需要添加代理的对象 // `handler` ⽤来⾃定义对象中的操作 可以很⽅便的使⽤ Proxy 来实现⼀个数据绑定和监听 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> onWatch = <span class="function">(<span class="params">obj, setBind, getLogger</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">let</span> handler = &#123;     </span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, property, receiver</span>)</span> &#123;       </span><br><span class="line">      getLogger(target, property)       </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver)  </span><br><span class="line">      &#125;,     </span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, property, value, receiver</span>)</span> &#123;       </span><br><span class="line">      setBind(value);       </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, property, value)</span><br><span class="line">      &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125; </span><br><span class="line"><span class="keyword">let</span> value </span><br><span class="line"><span class="keyword">let</span> p = onWatch(obj, <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;   </span><br><span class="line">  value = v &#125;, </span><br><span class="line">  (target, property) =&gt; &#123;   </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Get &#x27;<span class="subst">$&#123;property&#125;</span>&#x27; = <span class="subst">$&#123;target[property]&#125;</span>`</span>); </span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line">p.a = <span class="number">2</span> <span class="comment">// bind `value` to `2` p.a // -&gt; Get &#x27;a&#x27; = 2</span></span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Array-find-简写"><a href="#Array-find-简写" class="headerlink" title="Array.find 简写"></a>Array.find 简写</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pets = [&#123;</span><br><span class="line">    type: <span class="string">&#x27;Dog&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;wangcai&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">&#x27;Cat&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">&#x27;Dog&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Tommy&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">pet = pets.find(<span class="function"><span class="params">item</span> =&gt;</span> item.type === <span class="string">&#x27;Dog&#x27;</span> &amp;&amp; item.name === <span class="string">&#x27;Tommy&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pet) <span class="comment">// &#123; type: &#x27;Dog&#x27;, name: &#x27;Tommy&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="隐式返回"><a href="#隐式返回" class="headerlink" title="隐式返回"></a>隐式返回</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> implicitReturn = <span class="function">(<span class="params">value</span>) =&gt;</span> (value + value) <span class="comment">// 注意这里是圆括号 不是花括号</span></span><br><span class="line"><span class="built_in">console</span>.log(implicitReturn(<span class="string">&#x27;giao&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="charAt-简写"><a href="#charAt-简写" class="headerlink" title="charAt() 简写"></a>charAt() 简写</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;SampleString&#x27;</span>.charAt(<span class="number">0</span>) <span class="comment">// S</span></span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="string">&#x27;SampleString&#x27;</span>[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h2 id="有条件的函数的调用"><a href="#有条件的函数的调用" class="headerlink" title="有条件的函数的调用"></a>有条件的函数的调用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am Function 1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am Function 2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 复杂写法</span></span><br><span class="line"><span class="keyword">let</span> checkValue = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> (checkValue === <span class="number">3</span>) &#123;</span><br><span class="line">  fn1()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fn2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简短写法</span></span><br><span class="line">(checkValue === <span class="number">3</span> ? fn1 : fn2)()</span><br></pre></td></tr></table></figure>

<h2 id="Math-Floor-简写"><a href="#Math-Floor-简写" class="headerlink" title="Math.Floor 简写"></a>Math.Floor 简写</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> val = <span class="string">&#x27;123.95&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(val)) <span class="comment">// 常规写法</span></span><br><span class="line"><span class="built_in">console</span>.log(~~val) <span class="comment">// 简写</span></span><br></pre></td></tr></table></figure>

<h2 id="Math-pow-简写"><a href="#Math-pow-简写" class="headerlink" title="Math.pow 简写"></a>Math.pow 简写</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 简写 8  </span></span><br></pre></td></tr></table></figure>

<h2 id="字符串转换为数字"><a href="#字符串转换为数字" class="headerlink" title="字符串转换为数字"></a>字符串转换为数字</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&#x27;100&#x27;</span>)</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">&quot;100&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">&quot;100.2&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="amp-amp-运算"><a href="#amp-amp-运算" class="headerlink" title="&amp;&amp; 运算"></a>&amp;&amp; 运算</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (value === <span class="number">1</span>)  <span class="built_in">console</span>.log(<span class="string">&#x27;Value is one&#x27;</span>)</span><br><span class="line"><span class="comment">// &amp;&amp; 运算</span></span><br><span class="line">value &amp;&amp; <span class="built_in">console</span>.log(<span class="string">&#x27;Value is one&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  只要“&amp;&amp;”前面是false，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”前面的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  只要“&amp;&amp;”前面是true，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”后面的值</span></span><br></pre></td></tr></table></figure>

<h2 id="toString-简写"><a href="#toString-简写" class="headerlink" title="toString 简写"></a>toString 简写</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someNumber = <span class="number">123</span></span><br><span class="line"><span class="built_in">console</span>.log(someNumber.toString()) <span class="comment">// &quot;123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;someNumber&#125;</span>`</span>) <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用对象的形式代替-switch-语法"><a href="#使用对象的形式代替-switch-语法" class="headerlink" title="使用对象的形式代替 switch 语法"></a>使用对象的形式代替 switch 语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch 写法</span></span><br><span class="line"><span class="keyword">let</span> animal = <span class="string">&#x27;dog&#x27;</span></span><br><span class="line"><span class="keyword">let</span> name</span><br><span class="line"><span class="keyword">switch</span>(animal) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;dog&#x27;</span>:</span><br><span class="line">    name = <span class="string">&#x27;wangcai&#x27;</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;cat&#x27;</span>:</span><br><span class="line">    name = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;pig&#x27;</span>:</span><br><span class="line">    name = <span class="string">&#x27;paige&#x27;</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    name = <span class="string">&#x27;jerry&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  对象的形式，实际上是使用策略模式重构代码</span></span><br><span class="line"><span class="comment">// case1</span></span><br><span class="line"><span class="keyword">const</span> fn1 = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> animalsList = &#123;</span><br><span class="line">    <span class="string">&#x27;dog&#x27;</span>: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;wangcai&#x27;</span> &#125;,</span><br><span class="line">    <span class="string">&#x27;cat&#x27;</span>: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;tom&#x27;</span> &#125;,</span><br><span class="line">    <span class="string">&#x27;pig&#x27;</span>: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;peppa pig&#x27;</span> &#125;,</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;jerry&#x27;</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> animalsList[name] !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> animalsList[name]()</span><br><span class="line">&#125;</span><br><span class="line">fn1(<span class="string">&#x27;dog&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// case2</span></span><br><span class="line"><span class="keyword">const</span> animalsList2 = &#123;</span><br><span class="line">  <span class="string">&#x27;dog&#x27;</span>: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;wangcai&#x27;</span> &#125;,</span><br><span class="line">  <span class="string">&#x27;cat&#x27;</span>: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;tom&#x27;</span> &#125;,</span><br><span class="line">  <span class="string">&#x27;pig&#x27;</span>: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;peppa&#x27;</span> &#125;,</span><br><span class="line">  <span class="string">&#x27;default&#x27;</span>: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;jerry&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn2 = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> animalsList2[name]</span><br><span class="line">&#125;</span><br><span class="line">fn2(<span class="string">&#x27;cat&#x27;</span>)()</span><br></pre></td></tr></table></figure>

<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>(22+ 高频实用的 JavaScript 片段 （2020年）)[<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/kmelc879Eadfr9YFntkAUg]">https://mp.weixin.qq.com/s/kmelc879Eadfr9YFntkAUg]</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Interview/" rel="tag"># Interview</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/03/21/JavaScript/this%E6%8C%87%E5%90%91/" rel="prev" title="javaScript中的this指向">
                  <i class="fa fa-chevron-left"></i> javaScript中的this指向
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/04/20/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/%E6%89%8B%E6%92%95Ajax/" rel="next" title="手撕Ajax">
                  手撕Ajax <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leslie choi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
