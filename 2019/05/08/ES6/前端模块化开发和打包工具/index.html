<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yoursite.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta name="description" content="前端模块化开发前言：历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。而现在的前端开发，不仅仅是完成浏览">
<meta property="og:type" content="article">
<meta property="og:title" content="前端模块化开发和打包工具">
<meta property="og:url" content="http://yoursite.com/2019/05/08/ES6/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%92%8C%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/index.html">
<meta property="og:site_name" content="404 not found">
<meta property="og:description" content="前端模块化开发前言：历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。而现在的前端开发，不仅仅是完成浏览">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/zongjie.png">
<meta property="article:published_time" content="2019-05-08T07:30:25.000Z">
<meta property="article:modified_time" content="2021-04-22T16:10:24.956Z">
<meta property="article:author" content="leslie choi">
<meta property="article:tag" content="basic">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/zongjie.png">


<link rel="canonical" href="http://yoursite.com/2019/05/08/ES6/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%92%8C%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;05&#x2F;08&#x2F;ES6&#x2F;%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%92%8C%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7&#x2F;&quot;,&quot;path&quot;:&quot;2019&#x2F;05&#x2F;08&#x2F;ES6&#x2F;前端模块化开发和打包工具&#x2F;&quot;,&quot;title&quot;:&quot;前端模块化开发和打包工具&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>前端模块化开发和打包工具 | 404 not found</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">404 not found</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91"><span class="nav-number">1.</span> <span class="nav-text">前端模块化开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-number">1.1.</span> <span class="nav-text">什么是模块化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%89%8D%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.2.</span> <span class="nav-text">目前前端模块化的解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CommonJS"><span class="nav-number">1.2.1.</span> <span class="nav-text">CommonJS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AMD%E8%A7%84%E8%8C%83%EF%BC%88Asyncchronous-Module-Definition-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9D%97%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="nav-number">1.2.2.</span> <span class="nav-text">AMD规范（Asyncchronous Module Definition 异步模块定义）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMD%E8%A7%84%E8%8C%83-Common-Module-Definition-%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9D%97%E5%AE%9A%E4%B9%89"><span class="nav-number">1.2.3.</span> <span class="nav-text">CMD规范(Common Module Definition 通用模块定义)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6-Module-%E9%9D%A2%E5%90%91%E6%9C%AA%E6%9D%A5%E7%9A%84%E6%A0%87%E5%87%86"><span class="nav-number">1.2.4.</span> <span class="nav-text">ES6 Module(面向未来的标准)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E-CommonJS-%E5%92%8C-ES6-%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB%E6%98%AF%EF%BC%9A"><span class="nav-number">1.2.5.</span> <span class="nav-text">对于 CommonJS 和 ES6 中的模块化的两者区别是：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7"><span class="nav-number">2.</span> <span class="nav-text">模块化打包工具</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#webpack%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">webpack打包优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#devServer%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87"><span class="nav-number">3.1.</span> <span class="nav-text">devServer提高开发效率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6"><span class="nav-number">3.2.</span> <span class="nav-text">优化构建速度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%A9%E5%B0%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%90%9C%E7%B4%A2%E8%8C%83%E5%9B%B4"><span class="nav-number">3.2.1.</span> <span class="nav-text">缩小文件的搜索范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8DllPlugin%E5%87%8F%E5%B0%91%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E6%AC%A1%E6%95%B0"><span class="nav-number">3.2.2.</span> <span class="nav-text">使用DllPlugin减少基础模块编译次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8HappyPack%E5%BC%80%E5%90%AF%E5%A4%9A%E8%BF%9B%E7%A8%8BLoader%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.2.3.</span> <span class="nav-text">使用HappyPack开启多进程Loader转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8ParallelUglifyPlugin%E5%BC%80%E5%90%AF%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%8E%8B%E7%BC%A9JS%E6%96%87%E4%BB%B6"><span class="nav-number">3.2.4.</span> <span class="nav-text">使用ParallelUglifyPlugin开启多进程压缩JS文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E8%BE%93%E5%87%BA%E8%B4%A8%E9%87%8F-%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E4%BD%93%E7%A7%AF"><span class="nav-number">3.3.</span> <span class="nav-text">优化输出质量-压缩文件体积</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%86%E7%8E%AF%E5%A2%83%E2%80%93%E5%87%8F%E5%B0%8F%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%BB%A3%E7%A0%81%E4%BD%93%E7%A7%AF"><span class="nav-number">3.3.1.</span> <span class="nav-text">区分环境–减小生产环境代码体积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E4%BB%A3%E7%A0%81-JS%E3%80%81ES%E3%80%81CSS"><span class="nav-number">3.3.2.</span> <span class="nav-text">压缩代码-JS、ES、CSS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Tree-Shaking%E5%89%94%E9%99%A4JS%E6%AD%BB%E4%BB%A3%E7%A0%81"><span class="nav-number">3.3.3.</span> <span class="nav-text">使用Tree Shaking剔除JS死代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E8%BE%93%E5%87%BA%E8%B4%A8%E9%87%8F%E2%80%93%E5%8A%A0%E9%80%9F%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82"><span class="nav-number">3.4.</span> <span class="nav-text">优化输出质量–加速网络请求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8CDN%E5%8A%A0%E9%80%9F%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD"><span class="nav-number">3.4.1.</span> <span class="nav-text">使用CDN加速静态资源加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E6%8F%90%E5%8F%96%E9%A1%B5%E9%9D%A2%E9%97%B4%E5%85%AC%E5%85%B1%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BB%A5%E5%88%A9%E7%94%A8%E7%BC%93%E5%AD%98"><span class="nav-number">3.4.2.</span> <span class="nav-text">多页面应用提取页面间公共代码，以利用缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E4%BB%A3%E7%A0%81%E4%BB%A5%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD"><span class="nav-number">3.4.3.</span> <span class="nav-text">分割代码以按需加载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E7%9A%84plugin"><span class="nav-number">3.5.</span> <span class="nav-text">优化的plugin</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0%EF%BC%9A"><span class="nav-number">4.</span> <span class="nav-text">参考文章：</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">leslie choi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/08/ES6/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%92%8C%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          前端模块化开发和打包工具
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-08 15:30:25" itemprop="dateCreated datePublished" datetime="2019-05-08T15:30:25+08:00">2019-05-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-23 00:10:24" itemprop="dateModified" datetime="2021-04-23T00:10:24+08:00">2021-04-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="前端模块化开发"><a href="#前端模块化开发" class="headerlink" title="前端模块化开发"></a>前端模块化开发</h1><p>前言：历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。而现在的前端开发，不仅仅是完成浏览的基本需求，并且通常是一个单页面应用，每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的 JavaScript 代码. 如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统。</p>
<h2 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h2><p>所谓的模块化开发就是封装细节，提供使用接口，彼此之间互不影响，每个模块都是实现某一特定的功能。模块化开发的基础就是函数，这种模块化类似于 java中的包 直接引入，即插即用，不会产生变量冲突，就是如此便捷。<br>存在问题：</p>
<ul>
<li>全局变量和函数变量冲突：使用自执行函数</li>
<li>依赖顺序问题以及重复引入的问题：将所有的文件按依赖顺序合并或者检查head标签，确保依赖的顺序</li>
<li>按需加载的问题，只需要使用某个库中的一个功能，却不得不将整个库引入：手动分离所需的代码</li>
</ul>
<h2 id="目前前端模块化的解决方案"><a href="#目前前端模块化的解决方案" class="headerlink" title="目前前端模块化的解决方案"></a>目前前端模块化的解决方案</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p><strong>服务器端</strong>的 Node.js 遵循 CommonJS规范，该规范的核心思想是允许模块通过 require 方法来<strong>同步加载</strong>所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;module&quot;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;../file.js&quot;</span>);</span><br><span class="line"><span class="built_in">exports</span>.doStuff = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = someValue;</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>服务器端模块便于重用</li>
<li>NPM 中已经有将近20万个可以使用模块包</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
</ul>
<p>缺点：</p>
<ul>
<li>只能在服务端(Node.js)使用, 不能在浏览器直接使用</li>
<li>模块是同步加载的, 如果加载过慢会阻塞进程</li>
</ul>
<h3 id="AMD规范（Asyncchronous-Module-Definition-异步模块定义）"><a href="#AMD规范（Asyncchronous-Module-Definition-异步模块定义）" class="headerlink" title="AMD规范（Asyncchronous Module Definition 异步模块定义）"></a>AMD规范（Asyncchronous Module Definition 异步模块定义）</h3><p>由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，<br>所以CommonJS规范比较适用服务器。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。</p>
<p>define(id?, dependencies?, factory)，它要在声明模块的时候指定所有的依赖 dependencies，并且还要当做形参传到 factory 中，对于依赖的模块提前执行，依赖前置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个名为 myModule 的模块，它依赖 jQuery 模块</span></span><br><span class="line">define(<span class="string">&#x27;myModule&#x27;</span>, [<span class="string">&#x27;jquery&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// $ 是 jquery 模块的输出</span></span><br><span class="line">    $(<span class="string">&#x27;body&#x27;</span>).text(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">define([<span class="string">&#x27;myModule&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myModule</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>requirejs遵循这个规范</strong></p>
<p>优点：</p>
<ul>
<li>可以在浏览器环境中异步加载模块</li>
<li>能够并行加载多个模块</li>
<li>体验好，没有延迟，依赖的模块被提前执行了</li>
</ul>
<p>缺点：</p>
<ul>
<li>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块</li>
<li>预下载, 预解释, 带来额外性能消耗</li>
</ul>
<h3 id="CMD规范-Common-Module-Definition-通用模块定义"><a href="#CMD规范-Common-Module-Definition-通用模块定义" class="headerlink" title="CMD规范(Common Module Definition 通用模块定义)"></a>CMD规范(Common Module Definition 通用模块定义)</h3><p>CMD是SeaJS 在推广过程中对模块定义的规范化产出。</p>
<p>CMD和AMD的比较：</p>
<ul>
<li>AMD推崇(但不强制)依赖前置，在定义模块的时候就要用require声明其依赖的</li>
<li><strong>CMD推崇(但不强制)就近依赖，只有在用到某个模块的时候再去require</strong></li>
<li>CMD不需要AMD那样的回调写法, 可以像CommonJS一样的同步写法(但加载其实还是异步的)</li>
<li>AMD模块是提前执行的, 而CMD模块默认是延迟执行的（性能更好）</li>
</ul>
<h3 id="ES6-Module-面向未来的标准"><a href="#ES6-Module-面向未来的标准" class="headerlink" title="ES6 Module(面向未来的标准)"></a>ES6 Module(面向未来的标准)</h3><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。<br>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>定义模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量, module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> bar = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数, module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一导出&amp;重命名, module.js</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; bar <span class="keyword">as</span> myBar, foo &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出, module.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo</span><br></pre></td></tr></table></figure>

<p>引用模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从模块中导入指定对象, 支持重命名, main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar <span class="keyword">as</span> myBar &#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从模块中导入默认对象(名称可跟原名称不一样)</span></span><br><span class="line"><span class="keyword">import</span> myFoo <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块, 但不导入任何值</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myModule <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="对于-CommonJS-和-ES6-中的模块化的两者区别是："><a href="#对于-CommonJS-和-ES6-中的模块化的两者区别是：" class="headerlink" title="对于 CommonJS 和 ES6 中的模块化的两者区别是："></a>对于 CommonJS 和 ES6 中的模块化的两者区别是：</h3><ul>
<li>前者⽀持动态导⼊，也就是 require(${path}/xx.js) ，后者⽬前不⽀持，但是已有提案,前者是同步导⼊，因为⽤于服务端，⽂件都在本地，同步导⼊即使卡住主线程影响也不⼤。</li>
<li>⽽后者是异步导⼊，因为⽤于浏览器，需要下载⽂件，如果也采⽤同步导⼊会对渲染有很<br>⼤影响</li>
<li>前者在导出时都是值拷⻉，就算导出的值变了，导⼊的值也不会改变，所以如果想更新值，必须重新导⼊⼀次。</li>
<li>但是后者采⽤实时绑定的⽅式，导⼊导出的值都指向同⼀个内存地址，所以导⼊值会跟随导出值变化</li>
<li>后者会编译成 require/exports 来执⾏的</li>
</ul>
<h1 id="模块化打包工具"><a href="#模块化打包工具" class="headerlink" title="模块化打包工具"></a>模块化打包工具</h1><p>由于模块化方案多样, 且浏览器支持不一, 再加上上述模块化方案仅仅支持JavaScript本身, 对 于复杂的前端应用来说远远不够用, 因此出现了各种打包工具来解决这些问题。</p>
<ul>
<li>早期打包工具</li>
</ul>
<ol>
<li>r.js – RequireJS提供的打包工具,仅仅支持RequireJS</li>
<li>SPM – SeaJS提供的打包工具,仅仅支持SeaJS</li>
<li>browserify – 让浏览器使用Node.js的NPM模块</li>
<li>gulp/grunt/fis – 前端自动化构建, 用来测试,压缩,检错,合并前端代码, 不支持模块化(类似Maven/Gradle)</li>
</ol>
<ul>
<li>现代打包工具</li>
</ul>
<ol>
<li>webpack – 高度可配置的静态资源打包器, 有着强大的插件和生态</li>
<li>rollup – 小巧高效的前端资源打包器, 适合用来编写库或框架</li>
<li>parcel – 后起之秀, 极速零配置Web应用打包工具</li>
</ol>
<p>webpack和gulp的区别：</p>
<p>gulp是<strong>基于流的构建工具</strong>：all in one的打包模式，输出一个js文件和一个css文件，优点是减少http请求，万金油方案。<br>webpack是<strong>模块化管理工具</strong>，使用webpack可以对模块进行压缩、预处理、打包、按需加载等。</p>
<p><strong>总结：</strong><br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/zongjie.png" alt="markdown"></p>
<h1 id="webpack打包优化"><a href="#webpack打包优化" class="headerlink" title="webpack打包优化"></a>webpack打包优化</h1><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低<br>Webpack在启动后会根据Entry配置的入口出发，递归地解析所依赖的文件。这个过程分为搜索文件和把匹配的文件进行分析、转化的两个过程，因此可以从这两个角度来进行优化配置</p>
<h2 id="devServer提高开发效率"><a href="#devServer提高开发效率" class="headerlink" title="devServer提高开发效率"></a>devServer提高开发效率</h2><ul>
<li>在package.json中配置命令 “webpack –watch” 可以监听到打包文件的变化，实现自动打包</li>
<li>在package.json中配置命令 “webpack-dev-server” ,再去webpack.config.js配置devServer，可以实现开启服务器打开页面（如果在本地打开文件则无法发送AJAX请求），设置open选项为true则会自动打开浏览器</li>
</ul>
<h2 id="优化构建速度"><a href="#优化构建速度" class="headerlink" title="优化构建速度"></a>优化构建速度</h2><h3 id="缩小文件的搜索范围"><a href="#缩小文件的搜索范围" class="headerlink" title="缩小文件的搜索范围"></a>缩小文件的搜索范围</h3><ol>
<li>resolve字段告诉webpack怎么去搜索文件，所以首先要重视resolve字段的配置</li>
</ol>
<ul>
<li><p>设置resolve.modules:[path.resolve(__dirname, ‘node_modules’)]避免层层查找<br>resolve.modules告诉webpack去哪些目录下寻找第三方模块，默认值为[‘node_modules’]，会依次查找./node_modules、../node_modules、../../node_modules</p>
</li>
<li><p>设置resolve.mainFields:[‘main’]，设置尽量少的值可以减少入口文件的搜索步骤</p>
</li>
</ul>
<p>第三方模块为了适应不同的使用环境，会定义多个入口文件，mainFields定义使用第三方模块的哪个入口文件，由于大多数第三方模块都使用main字段描述入口文件的位置，所以可以设置单独一个main值，减少搜索</p>
<ul>
<li>对庞大的第三方模块设置resolve.alias, 使webpack直接使用库的min文件，避免库内解析</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如对于react：</span></span><br><span class="line">    resolve.alias:&#123;</span><br><span class="line">        <span class="string">&#x27;react&#x27;</span>:patch.resolve(__dirname, <span class="string">&#x27;./node_modules/react/dist/react.min.js&#x27;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样会影响Tree-Shaking，适合对整体性比较强的库使用，如果是像lodash这类工具类的比较分散的库，比较适合Tree-Shaking，避免使用这种方式</p>
<ul>
<li>合理配置resolve.extensions，减少文件查找</li>
</ul>
<p>默认值：extensions:[‘.js’, ‘.json’],当导入语句没带文件后缀时，Webpack会根据extensions定义的后缀列表进行文件查找，所以：</p>
<p>a.列表值尽量少<br>b.频率高的文件类型的后缀写在前面<br>c.源码中的导入语句尽可能的写上文件后缀，如require(./data)要写成require(./data.json)</p>
<ol start="2">
<li>module.noParse字段告诉Webpack不必解析哪些文件，可以用来排除对非模块化库文件的解析</li>
</ol>
<p>如jQuery、ChartJS，另外如果使用resolve.alias配置了react.min.js，则也应该排除解析，因为react.min.js经过构建，已经是可以直接运行在浏览器的、非模块化的文件了。noParse值可以是RegExp、[RegExp]、function</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123; <span class="attr">noParse</span>:[<span class="regexp">/jquery|chartjs/</span>, <span class="regexp">/react\.min\.js$/</span>] &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置loader时，通过test、exclude、include缩小搜索范围</li>
</ol>
<h3 id="使用DllPlugin减少基础模块编译次数"><a href="#使用DllPlugin减少基础模块编译次数" class="headerlink" title="使用DllPlugin减少基础模块编译次数"></a>使用DllPlugin减少基础模块编译次数</h3><p>DllPlugin动态链接库插件，其原理是把网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取。<strong>为什么会提升构建速度呢？</strong>原因在于dll中大多包含的是常用的第三方模块，如react、react-dom，所以只要这些模块版本不升级，就只需被编译一次。这样做和配置resolve.alias和module.noParse的效果有异曲同工的效果</p>
<h3 id="使用HappyPack开启多进程Loader转换"><a href="#使用HappyPack开启多进程Loader转换" class="headerlink" title="使用HappyPack开启多进程Loader转换"></a>使用HappyPack开启多进程Loader转换</h3><p>在整个构建流程中，最耗时的就是Loader对文件的转换操作了，而运行在Node.js之上的Webpack是单线程模型的，也就是只能一个一个文件进行处理，不能并行处理。HappyPack可以将任务分解给多个子进程，多个子进程去并发的执行，最后将结果发给主进程。JS是单线程模型，只能通过这种多进程的方式提高性能</p>
<h3 id="使用ParallelUglifyPlugin开启多进程压缩JS文件"><a href="#使用ParallelUglifyPlugin开启多进程压缩JS文件" class="headerlink" title="使用ParallelUglifyPlugin开启多进程压缩JS文件"></a>使用ParallelUglifyPlugin开启多进程压缩JS文件</h3><p>使用UglifyJS插件压缩JS代码时，需要先将代码解析成Object表示的AST（抽象语法树），再去应用各种规则去分析和处理AST，所以这个过程计算量大耗时较多。ParallelUglifyPlugin可以开启多个子进程，每个子进程使用UglifyJS压缩代码，可以并行执行，能显著缩短压缩时间</p>
<p>在 Webpack4 中，我们就不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 console.log 这类代码的功能</p>
<h2 id="优化输出质量-压缩文件体积"><a href="#优化输出质量-压缩文件体积" class="headerlink" title="优化输出质量-压缩文件体积"></a>优化输出质量-压缩文件体积</h2><h3 id="区分环境–减小生产环境代码体积"><a href="#区分环境–减小生产环境代码体积" class="headerlink" title="区分环境–减小生产环境代码体积"></a>区分环境–减小生产环境代码体积</h3><p>代码运行环境分为开发环境和生产环境，代码需要根据不同环境做不同的操作，许多第三方库中也有大量的根据开发环境判断的if else代码，构建也需要根据不同环境输出不同的代码，所以需要一套机制可以在源码中区分环境，区分环境之后可以使输出的生产环境的代码体积减小。Webpack中使用DefinePlugin插件来定义配置文件适用的环境</p>
<h3 id="压缩代码-JS、ES、CSS"><a href="#压缩代码-JS、ES、CSS" class="headerlink" title="压缩代码-JS、ES、CSS"></a>压缩代码-JS、ES、CSS</h3><ol>
<li>Webpack内置UglifyJS插件、ParallelUglifyPlugin</li>
</ol>
<p>会分析JS代码语法树，理解代码的含义，从而做到去掉无效代码、去掉日志输入代码、缩短变量名等优化。</p>
<ol start="2">
<li><p>压缩ES6：第三方UglifyJS插件<br>随着越来越多的浏览器支持直接执行ES6代码，应尽可能的运行原生ES6，这样比起转换后的ES5代码，代码量更少，且ES6代码性能更好。直接运行ES6代码时，也需要代码压缩，第三方的uglify-webpack-plugin提供了压缩ES6代码的功能</p>
</li>
<li><p>压缩CSS：css-loader?minimize、PurifyCSSPlugin</p>
</li>
</ol>
<p>cssnano基于PostCSS，不仅是删掉空格，还能理解代码含义，例如把color:#ff0000 转换成 color:red，css-loader内置了cssnano，只需要使用 css-loader?minimize 就可以开启cssnano压缩</p>
<p>另外一种压缩CSS的方式是使用PurifyCSSPlugin，需要配合 extract-text-webpack-plugin 使用，它主要的作用是可以去除没有用到的CSS代码，类似JS的Tree Shaking</p>
<h3 id="使用Tree-Shaking剔除JS死代码"><a href="#使用Tree-Shaking剔除JS死代码" class="headerlink" title="使用Tree Shaking剔除JS死代码"></a>使用Tree Shaking剔除JS死代码</h3><p>Tree Shaking可以剔除用不上的死代码，<strong>它依赖ES6的import、export的模块化语法，最先在Rollup中出现，</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// test.js </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">2</span> <span class="comment">// index.js </span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./test.js&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="优化输出质量–加速网络请求"><a href="#优化输出质量–加速网络请求" class="headerlink" title="优化输出质量–加速网络请求"></a>优化输出质量–加速网络请求</h2><h3 id="使用CDN加速静态资源加载"><a href="#使用CDN加速静态资源加载" class="headerlink" title="使用CDN加速静态资源加载"></a>使用CDN加速静态资源加载</h3><p>CDN又称为内容分发网络，使内容传输的更快，更稳定。<br>也就是说，<strong>把静态资源文件和动态网页分集群部署</strong>，静态资源会被部署到CDN节点上，网页中引用的资源也会变成对应的部署路径。</p>
<p>由于CDN会为资源开启长时间的缓存，例如用户从CDN上获取了index.html，即使之后替换了CDN上的index.html，用户那边仍会在使用之前的版本直到缓存时间过期。业界做法：</p>
<ul>
<li>HTML文件：放在自己的服务器上且关闭缓存，不接入CDN</li>
<li>静态的JS、CSS、图片等资源：开启CDN和缓存，同时文件名带上由内容计算出的Hash值，这样只要内容变化hash就会变化，文件名就会变化，就会被重新下载而不论缓存时间多长。</li>
</ul>
<p>另外，HTTP1.x版本的协议下，浏览器会对于向同一域名并行发起的请求数限制在4~8个。那么把所有静态资源放在同一域名下的CDN服务上就会遇到这种限制，所以可以把他们分散放在不同的CDN服务上，例如JS文件放在js.cdn.com下，将CSS文件放在css.cdn.com下等。这样又会带来一个新的问题：增加了域名解析时间，这个可以通过dns-prefetch来解决 <code>&lt;link rel=&#39;dns-prefetch&#39; href=&#39;//js.cdn.com&#39;&gt;</code> 来缩减域名解析的时间。形如**//xx.com 这样的URL省略了协议**，这样做的好处是，浏览器在访问资源时会自动根据当前URL采用的模式来决定使用HTTP还是HTTPS协议。</p>
<h3 id="多页面应用提取页面间公共代码，以利用缓存"><a href="#多页面应用提取页面间公共代码，以利用缓存" class="headerlink" title="多页面应用提取页面间公共代码，以利用缓存"></a>多页面应用提取页面间公共代码，以利用缓存</h3><p>大型网站通常由多个页面组成，每个页面都是一个独立的单页应用，多个页面间肯定会依赖同样的样式文件、技术栈等。如果不把这些公共文件提取出来，那么每个单页打包出来的chunk中都会包含公共代码，相当于要传输n份重复代码。如果把公共文件提取出一个文件，那么当用户访问了一个网页，加载了这个公共文件，再访问其他依赖公共文件的网页时，就直接使用文件在浏览器的缓存，这样公共文件就只用被传输一次</p>
<h3 id="分割代码以按需加载"><a href="#分割代码以按需加载" class="headerlink" title="分割代码以按需加载"></a>分割代码以按需加载</h3><ul>
<li>将网站功能按照相关程度划分成几类</li>
<li>每一类合并成一个Chunk，按需加载对应的Chunk</li>
<li>例如，只把首屏相关的功能放入执行入口所在的Chunk，这样首次加载少量的代码，其他代码要用到的时候再去加载。最好提前预估用户接下来的操作，提前加载对应代码，让用户感知不到网络加载</li>
</ul>
<h2 id="优化的plugin"><a href="#优化的plugin" class="headerlink" title="优化的plugin"></a>优化的plugin</h2><p><strong>构建优化</strong></p>
<ul>
<li>减少编译体积 ContextReplacementPugin 、 IgnorePlugin 、 babel-pluginimport 、 babel-plugin-transform-runtime</li>
<li>并⾏编译 happypack 、 thread-loader 、 uglifyjsWebpackPlugin 开启并⾏ </li>
<li>缓存 cache-loader 、 hard-source-webpack-plugin 、 uglifyjsWebpackPlugin 开 启缓存、 babel-loader 开启缓存 </li>
<li>预编译 dllWebpackPlugin &amp;&amp; DllReferencePlugin 、 auto-dll-webapck-plugin</li>
</ul>
<p><strong>性能优化</strong></p>
<ul>
<li>减少编译体积 Tree-shaking 、 Scope Hositing hash </li>
<li>缓存 webpack-md5-plugin </li>
<li>拆包 splitChunksPlugin 、 import() 、 require.ensure</li>
</ul>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5aa3d2056fb9a028c36868aa#heading-7">webpack详解</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5badd0c5e51d450e4437f07a#heading-7">Webpack揭秘——走向高阶前端的必经之路</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5b652b036fb9a04fa01d616b">三十分钟掌握Webpack性能优化</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5b4609f5e51d4519596b66a7">手写一个webpack4.0配置</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/basic/" rel="tag"># basic</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/04/29/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/Promise/" rel="prev" title="Promise">
                  <i class="fa fa-chevron-left"></i> Promise
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/05/11/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" rel="next" title="面向对象编程">
                  面向对象编程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leslie choi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
