<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yoursite.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta property="og:type" content="website">
<meta property="og:title" content="404 not found">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="404 not found">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="leslie choi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;2&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>404 not found</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">404 not found</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">leslie choi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/30/vue/14%20$listener%E5%92%8C$attrs%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/30/vue/14%20$listener%E5%92%8C$attrs%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">$listener 和 $attrs 的使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-30 08:43:20" itemprop="dateCreated datePublished" datetime="2020-07-30T08:43:20+08:00">2020-07-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="listener-和-attrs-的使用"><a href="#listener-和-attrs-的使用" class="headerlink" title="$listener 和 $attrs 的使用"></a>$listener 和 $attrs 的使用</h1><p>背景：假设有一个 father 组件，father 组件中引入了 child 组件，child 组件中又引入了 son 组件。那么 father 组件和 child 组件之间如何通信呢？</p>
<p>解决方案：</p>
<ol>
<li>万金油方案 Vuex，使用 Vuex 虽然能够实现数据之间的共享，但是项目中如果组件之间共享状态比较少，或者说项目比较小，那么使用 Vuex 确实没太大必要。</li>
<li>将 child 组件当成一个中间站，然后利用父子组件之间 prop 和 $emit，一层一层向上或者向下传递信息，虽然可行但是使用麻烦并且可维护性差。</li>
<li>自定义一个Vue 中央数据总线（todo），但是多人协作麻烦</li>
</ol>
<p>针对这种情况，在vue2.4中，为了解决该需求，引入了$attrs 和$listeners，新增了inheritAttrs 选项。</p>
<p><strong>父组件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Father&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;child :temp&#x3D;&quot;tempdata&quot; @tempFn&#x3D;&quot;fatherFn&quot; prop&#x3D;&#39;$attrs不会传递child组件中定义的props5值&#39;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &#39;.&#x2F;Child.vue&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">      Child</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      tempdata: &#39;i am father data&#39;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;&#125;,</span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fatherFn: function() &#123;</span><br><span class="line">      console.log(&#39;call father function!&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>子组件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;child&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;son v-bind&#x3D;&quot;$attrs&quot; v-on&#x3D;&quot;$listeners&quot;&gt;&lt;&#x2F;son&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from &#39;.&#x2F;Son&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Child&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;&#125;,</span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(&#39;this.$attrs&#39;,this.$attrs)  &#x2F;&#x2F;  &#123;prop: &#39;$attrs不会传递child组件中定义的props5值&#39;,temp: &#39;i am father data&#39;&#125;</span><br><span class="line">    console.log(&#39;this.$listeners&#39;,this.$listeners)  &#x2F;&#x2F;  &#123;tempFn: fn&#125;</span><br><span class="line">    this.$emit(&#39;tempFn&#39;)   &#x2F;&#x2F;   子组件调用父组件方法</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>孙组件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;son&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123; $attrs.temp &#125;&#125;--------&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;&#125;,</span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    &#x2F;&#x2F; this.$emit(&#39;tempFn&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>$attrs：当前组件的属性，通俗的讲也就是在组件标签定义的一系列属性，如input的value，placeholder等，但是不包括在当前组件里面定义的props属性。</p>
</li>
<li><p>$listeners：当前组件监听的事件，通俗的讲也就是在使用组件的时候在标签中定义的事件，如@input，以及一些自定义事件@tempFn等。</p>
</li>
</ul>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p>(Vue中的$attrs和$listener)[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lsboom/p/11365293.html]">https://www.cnblogs.com/lsboom/p/11365293.html]</a><br>(绝对干货~！学会这些Vue小技巧，可以早点下班和女神约会了)[<a target="_blank" rel="noopener" href="https://juejin.im/post/5eddbaee5188254344768fdc#heading-10]">https://juejin.im/post/5eddbaee5188254344768fdc#heading-10]</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42966484/article/details/89408538">VUE中.sync 修饰符</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/30/vue/Vue%20%E7%BC%96%E7%A0%81%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/30/vue/Vue%20%E7%BC%96%E7%A0%81%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">vue 编码优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-30 08:43:20" itemprop="dateCreated datePublished" datetime="2020-07-30T08:43:20+08:00">2020-07-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-13 19:28:07" itemprop="dateModified" datetime="2021-04-13T19:28:07+08:00">2021-04-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="使用-Object-freeze-提升性能"><a href="#使用-Object-freeze-提升性能" class="headerlink" title="使用 Object.freeze() 提升性能"></a>使用 Object.freeze() 提升性能</h1><p>背景：在开发过程中，我们经常需要获取一些对象，像users信息，列表items，文章信息等等，但是我们不需要去修改这些信息。我们只是把这些信息展示出来，或者放在vuex中state里面。</p>
<p>Vue默认会对每个数组数据的每一层属性，添加双向数据绑定机制。当数组对象非常庞大时，消耗在这上面的双向数据绑定就越多。因为，在这种场景下，我们可以通过阻止Vue对这些数据添加双向数据绑定来提高一些性能。</p>
<p>根据 MDN 文档，使用 Object.freeze()，可以冻结一个对象，被冻结的对象则不能再被修改。即该对象不能添加、删除已有的属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。</p>
<p><strong>此外，冻结一个对象后该对象的原型也不能被修改。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&quot;james&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj)</span><br><span class="line"></span><br><span class="line">obj.prop = <span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.prop)</span><br></pre></td></tr></table></figure>

<p>PS: 顺便提一下密封对象和禁止对象属性拓展</p>
<ol>
<li><p>Object.preventExtensions()，禁止对象拓展，但是可以修改和删除对象的属性。<strong>Object.preventExtensions()仅阻止添加自身的属性。但其对象类型的原型依然可以添加新的属性。</strong></p>
</li>
<li><p>Object.seal()，可以修改对象属性，不可以删除和增加对象属性。</p>
</li>
</ol>
<p><strong>以上三个方法分别可用Object.isExtensible(), Object.isSealed(), Object.isFrozen() 来检测</strong></p>
<p>当你把一个普通的 JavaScript 对象传给 Vue 实例的  data  选项，Vue 将遍历此对象所有的属性，并使用  Object.defineProperty  把这些属性全部转为 getter/setter，这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>
<p>但 Vue 在遇到像 Object.freeze() 这样被设置为不可配置之后的对象属性时，不会为对象加上 setter getter 等数据劫持的方法，使用了 Object.freeze() 之后，减少了 observer 的开销。</p>
<p>由于 Object.freeze()会把对象冻结，所以比较适合展示类的场景，如果你的数据属性需要改变，可以重新替换成一个新的 Object.freeze()的对象。<strong>由于 Object.freeze()会把对象冻结，所以比较适合展示类的场景，如果你的数据属性需要改变，可以重新替换成一个新的 Object.freeze()的对象。</strong></p>
<h1 id="requireContext-导入组件-todo"><a href="#requireContext-导入组件-todo" class="headerlink" title="requireContext 导入组件(todo)"></a>requireContext 导入组件(todo)</h1><h1 id="sync-的使用"><a href="#sync-的使用" class="headerlink" title=".sync 的使用"></a>.sync 的使用</h1><p>背景：在 Vue1.x 版本，.sync 还可以进行双向数据绑定，即说明子组件中可以修改父组件的值。但是这与单向数据流的设计理念相违背，所以在 Vue2.0 版本中被舍弃。直到 Vue2.3 版本及以上，重新引进了 .sync 修饰符，这次只是作为语法糖的存在。存在的意义就是让我们手动更新父组件中的值，并且让其的数据改动来源更加明显。</p>
<p><strong>适用于单纯在子组件中修改父组件中数据的场景</strong></p>
<p>父组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;我是父组件中的按钮&quot; @click&#x3D;&quot;show&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- &lt;Son @upIsShow&#x3D;&quot;changeIsShow&quot; v-show&#x3D;&quot;isShow&quot; &#x2F;&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;Son @update:isShow&#x3D;&quot;changeIsShow&quot; v-show&#x3D;&quot;isShow&quot;&#x2F;&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;Son @update:isShow&#x3D;&quot;function(bol)&#123;isShow&#x3D;bol&#125;&quot; v-show&#x3D;&quot;isShow&quot;&#x2F;&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;Son @update:isShow&#x3D;&quot;bol&#x3D;&gt;isShow&#x3D;bol&quot; v-show&#x3D;&quot;isShow&quot;&#x2F;&gt; --&gt;</span><br><span class="line">    &lt;Son :isShow.sync&#x3D;&quot;isShow&quot; v-show&#x3D;&quot;isShow&quot; :age.sync&#x3D;&quot;age&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- 当子组件想要更改isShow的值，需要显式触发 this.$emit(&quot;update:isShow&quot;,false) 事件--&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;this.age&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from &quot;..&#x2F;components&#x2F;sync&#x2F;Son&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isShow: false,</span><br><span class="line">      age: 20</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    show() &#123;</span><br><span class="line">      this.isShow &#x3D; true</span><br><span class="line">    &#125;,</span><br><span class="line">    changeIsShow(bol) &#123;</span><br><span class="line">      this.isShow &#x3D; bol</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是一个子组件！</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;点击消失&quot; @click&#x3D;&quot;upIsShow&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    upIsShow() &#123;</span><br><span class="line">      &#x2F;&#x2F; this.$emit(&quot;upIsShow&quot;, false)</span><br><span class="line">      this.$emit(&quot;update:isShow&quot;,false)</span><br><span class="line">      this.$emit(&quot;update:age&quot;,22)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="动态组件渲染"><a href="#动态组件渲染" class="headerlink" title="动态组件渲染"></a>动态组件渲染</h1><h1 id="常见性能优化方式"><a href="#常见性能优化方式" class="headerlink" title="常见性能优化方式"></a>常见性能优化方式</h1><ol>
<li><p>合理使用 v-show 和 v-if</p>
</li>
<li><p>合理使用 compited</p>
</li>
<li><p>v-for 加上 key，避免和 v-if 同时使用</p>
</li>
<li><p>合理使用 keep-alive</p>
</li>
<li><p>合理使用异步组件</p>
</li>
<li><p>自定义事件、DOM 事件及时销毁</p>
</li>
<li><p>data 层级不要嵌套太深</p>
</li>
<li><p>开发环境使用 vue-loader 做模版编译（预编译）</p>
</li>
<li><p>使用 SSR</p>
</li>
</ol>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d5e89aee51d453bdb1d9b61">利用Object.freeze()提升性能</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/56168a779849">Object.freeze()提高Vue.js中大型列表的性能【翻译+解读】</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/26/JavaScript/javascript%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/26/JavaScript/javascript%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">JavaScript 开发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-26 16:19:11" itemprop="dateCreated datePublished" datetime="2020-07-26T16:19:11+08:00">2020-07-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="判断设备"><a href="#判断设备" class="headerlink" title="判断设备"></a>判断设备</h1><ol>
<li>判断当前设备类型</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="title">getPhoneType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> u = navigator.userAgent</span><br><span class="line">  <span class="keyword">if</span> (u.indexOf(<span class="string">&#x27;Android&#x27;</span>) &gt; -<span class="number">1</span> || u.indexOf(<span class="string">&#x27;Linux&#x27;</span>) &gt; -<span class="number">1</span>) &#123; <span class="comment">// 安卓手机</span></span><br><span class="line">    result = <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.indexOf(<span class="string">&#x27;iPhone&#x27;</span>) &gt; -<span class="number">1</span>) &#123; <span class="comment">// 苹果手机</span></span><br><span class="line">    result = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.indexOf(<span class="string">&#x27;Windows Phone&#x27;</span>) &gt; -<span class="number">1</span>) &#123; <span class="comment">// winphone手机</span></span><br><span class="line">    result = <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.indexOf(<span class="string">&#x27;iPhone Simulator&#x27;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    result = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>判断是否 IPhoneX 系列</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="title">isIphoneXall</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// iPhone X、iPhone XS</span></span><br><span class="line">  <span class="keyword">const</span> isIPhoneX = <span class="regexp">/iphone/gi</span>.test(<span class="built_in">window</span>.navigator.userAgent) &amp;&amp; <span class="built_in">window</span>.screen.width === <span class="number">375</span> &amp;&amp; <span class="built_in">window</span>.screen.height === <span class="number">812</span></span><br><span class="line">  <span class="comment">// iPhone XS Max</span></span><br><span class="line">  <span class="keyword">const</span> isIPhoneXSMax = <span class="regexp">/iphone/gi</span>.test(<span class="built_in">window</span>.navigator.userAgent) &amp;&amp; <span class="built_in">window</span>.screen.width === <span class="number">414</span> &amp;&amp; <span class="built_in">window</span>.screen.height === <span class="number">896</span></span><br><span class="line">  <span class="comment">// iPhone XR</span></span><br><span class="line">  <span class="keyword">const</span> isIPhoneXR = <span class="regexp">/iphone/gi</span>.test(<span class="built_in">window</span>.navigator.userAgent) &amp;&amp; <span class="built_in">window</span>.screen.width === <span class="number">414</span> &amp;&amp; <span class="built_in">window</span>.screen.height === <span class="number">896</span></span><br><span class="line">  <span class="keyword">if</span> (isIPhoneX || isIPhoneXSMax || isIPhoneXR) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="判断是否是-url"><a href="#判断是否是-url" class="headerlink" title="判断是否是 url"></a>判断是否是 url</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> isUrl = <span class="function"><span class="params">str</span> =&gt;</span> <span class="regexp">/^(((ht|f)tps?):\/\/)?[\w-]+(\.[\w-]+)+([\w.,@?^=%&amp;:/~+#-]*[\w@?^=%&amp;/~+#-])?$/</span>.test(str)</span><br><span class="line"><span class="comment">// e.g.</span></span><br><span class="line">isUrl(<span class="string">&#x27;https://www.baidu.com&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">isUrl(<span class="string">&#x27;https://www&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="连字符和驼峰互相转换"><a href="#连字符和驼峰互相转换" class="headerlink" title="连字符和驼峰互相转换"></a>连字符和驼峰互相转换</h1><ol>
<li>连字符转驼峰</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> toCamelCase = <span class="function">(<span class="params">str = <span class="string">&#x27;&#x27;</span>, separator = <span class="string">&#x27;-&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Argument must be a string&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> newExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;\\-\(\\w\)&#x27;</span>, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> str.replace(newExp, <span class="function">(<span class="params">matched, $<span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> $<span class="number">1.</span>toUpperCase()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g.</span></span><br><span class="line">toCamelCase(<span class="string">&#x27;hello-world&#x27;</span>) <span class="comment">// helloWorld</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>驼峰转连字符</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> fromCamelCase = <span class="function">(<span class="params">str = <span class="string">&#x27;&#x27;</span>, separator = <span class="string">&#x27;-&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Argument must be a string&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/([A-Z])/g</span>, <span class="string">`<span class="subst">$&#123;separator&#125;</span>$1`</span>).toLowerCase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g.</span></span><br><span class="line">fromCamelCase(<span class="string">&#x27;helloWorld&#x27;</span>) <span class="comment">// hello-world</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>






<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>(【适合收藏】为了多点时间陪女朋友，我向BAT大佬跪求了这15条JS技巧)[<a target="_blank" rel="noopener" href="https://juejin.im/post/6854573211955560455]">https://juejin.im/post/6854573211955560455]</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/11/%E7%BD%91%E7%BB%9C/%E5%89%8D%E7%AB%AF%E7%99%BB%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/11/%E7%BD%91%E7%BB%9C/%E5%89%8D%E7%AB%AF%E7%99%BB%E5%BD%95/" class="post-title-link" itemprop="url">前端登录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-11 14:00:25" itemprop="dateCreated datePublished" datetime="2020-01-11T14:00:25+08:00">2020-01-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="传统的登录方案"><a href="#传统的登录方案" class="headerlink" title="传统的登录方案"></a>传统的登录方案</h1><p>http 是一种无状态的协议，也就是说它并不知道哪一个用户访问量了应用。针对 http 无状态的这样一个特点，解决的方法就是使用 cookie 记录用户的登录状态。  </p>
<p>每当用户登录之后，如果登录成功，服务端就会生成一条记录，这个记录保存了一个 sessionId，可以用来判断当前的用户是哪一个，然后再将这个 sessionId 发送到客户端，客户端可以将这个 session ID 保存到 cookie 中，下次这个用户再次向服务器发送请求的时候，就可以携带 Cookie，这个时候服务端就会验证 cookie 里面的信息，如果能在服务端中找到对应的记录，就说明用户已经通过了身份的验证，然后就可以把用户请求的数据返回给客户端。</p>
<p>上面的解决方法就是使用 session 配合 cookie 解决的，但是这样就存在一种问题，服务端需要存储登录用户生成的 Session，而这些 Session 可能会存储在内存中、磁盘、数据库里面，所以我们就必须定时去清理过期的 Session，这种认证方法出现的问题就是，如果用户量增多，那么服务器的开销就会不断增加，而且使用到 cookie，就很容易受到跨站点请求伪造（CSRF）的攻击</p>
<h1 id="token-登录验证"><a href="#token-登录验证" class="headerlink" title="token 登录验证"></a>token 登录验证</h1><p>针对这样一种情况，新增一种 token 的解决方案</p>
<p>简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</p>
<p>特点：服务端无状态化、可扩展性好 支持移动端设备 相对安全 支持跨程序调用</p>
<p><strong>传统的 token 的身份验证流程：</strong></p>
<ul>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</li>
<li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</li>
<li>服务端收到请求，然后去验证客户端请求里面带着的 token ，<strong>和数据库中的 token 进行对比</strong>，如果验证成功，就向客户端返回请求的数据</li>
</ul>
<p>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</p>
<p>基于 token 的用户认证是一种服务端无状态的认证方式，服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库。</p>
<p>token 完全由应用管理，所以它可以避开同源策略，也可以防止 CSRF 攻击。<strong>因为请求中发送 token，而不再是发送 cookie，即使说在客户端使用 cookie 存储 token，cookie 也只是一种存储机制，而不再是用于认证，所以相对比较安全</strong></p>
<h1 id="jwt-登录验证"><a href="#jwt-登录验证" class="headerlink" title="jwt 登录验证"></a>jwt 登录验证</h1><p>使用传统的token 进行身份验证，存在下面的缺点，就是<strong>服务端需要保存 token</strong>，以后用户再来访问的时候，需要携带token，然后再去数据库中获取token进行校验。</p>
<p>而使用JWT，是将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</p>
<p><strong>jwt 的身份认证流程</strong></p>
<ul>
<li>客户端输入账号密码进行登录，向服务端发送请求</li>
<li>如果用户登录成功，服务端使用密钥创建 JWT，然后将 JWT 返回给浏览器</li>
<li>在下一次浏览器向服务器发送请求的时候，将 JWT 一起发送给服务器</li>
<li>然后服务端检查 JWT 的签名，从 JWT 中获取用户的信息，检查通过则可以把响应发送给客户端</li>
</ul>
<p>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用 Bearer 模式添加 JWT，其内容看起来是下面这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure>

<p>JWT 原理：</p>
<p>JWT 生成的 token 是由三段字符串组成的，并且用.连接起来</p>
<ul>
<li>第一段字符串 header，内部包含加密算法/token 类型</li>
<li>第二段字符串 payload（可以为空），自定义值，比如用户 id，用户姓名，超时时间等用户非敏感的信息</li>
<li>第三段字符串：将前两段字符串使用明文拼接起来，然后对前两部分密文进行加密（加密算法可以自己定义）和加盐处理，然后再使用加密算法再对前两部分的密文再进行加密。</li>
</ul>
<p>以后用户再来访问的时候，都需要携带 token，然后后端需要对 token 进行检验</p>
<ul>
<li>第一步：获取 token，然后对 token 进行切割</li>
<li>第二步：对第二段进行解密，然后获取 payload 信息，检测 token 是否已经超时</li>
<li>第三步：把第一二段密文再进行拼接，再次执行加密，如果结果和传过来的密文一致，则说明 token 没有被修改过，则认证通过。</li>
</ul>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="使用-cookie-时需要考虑的问题"><a href="#使用-cookie-时需要考虑的问题" class="headerlink" title="使用 cookie 时需要考虑的问题"></a>使用 cookie 时需要考虑的问题</h2><ul>
<li>因为存储在客户端，容易被客户端篡改，使用前需要验证合法性</li>
<li>不要存储敏感数据，比如用户密码，账户余额</li>
<li>使用 httpOnly 在一定程度上提高安全性</li>
<li>尽量减少 cookie 的体积，能存储的数据量不能超过 4kb</li>
<li>设置正确的 domain 和 path，减少数据传输</li>
<li>cookie 无法跨域</li>
<li>一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie</li>
<li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</li>
</ul>
<h2 id="使用-session-时需要考虑的问题"><a href="#使用-session-时需要考虑的问题" class="headerlink" title="使用 session 时需要考虑的问题"></a>使用 session 时需要考虑的问题</h2><ul>
<li>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session</li>
<li>当网站采用集群部署的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。</li>
<li>当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。</li>
<li><strong>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？</strong> 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现</li>
<li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token。</li>
</ul>
<h2 id="使用-token-时需要考虑的问题"><a href="#使用-token-时需要考虑的问题" class="headerlink" title="使用 token 时需要考虑的问题"></a>使用 token 时需要考虑的问题</h2><ul>
<li>如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。</li>
<li>token 完全由应用管理，所以它可以避开同源策略</li>
<li>token 可以避免 CSRF 攻击(因为不需要 cookie 了)</li>
<li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</li>
</ul>
<h2 id="使用-JWT-时需要考虑的问题"><a href="#使用-JWT-时需要考虑的问题" class="headerlink" title="使用 JWT 时需要考虑的问题"></a>使用 JWT 时需要考虑的问题</h2><ul>
<li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）<br>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li>
<li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li>
<li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li>
<li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li>
<li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li>
<li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。<br>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li>
</ul>
<h2 id="使用加密算法时需要考虑的问题"><a href="#使用加密算法时需要考虑的问题" class="headerlink" title="使用加密算法时需要考虑的问题"></a>使用加密算法时需要考虑的问题</h2><ul>
<li>绝不要以明文存储密码</li>
<li><strong>永远使用 哈希算法 来处理密码，绝不要使用 Base64 或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码。</strong>编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道， 这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希这种说法， 但是编码就存在解码，加密就存在解密。</li>
<li>绝不要使用弱哈希或已被破解的哈希算法，像 MD5 或 SHA1 ，只使用强密码哈希算法。</li>
<li>绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样。如果你需要 “忘记密码” 的功能，可以随机生成一个新的 一次性的（这点很重要）密码，然后把这个密码发送给用户。</li>
</ul>
<h2 id="只要关闭浏览器-，session-真的就消失了？"><a href="#只要关闭浏览器-，session-真的就消失了？" class="headerlink" title="只要关闭浏览器 ，session 真的就消失了？"></a>只要关闭浏览器 ，session 真的就消失了？</h2><p>不对。对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 log off 的时候发个指令去删除 session。<br>然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session id 就消失了，再次连接服务器时也就无法找到原来的 session。<br>如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。<strong>恰恰是由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。</strong></p>
<h1 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p>
<p>SSO一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证。</p>
<p>大概流程就是这样</p>
<ul>
<li><p>用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将<strong>自己的地址</strong>作为参数</p>
</li>
<li><p>sso认证中心发现用户未登录，将用户引导至登录页面</p>
</li>
<li><p>用户输入用户名密码提交登录申请</p>
</li>
<li><p>sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌</p>
</li>
<li><p>sso认证中心带着令牌跳转会最初的请求地址（系统1）</p>
</li>
<li><p>系统1拿到令牌，去sso认证中心校验令牌是否有效</p>
</li>
<li><p>sso认证中心校验令牌，返回有效，注册系统1</p>
</li>
<li><p>系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</p>
</li>
<li><p>用户访问系统2的受保护资源</p>
</li>
<li><p>系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</p>
</li>
<li><p>sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</p>
</li>
<li><p>系统2拿到令牌，去sso认证中心校验令牌是否有效</p>
</li>
<li><p>sso认证中心校验令牌，返回有效，注册系统2</p>
</li>
<li><p>系统2使用该令牌创建与用户的局部会话，返回受保护资源</p>
</li>
</ul>
<p>用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系</p>
<ul>
<li><p>局部会话存在，全局会话一定存在</p>
</li>
<li><p>全局会话存在，局部会话不一定存在</p>
</li>
<li><p>全局会话销毁，局部会话必须销毁</p>
</li>
</ul>
<p>总结：</p>
<ul>
<li>SSO系统生成一个token，并将用户信息存到Redis中，并设置过期时间</li>
<li>其他系统请求SSO系统进行登录，得到SSO返回的token，写到Cookie中</li>
<li>每次请求时，Cookie都会带上，拦截器得到token，判断是否已经登录<br>（关于cookie跨域的问题，多个域名共享Cookie，在写到客户端的时候设置Cookie的domain。）</li>
</ul>
<h2 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h2><p>现在我们有两个系统，分别是 <code>www.java3y.com</code> 和 <code>www.java4y.com</code> ，一个SSO<code>www.sso.com</code></p>
<p>首先，用户想要访问系统A <code>www.java3y.com</code>受限的资源(比如说购物车功能，购物车功能需要登录后才能访问)，系统A <code>www.java3y.com</code> 发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：</p>
<p><code>www.sso.com?service=www.java3y.com</code></p>
<p>sso认证中心发现用户未登录，将用户引导至登录页面，用户进行输入用户名和密码进行登录，用户与认证中心建立全局会话（生成一份Token，写到Cookie中，保存在浏览器上）</p>
<p>随后，认证中心重定向回系统A，并把Token携带过去给系统A，重定向的地址如下：</p>
<p><code>www.java3y.com?token=xxxxxxx</code></p>
<p>接着，系统A去sso认证中心验证这个Token是否正确，如果正确，则系统A和用户建立局部会话（创建Session）。到此，系统A和用户已经是登录状态了。</p>
<p>此时，用户想要访问系统B <code>www.java4y.com</code> 受限的资源(比如说订单功能，订单功能需要登录后才能访问)，系统B <code>www.java4y.com</code> 发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：</p>
<p><code>www.sso.com?service=www.java4y.com</code></p>
<p>注意，因为之前用户与认证中心<a target="_blank" rel="noopener" href="http://www.sso.com已经建立了全局会话(当时已经把cookie保存到浏览器上了),所以这次系统b重定向到认证中心/">www.sso.com已经建立了全局会话（当时已经把Cookie保存到浏览器上了），所以这次系统B重定向到认证中心</a> <code>www.sso.com</code> 是可以带上Cookie的。<br>认证中心根据带过来的Cookie发现已经与用户建立了全局会话了，认证中心重定向回系统B，并把Token携带过去给系统B，重定向的地址如下：</p>
<p><code>www.java4y.com?token=xxxxxxx</code></p>
<p>接着，系统B去sso认证中心验证这个Token是否正确，如果正确，则系统B和用户建立局部会话（创建Session）。到此，系统B和用户已经是登录状态了。</p>
<p>看到这里，其实SSO认证中心就类似一个中转站。</p>
<h2 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a>代码实现思路</h2><ol>
<li><p>新建一个SSO的类,这个类有baseUrL的属性,因为每次验证都需要传过来一个地址。</p>
</li>
<li><p>然后SSO类主要存在以下两个个方法。</p>
</li>
</ol>
<ul>
<li><p>验证TGT(Ticket Grangting Ticket)是否有效,如果有效,则可以证明用户在CAS成功登录过(用来判断是否登陆过)。</p>
</li>
<li><p>验证Service ticket(ST),务票据，服务的惟一标识码 , 由 CASServer 发出（ Http 传送），用户访问Service时，service发现用户没有ST，则要求用户去CAS获取ST.用户向CAS发出获取ST的请求，CAS发现用户有TGT，则签发一个ST，返回给用户。用户拿着ST去访问service，service拿ST去CAS验证，验证通过后，允许用户访问资源。</p>
</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e055d9ef265da33997a42cc">傻傻分不清之 Cookie、Session、Token、JWT</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/25/css/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/08/25/css/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">移动端常见问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-25 20:29:25" itemprop="dateCreated datePublished" datetime="2019-08-25T20:29:25+08:00">2019-08-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="300毫秒延迟的由来和解决方法"><a href="#300毫秒延迟的由来和解决方法" class="headerlink" title="300毫秒延迟的由来和解决方法"></a>300毫秒延迟的由来和解决方法</h1><ol>
<li><p>300 毫秒延迟的主要原因是解决双击缩放。双击缩放，顾名思义，即用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 那么这和 300 毫秒延迟有什么联系呢？ 假定这么一个场景。用户在 iOS Safari 里边点击了一个链接。由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。 <strong>鉴于iPhone的成功，其他移动浏览器都复制了 iPhone Safari 浏览器的多数约定，包括双击缩放，几乎现在所有的移动端浏览器都有这个功能。</strong></p>
</li>
<li><p>解决方案</p>
</li>
</ol>
<ul>
<li>粗暴型，禁用缩放，添加viewport meta标签</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用fastclick</li>
</ul>
<p>移动端事件触发顺序：在移动端，手指点击一个元素，会经过：touchstart –&gt; touchmove -&gt; touchend –&gt;click。</p>
<p>fastclick.js的原理是：FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即触发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉。</p>
<h1 id="SPA单页面应用优化"><a href="#SPA单页面应用优化" class="headerlink" title="SPA单页面应用优化"></a>SPA单页面应用优化</h1><ol>
<li>SSR服务端渲染直出</li>
</ol>
<p>服务端渲染主要有两个目的，一是 SEO，二是加快内容展现。<br>在带来这两个好处的同时，<strong>我们也需要评估服务端渲染的成本，首先我们需要服务端的支持，因此涉及到了服务构建、部署等，同时 web 项目是一个流量较大的网站，也需要考虑服务器的负载，以及相应的缓存策略，</strong>特别像我们行业，由于地理位置的不同，不同用户看到的页面也是不一样的，也就是所谓的千人千面，这也为缓存造成了一定困难。</p>
<p>ssr是Server-Side Rendering的简写，即由服务端负责渲染页面直出，亦即同构应用。程序的大部分代码都可以在服务端和客户端运行。在服务端vue组件渲染为html字符串，然后直接返回给客户端，在客户端生成dom和操作dom。</p>
<p>能在服务端渲染为html字符串得益于vue组件结构是基于vnode的。vnode是dom的抽象表达，它不是真实的dom，它是由js对象组成的树，每个节点代表了一个dom。因为vnode，所以在服务端vue可以把js对象解析为html字符串。同样在客户端vnode因为是存在内存之中的，操作内存总比操作dom快的多，每次数据变化需要更新dom时，新旧vnode树经过diff算法，计算出最小变化集，大大提高了性能。</p>
<p><strong>服务端渲染 SSR 的优缺点如下：</strong></p>
<p>(1) 服务端渲染的优点：</p>
<ul>
<li><p>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面</p>
</li>
<li><p>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间</p>
</li>
</ul>
<p>(2) 服务端渲染的缺点：</p>
<ul>
<li><p>更多的开发条件限制： <strong>例如服务端渲染只支持 beforCreate 和 created 两个钩子函数</strong>，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境</p>
</li>
<li><p>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p>
</li>
</ul>
<ol start="2">
<li>使用预渲染</li>
</ol>
<p>所谓预渲染，就是在项目的构建过程中，通过一些渲染机制，比如 puppeteer或者 jsdom 将页面在构建的过程中就渲染好，然后插入到 html 中，这样在页面启动之前首先看到的就是预渲染的页面了</p>
<p>预渲染渲染的页面数据是在构建过程中就已经打包到了 html 中， 当真实访问页面的时候，真实数据可能已经和预渲染的数据有了很大的出入，而且预渲染的页面也是一个不可交互的页面，在页面没有启动之前，用户无法和预渲染的页面进行任何交互，预渲染页面中的数据反而会影响到用户获取真实的信息，当涉及到一些价格、金额、地理位置的地方甚至会导致用户做出一些错误的决定。</p>
<p>预渲染虽然可以提⾼⻚⾯的加载速度，但是要确保该⻚⾯百分百会被⽤户在之后打开，否则就⽩⽩浪费资源去渲染</p>
<ol start="3">
<li>使用骨架图</li>
</ol>
<p>因为移动端经常要考虑到用户的网络问题，如果网络慢的话对于用户的体验是非常差的，那我们就必须在这个基础上进行优化。举个常见的场景就是首页有个轮播图，在网络慢的情况下，很有可能是轮播图下面的其他区域内容先渲染出来，等到几秒过后，本来应该是在中间的区域，会先在顶部渲染出来，然后等到轮播图渲染出来之后，再被挤到原来的区域，所以用户视觉上会有一个页面抖动的情况，这种情况当然是要避免出现的。所以最好的话，可以提前给每一个区域占个坑。最简单的实现方式就是通过CSS来实现，需要先根据设计稿，计算出宽高比，使用padding-bottom，然后再加上个灰色的背景颜色。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">	<span class="attribute">overflow</span>: hidden;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">padding-bottom</span>: <span class="number">30%</span>;</span><br><span class="line">	<span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然还有其他的实现思路，比如说使用骨架屏<br>骨架屏个人理解就是特殊的loading，但是体验比普通loading一直转圈圈好很多，可以让用户能够感知到即将加载页面的基本 CSS 样式和页面布局。</p>
<p>比如每次饿了么点外卖的时候网络不好，或者登录掘金论坛的时候，可能首先渲染出来的时候是屏幕填了一个个的坑，显示出了页面的大概布局应该就是用的骨架屏原理，但是使用注意保证骨架屏图片体积尽可能小，因为要保证以最快的时间加载出来，而且打入本地app<br>如果说使用vue开发的话，也可以直接也可以使用插件vue-skeleton-webpack-plugin</p>
<ul>
<li>webpack.dev.conf.js和webpack.prod.conf.js中引入插件</li>
<li>创建骨架屏组件 src/skeleton.vue</li>
<li>创建骨架屏组件的入口文件src/entry-skeleton.js</li>
</ul>
<ol start="4">
<li>使用offline-plugin搭配webpack轻松实现PWA进行优化</li>
</ol>
<p>使用PWA的离线缓存，类似于HTTP cache缓存，但是相对来说缓存更可控。</p>
<h1 id="科普PWA"><a href="#科普PWA" class="headerlink" title="科普PWA"></a>科普PWA</h1><p>PWA(Progressive web apps, 渐进式Web应用)</p>
<ul>
<li>可以生成桌面小图标，不需要打开浏览器，方便用户访问</li>
<li>通过网络缓存提升页面访问速度，达到渐进式的页面甚至离线访问，提升用户体验</li>
<li>实现类似app的推送功能，生成系统通知推送给用户</li>
</ul>
<p>service worker是实现PWA的核心，service worker是一个独立的浏览器线程，不会对当前程序的执行线程造成阻塞，通过service worker可以实现页面离线访问、用户消息推送等功能。<br>使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p>
<p>Service Worker 实现缓存功能一般分为三个步骤：</p>
<ul>
<li>首先需要先注册 Service Worker</li>
<li>然后监听到 install 事件以后就可以缓存需要的文件</li>
<li>下次用户访问的时候就可以通过<strong>拦截请求的方式</strong>查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据</li>
</ul>
<p>PWA确实是当下很热门的技术，因为它提升了web应用的体验，甚至达到可以和原生app体验相提并论，但是它的问题就是兼容性问题，相信如果兼容性问题得到解决，这种技术一定会被大面积推广到实际应用。iOS11.3之前都不支持，因此vue cli3脚手架在集成时默认在ios下是关闭的</p>
<h1 id="移动端资源压缩"><a href="#移动端资源压缩" class="headerlink" title="移动端资源压缩"></a>移动端资源压缩</h1><p>我们常将网络性能优化措施归结为三大方面：减少请求数、减小请求资源体积、提升网络传输速率。</p>
<ol>
<li>JS 压缩</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">        minimizer: [</span><br><span class="line">            <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">                cache: <span class="literal">true</span>,</span><br><span class="line">                parallel: <span class="literal">true</span>,</span><br><span class="line">                sourceMap: <span class="literal">true</span> <span class="comment">// set to true if you want JS source maps</span></span><br><span class="line">            &#125;),</span><br><span class="line">            ...Plugins</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>HTML 压缩：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: __dirname + <span class="string">&#x27;/views/index.html&#x27;</span>, <span class="comment">// new 一个这个插件的实例，并传入相关的参数</span></span><br><span class="line">            filename: <span class="string">&#x27;../index.html&#x27;</span>,</span><br><span class="line">            minify: &#123;</span><br><span class="line">                removeComments: <span class="literal">true</span>,</span><br><span class="line">                collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">                removeRedundantAttributes: <span class="literal">true</span>,</span><br><span class="line">                useShortDoctype: <span class="literal">true</span>,</span><br><span class="line">                removeEmptyAttributes: <span class="literal">true</span>,</span><br><span class="line">                removeStyleLinkTypeAttributes: <span class="literal">true</span>,</span><br><span class="line">                keepClosingSlash: <span class="literal">true</span>,</span><br><span class="line">                minifyJS: <span class="literal">true</span>,</span><br><span class="line">                minifyCSS: <span class="literal">true</span>,</span><br><span class="line">                minifyURLs: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            chunksSortMode: <span class="string">&#x27;dependency&#x27;</span></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>提取公共资源：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123; <span class="comment">// 抽离第三方插件</span></span><br><span class="line">          test: <span class="regexp">/node_modules/</span>, <span class="comment">// 指定是 node_modules 下的第三方包</span></span><br><span class="line">          chunks: <span class="string">&#x27;initial&#x27;</span>,</span><br><span class="line">          name: <span class="string">&#x27;common/vendor&#x27;</span>, <span class="comment">// 打包后的文件名，任意命名    </span></span><br><span class="line">          priority: <span class="number">10</span> <span class="comment">// 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包</span></span><br><span class="line">        &#125;,</span><br><span class="line">        utils: &#123; <span class="comment">// 抽离自定义公共代码</span></span><br><span class="line">          test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          chunks: <span class="string">&#x27;initial&#x27;</span>,</span><br><span class="line">          name: <span class="string">&#x27;common/utils&#x27;</span>,</span><br><span class="line">          minSize: <span class="number">0</span> <span class="comment">// 只要超出 0 字节就生成一个新包</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>提取 css 并压缩：</li>
</ol>
<p>在使用 webpack 的过程中，我们通常会以模块的形式引入 css 文件（webpack 的思想不就是万物皆模块嘛），但是在上线的时候，我们还需要将这些 css 提取出来，并且压缩，这些看似复杂的过程只需要简单的几行配置就行：<br>（PS: 我们需要用到mini-css-extract-plugin ，所以还得大家自行 npm install）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [..., &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                _mode === <span class="string">&#x27;development&#x27;</span> ? <span class="string">&#x27;style-loader&#x27;</span> : MiniCssExtractPlugin.loader, &#123;</span><br><span class="line">                    loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        importLoaders: <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        ident: <span class="string">&#x27;postcss&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>将 webpack 开发环境修改为生产环境：</li>
</ol>
<p>在使用 webpack 打包项目时，它常常会引入一些调试代码，以作相关调试，我们在上线时不需要这部分内容，通过配置剔除：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool: <span class="string">&#x27;false&#x27;</span></span><br></pre></td></tr></table></figure>

<p>最后，我们还应该在服务器上开启 Gzip 传输压缩，它能将我们的文本类文件体积压缩至原先的四分之一，效果立竿见影，还是切换到我们的 nginx 配置文档，添加如下两项配置项目：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip on;</span><br><span class="line">gzip_types text/plain application/javascriptapplication/x-javascripttext/css application/xml text/javascriptapplication/x-httpd-php application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml;</span><br></pre></td></tr></table></figure>

<p><strong>特别注意！不要对图片文件进行 Gzip 压缩！</strong></p>
<ol start="6">
<li>使用雪碧图</li>
</ol>
<p>雪碧图的概念大家一定在生活中经常听见，其实雪碧图是减小请求数的显著运用。而且很奇妙的是，多张图片拼在一块后，总体积会比之前所有图片的体积之和小（你可以亲自试试）。这里给大家推荐一个自动化生成雪碧图的工具：<a target="_blank" rel="noopener" href="https://www.toptal.com/developers/css/sprite-generator">https://www.toptal.com/developers/css/sprite-generator</a></p>
<p>只要你添加相关资源文件，他就会自动帮你生成雪碧图以及对应的 CSS 样式。</p>
<p>优点：</p>
<ul>
<li>减少HTTP 请求数，极大地提高页面加载速度</li>
<li>增加图片信息的重复度，提高压缩比，减少图片大小</li>
</ul>
<p>缺点：</p>
<ul>
<li>图片合并麻烦，如果雪碧图无法加载则会导致整个页面出现显示问题，所以必须控制雪碧图大小不能太大</li>
<li>维护麻烦，修改一个图片可能需要重新布局整个图片、样式</li>
</ul>
<ol start="7">
<li>使用字体图标（iconfont）</li>
</ol>
<p>无论是压缩后的图片，还是雪碧图，终归还是图片，只要是图片，就还是会占用大量网络传输资源。但是字体图标的出现，却让前端开发者看到了另外一个神奇的世界。（iconfont本身是基于SVG的，只适用一些相对简单的业务场景）</p>
<p>我最喜欢用的是阿里矢量图标库（网址：<code>http://www.iconfont.cn/</code>），里面有大量的矢量图资源，而且你只需要像在淘宝采购一样把他们添加至购物车就能把它们带回家，整理完资源后还能自动生成CDN 链接，可以说是完美的一条龙服务了。（图片来自官网首页）</p>
<p>图片能做的很多事情，矢量图都能作，<strong>而且它只是往 HTML 里插入字符和 CSS 样式而已，和图片请求比起来资源占用完全不在一个数量级，</strong>如果你的项目里有小图标，就使用矢量图吧。</p>
<h1 id="1像素边框问题"><a href="#1像素边框问题" class="headerlink" title="1像素边框问题"></a>1像素边框问题</h1><p><strong>物理像素</strong></p>
<p>移动设备出厂时，不同设备自带的不同像素，也称硬件像素；</p>
<p><strong>逻辑像素</strong></p>
<p>即css中像素，和设备屏幕的像素没有必然的关系</p>
<p><strong>dpr(devicePixelRatio)设备像素比</strong></p>
<p>dpr = 物理像素 / 分辨率</p>
<p><strong>在不缩放的情况下，一个css像素就对应一个dpr</strong></p>
<p>css像素 = 物理像素 / dpr</p>
<p>为什么移动端CSS里面写了1px，实际上看起来比1px粗；了解设备物理像素和逻辑像素的同学应该很容易理解，其实这两个px的含义其实是不一样的，UI设计师要求的1px是指设备的物理像素1px，而CSS里记录的像素是逻辑像素，它们之间存在一个比例关系，可以用javascript中的window.devicePixelRatio来获取，也可以用媒体查询的-webkit-min-device-pixel-ratio来获取。</p>
<p>当然，比例多少与设备相关。</p>
<p>在手机上border无法达到我们想要的效果。这是因为devicePixelRatio特性导致，iPhone的devicePixelRatio==2，而border-width: 1px描述的是设备独立像素，所以，border被放大到物理像素2px显示，在iPhone上就显得较粗。</p>
<p>解决方法：</p>
<ol>
<li>使用 border-image</li>
</ol>
<p>缺点：需要再单独制作图片，并且圆角可能出现模糊</p>
<ol start="2">
<li> viewport + rem + js方案</li>
</ol>
<p>整体思路就是利用viewport + rem + js 动态的修改页面的缩放比例，实现小于1像素的显示。在页面初始化时，在头部引入原始默认状态如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">id</span>=<span class="string">&quot;WebViewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来的任务就是js的动态修改缩放比 以及 实现rem根元素字体大小的设置:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> viewport = <span class="built_in">document</span>.querySelector(<span class="string">&quot;meta[name=viewport]&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.devicePixelRatio == <span class="number">1</span>) &#123;</span><br><span class="line">    viewport.setAttribute(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&#x27;</span>)</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.devicePixelRatio == <span class="number">2</span>) &#123;</span><br><span class="line">    viewport.setAttribute(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&#x27;</span>)</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.devicePixelRatio == <span class="number">3</span>) &#123;</span><br><span class="line">    viewport.setAttribute(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;width=device-width, initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no&#x27;</span>)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> docEl = <span class="built_in">document</span>.documentElement;</span><br><span class="line"><span class="keyword">var</span> fontsize = <span class="number">10</span> * (docEl.clientWidth / <span class="number">320</span>) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">docEl.style.fontSize = fontsize;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>媒体查询 + 伪类 + transform（推荐）</li>
</ol>
<p>在以上的用法中，无非逃不开一种思想，就是将1px缩小为0.5px来展示，</p>
<p>然而,0.5px并不是所有的设备或浏览器都支持，就考虑用媒体查询或viewport将其缩放比例。其实1像素问题的产生基本发生在设置边框或分割线的时候，场景并不覆盖全局样式，因此，直接缩放需要设置的元素，才是我们真正需要的。</p>
<p>tranform就能实现这个需求。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 2倍屏 */</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">2.0</span>) &#123;</span><br><span class="line">    <span class="selector-class">.border-bottom</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">        -webkit-<span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3倍屏 */</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">3.0</span>) &#123;</span><br><span class="line">    <span class="selector-class">.border-bottom</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">        -webkit-<span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.33</span>);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.33</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>PS：使用rem布局时，个人习惯将字体设置为50px(浏览器默认是16px)，这样在换算成rem单位的时候，就可以直接乘以0.2就好了。（50px换算成10rem）；另外也可以将默认字体设置为62.5%，这样在换算单位的时候，就可以将1rem换算为10px。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5bcc169ae51d450e85308d86">首页白屏的引发的思考(一)</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247489586&idx=1&sn=2168d42df837521da50b3ed7f8932698&chksm=f951ad71ce262467728b7940de1a2311c523f264f4ca7e705712bf655a844fab93706cbe1ca3&token=1792152421&lang=zh_CN#rd">首屏时间从12.67s到1.06s，我是如何做到的？</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/21/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/ajax%E3%80%81axios%E3%80%81fetch%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/08/21/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/ajax%E3%80%81axios%E3%80%81fetch%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">ajax、axios、fetch的区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-21 11:43:20" itemprop="dateCreated datePublished" datetime="2019-08-21T11:43:20+08:00">2019-08-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Ajax/" itemprop="url" rel="index"><span itemprop="name">Ajax</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>背景</strong></p>
<p>前端的技术发展速度非常的快，异步请求也是其重要的体现之一，从最早的原生XHR，再到JqueryAjax的统治时代，再到近来，fetch、axios等技术也开始出现并大量投入使用。</p>
<h1 id="原生Ajax"><a href="#原生Ajax" class="headerlink" title="原生Ajax"></a>原生Ajax</h1><p>Ajax是指一种<strong>创建交互式网页应用</strong>的网页开发技术，并且可以做到无需重新加载整个网页的情况下，能够更新部分网页，也叫作局部更新。是最早出现的发送后端请求技术，隶属于原始js中，核心是使用XMLHttpRequest对象，多个请求之间如果有先后关系的话，就会出现回调地狱。</p>
<p><strong>使用步骤：</strong></p>
<ol>
<li>创建XmlHttpRequest对象</li>
<li>调用open方法设置基本请求信息</li>
<li>设置发送的数据，发送请求（send）</li>
<li>注册监听的回调函数（onreadystatechange）</li>
<li>拿到返回值，对页面进行更新</li>
</ol>
<p><strong>状态值：</strong></p>
<p>0    请求还未初始化，还未调用open()          —-未初始化<br>1    请求已建立但未发送，还未调用send()       —-载入<br>2    接受原始响应数据，为解析做准备            —-载入完成<br>3    正在解析数据                             —-解析<br>4    响应完成，数据解析完成                     —-解析完成</p>
<p><strong>优点：可以实现局部刷新，并且原生支持不需要使用任何插件</strong></p>
<p><strong>缺点：可能破坏浏览器后退功能，并且会出现回调地狱</strong></p>
<h1 id="Jquery-Ajax"><a href="#Jquery-Ajax" class="headerlink" title="Jquery Ajax"></a>Jquery Ajax</h1><p>jquery的ajax就是在原生的ajax的基础上进行了封装，并且添加上了对JSONP的支持。</p>
<p>优点：</p>
<ul>
<li>使用方便</li>
</ul>
<p>缺点：</p>
<ul>
<li>本身是针对mvc的编程模式，不太适合目前mvvm的编程模式</li>
<li>基于原⽣的 XHR 开发， XHR 本身的架构不清晰，已经有了 fetch 的替代⽅案 </li>
<li>jQuery本身比较大，如果单纯的使用ajax可以自己封装一个，不然会影响性能体验</li>
<li>回调地狱</li>
</ul>
<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>axios 是 vue 官方推荐使用的一个库，<strong>axios 一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生 XHR 的封装，只不过它是 Promise 的实现版本，</strong>不是原生js,使用时需要对其进行安装，符合最新的ES规范，它本身具有以下优点：</p>
<ul>
<li>支持 Promise API</li>
<li>客户端支持防止CSRF</li>
<li>自动转换JSON数据</li>
<li>从 node.js 创建 http 请求</li>
<li>拦截请求和响应</li>
<li>从浏览器中创建 XMLHttpReques</li>
</ul>
<p>PS:防止 CSRF :就是让你的每个请求都带一个从 cookie 中拿到的 key, 根据浏览器同源策略，假冒的网站是拿不到你 cookie 中得 key 的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。</p>
<h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><p>fetch 号称是 AJAX 的替代品，是在 ES6 出现的，使用了 ES6 中的 promise 对象。Fetch 是基于 promise 设计的。fetch 不是 ajax 的进一步封装，而是原生 js，没有使用 XMLHttpRequest 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(url).then(fun2)</span><br><span class="line">        .then(fun3)</span><br><span class="line">        .....</span><br><span class="line">        .catch(fun)</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>解决回调地狱</li>
<li>使用起来更加简洁</li>
</ul>
<p>缺点：</p>
<ul>
<li>API 偏底层，需要封装</li>
<li>默认不带 Cookie，需要手动添加</li>
<li>浏览器支持情况不是很友好，需要第三方的ployfill</li>
<li>fetch 没有办法原⽣监测请求的进度，⽽XHR可以</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ajax 是最早出现发送后端请求的技术，属于原生 js 范畴,核心是使用 XMLHttpRequest 对象,使用较多并有先后顺序的话，容易产生回调地狱。</p>
<p>fetch 号称可以代替 ajax 的技术，是基于 es6 中的 Promise 对象设计的，参数和 jQuery 中的 ajax 类似，它并不是对 ajax 进一步封装，它属于原生 js 范畴。没有使用 XMLHttpRequest 对象。</p>
<p>axios 不是原生 js,使用时需要对其进行安装，客户端和服务器端都可以使用，可以在请求和响应阶段进行拦截，基于 promise 对象。<br>axios 既提供了并发的封装，也没有 fetch 的各种问题，而且体积也较小，当之无愧现在最应该选用的请求的方式。这大概就是目前官方推荐使用 axios 的原因了吧。</p>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jennyya/article/details/83687622">ajax、fetch、axios区别</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8bc48f8fde75">ajax和axios、fetch的区别</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/23/css/HTML/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/23/css/HTML/" class="post-title-link" itemprop="url">HTML</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-23 15:19:35" itemprop="dateCreated datePublished" datetime="2019-07-23T15:19:35+08:00">2019-07-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h1><p>在我的理解为：根据内容，使用最合适的HTML标签。<br>场景：加入一个文章标题，要求这个标题的字体比正文的要大一些，还要加粗。能够实现这种效果的方法有很多，比如用CSS样式进行渲染。这样的效果看起来像是一个标题，但是他对浏览器来说，只是一个被渲染过的文本，无法知道他是一个标题。若要让浏览器知道他是一个标题，应该用hn标签来进行标记。<br>从这个例子可以总结出： 语义化的HTML文档，不关心内容的显示效果。 说的通俗一点： 标题脱了CSS这层外衣，它还是一个标题。</p>
<h2 id="语义化标签的优势"><a href="#语义化标签的优势" class="headerlink" title="语义化标签的优势"></a>语义化标签的优势</h2><ul>
<li>代码结构清晰，方便阅读，有利于团队合作开发。</li>
<li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。</li>
<li>有利于搜索引擎优化（SEO）。</li>
</ul>
<h2 id="HTML5新增的语义化标签"><a href="#HTML5新增的语义化标签" class="headerlink" title="HTML5新增的语义化标签"></a>HTML5新增的语义化标签</h2><ul>
<li>header：页眉通常包括网站标志、主导航、全站链接以及搜索框</li>
<li>nav：标记导航，仅对文档中重要的链接群使用</li>
<li>main：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能</li>
<li>article：定义外部的内容，其中的内容独立于文档的其余部分</li>
<li>section：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分</li>
<li>footer：页脚，只有当父级是body时，才是整个页面的页脚</li>
</ul>
<h1 id="meta标签的理解和总结"><a href="#meta标签的理解和总结" class="headerlink" title="meta标签的理解和总结"></a>meta标签的理解和总结</h1><p>meta常用于定义页面的说明，关键字，最后修改日期，和其它的元数据。它不会显示在页面上，但是机器却可以识别。<br>这些元数据将服务于浏览器（如何布局或重载页面），搜索引擎和其它网络服务。</p>
<p><strong>组成：meta标签一共有两个属性，分别是http-equiv属性和name属性</strong></p>
<h2 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h2><p>name属性主要用于描述网页，比如网页的关键词，叙述等。与之对应的属性值为content，content中的内容是对name填入类型的具体描述，便于搜索引擎抓取。<br>meta标签中name属性语法格式是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;参数&quot;</span> <span class="attr">content</span>=<span class="string">&quot;具体的描述&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A. keywords(关键字)</strong><br>说明：用于告诉搜索引擎，你网页的关键字。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Lxxyx,博客，文科生，前端&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>B. description(网站内容的描述)</strong><br>说明：用于告诉搜索引擎，你网站的主要内容。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;文科生，热爱前端与编程。目前大二，这是我的前端博客&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（SEO优先级按照title、description、keywords的顺序递减）</p>
<ul>
<li><strong>C. viewport(移动端的窗口)</strong><br>说明：这个概念较为复杂，具体的会在下篇博文中讲述。<br>这个属性常用于设计移动端网页。在用bootstrap,AmazeUI等框架时候都有用过viewport。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>C. viewport(移动端的窗口)</strong><br>说明：robots用来告诉爬虫哪些页面需要索引，哪些页面不需要索引。<br>content的参数有all,none,index,noindex,follow,nofollow。默认是all。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;none&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>E. author(作者)</strong><br>说明：用于标注网页作者</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;leslie,leslie_choi@yeah.net&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>G. copyright(版权)</strong><br>说明：用于标注版权信息</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;copyright&quot;</span> <span class="attr">content</span>=<span class="string">&quot;leslie&quot;</span>&gt;</span> //代表该网站为leslie个人版权所有。</span><br></pre></td></tr></table></figure>

<h2 id="http-equiv属性"><a href="#http-equiv属性" class="headerlink" title="http-equiv属性"></a>http-equiv属性</h2><p>equiv的全称是”equivalent”，意思是相等，相当于。<br>所以在这里的作用就是相当于HTTP的作用，类似于定义http参数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;参数&quot;</span> <span class="attr">content</span>=<span class="string">&quot;具体的描述&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>A. content-Type(设定网页字符集)(推荐使用HTML5的方式)</strong></li>
</ul>
<p>说明：用于设定网页字符集，便于浏览器解析与渲染页面</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=utf-8&quot;</span>&gt;</span>  //旧的HTML，不推荐</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> //HTML5设定网页字符集的方式，推荐使用UTF-8</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>B. X-UA-Compatible(浏览器采取何种版本渲染当前页面)</strong></li>
</ul>
<p>说明：用于告知浏览器以何种版本来渲染页面。（一般都设置为最新模式，在各大框架中这个设置也很常见。）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span>/&gt;</span> //指定IE和Chrome使用最新版本渲染当前页面</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>C.cache-control(指定请求和响应遵循的缓存机制)</strong></li>
</ul>
<p><strong>用法一：指导浏览器如何缓存某个响应以及缓存多长时间。</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;cache-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>共有以下几种用法：</p>
<p>1、no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。</p>
<p>2、no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）</p>
<p>3、public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果</p>
<p>4、private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）</p>
<p>5、maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。</p>
<p><strong>用法二：禁止百度自动转码。</strong></p>
<p>用于禁止当前页面在移动端浏览时，被百度自动转码。虽然百度的本意是好的，但是转码效果很多时候却不尽人意。所以可以在head中加入例子中的那句话，就可以避免百度自动转码了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Cache-Control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-siteapp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>D. expires(网页到期时间)</strong></li>
</ul>
<p>用于设定网页的到期时间，过期后网页必须到服务器上重新传输。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;expires&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Sunday 26 October 2016 01:00 GMT&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>refresh(自动刷新并指向某页面)</strong></li>
</ul>
<p>网页将在设定的时间内，自动刷新并调向设定的网址。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;2；URL=http://www.baidu.com&quot;</span>&gt;</span> //意思是2秒后跳转</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Set-Cookie(cookie设定)</strong> </li>
</ul>
<p>如果网页过期。那么这个网页存在本地的cookies也会被自动删除。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Set-Cookie&quot;</span> <span class="attr">content</span>=<span class="string">&quot;name, date&quot;</span>&gt;</span> //格式</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Set-Cookie&quot;</span> <span class="attr">content</span>=<span class="string">&quot;User=Lxxyx; path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT&quot;</span>&gt;</span> //具体范例</span><br></pre></td></tr></table></figure>

<h2 id="设置页面不缓存的方法"><a href="#设置页面不缓存的方法" class="headerlink" title="设置页面不缓存的方法"></a>设置页面不缓存的方法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;pragma&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Cache-Control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache, must-revalidate&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;expires&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="H5和CSS3的新特性"><a href="#H5和CSS3的新特性" class="headerlink" title="H5和CSS3的新特性"></a>H5和CSS3的新特性</h1><h2 id="html5有哪些新特性"><a href="#html5有哪些新特性" class="headerlink" title="html5有哪些新特性"></a>html5有哪些新特性</h2><ol>
<li>拖拽释放(Drag and drop) API </li>
<li>语义化更好的内容标签（header,nav,footer,aside,article,section）</li>
<li>音频、视频API(audio,video)</li>
<li>画布(Canvas) API</li>
<li>地理(Geolocation) API</li>
<li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；sessionStorage 的数据在浏览器关闭后自动删除。</li>
<li>sessionStorage 的数据在浏览器关闭后自动删除</li>
<li>表单控件，calendar、date、time、email、url、search  </li>
<li>新的技术webworker, websocket, Geolocation</li>
</ol>
<h3 id="html5-的离线存储以及工作原理"><a href="#html5-的离线存储以及工作原理" class="headerlink" title="html5 的离线存储以及工作原理"></a>html5 的离线存储以及工作原理</h3><p>在⽤户没有与因特⽹连接时，可以正常访问站点或应⽤，在⽤户与因特⽹连接时，更新⽤ 户机器上的缓存⽂件</p>
<p>原理：HTML5 的离线存储是基于⼀个新建的 .appcache ⽂件的缓存机制(不是存储技 术)，通过这个⽂件上的解析清单离线存储资源，这些资源就会像 cookie ⼀样被存储了下 来。之后当⽹络在处于离线状态下时，浏览器会通过被离线存储的数据进⾏⻚⾯展示</p>
<p>使用方法：</p>
<ol>
<li>⻚⾯头部像下⾯⼀样加⼊⼀个 manifest 的属性</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">&quot;demo.appcache&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在 cache.manifest ⽂件的编写离线存储的资源 </p>
</li>
<li><p>在离线状态时，操作 window.applicationCache 进⾏需求实现</p>
</li>
</ol>
<p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest ⽂件，如 果是第⼀次访问 app ，那么浏览器就会根据manifest⽂件的内容下载相应的资源并且进⾏ 离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使⽤离线的资 源加载⻚⾯，然后浏览器会对⽐新的 manifest ⽂件与旧的 manifest ⽂件，如果⽂件没有发⽣改变，就不做任何操作，如果⽂件改变了，那么就会重新下载⽂件中的资源并进⾏离线存储。</p>
<p>离线的情况下，浏览器就直接使⽤离线存储的资源。</p>
<h2 id="CSS3-新增属性"><a href="#CSS3-新增属性" class="headerlink" title="CSS3 新增属性"></a>CSS3 新增属性</h2><ol>
<li>颜色：新增RGBA，HSLA模式</li>
<li>文字阴影（text-shadow、）</li>
<li>边框： 圆角（border-radius）边框阴影： box-shadow</li>
<li>盒子模型：box-sizing</li>
<li>背景：background-size 设置背景图片的尺寸background-origin 设置背景图片的原点。background-clip 设置背景图片的裁切区域，以”，”分隔可以设置多背景，用于自适应布局</li>
<li>渐变：linear-gradient、radial-gradient</li>
<li>过渡：transition，可实现动画</li>
<li>自定义动画</li>
<li>在CSS3中唯一引入的伪元素是 ：：selection.</li>
<li>媒体查询，多栏布局</li>
<li>border-image</li>
<li>2D转换：transform：translate(x，y) rotate(x，y) skew(x，y) scale(x，y)</li>
</ol>
<h2 id="H5中已经废弃的标签"><a href="#H5中已经废弃的标签" class="headerlink" title="H5中已经废弃的标签"></a>H5中已经废弃的标签</h2><ul>
<li>br 换行，已经被 p 标签进行替换</li>
<li>hr 画线</li>
<li>font、big、center</li>
<li>在企业开发中，不到万不得已 不要轻易使用被废弃的标签</li>
<li>strong ：定义重要性强调的文字</li>
<li>ins 定义插入的文字</li>
<li>em 定义强调的文字</li>
<li>del定义被删除的文字</li>
<li>frame 等等</li>
</ul>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/entry/588074c62f301e00696b481d">关于 HTML 中 meta 标签的理解和总结</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/13/JavaScript/%E6%8F%90%E9%AB%98%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/13/JavaScript/%E6%8F%90%E9%AB%98%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">提高页面性能</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-13 22:12:24" itemprop="dateCreated datePublished" datetime="2019-07-13T22:12:24+08:00">2019-07-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们常将网络性能优化措施归结为三大方面：减少请求数、减小请求资源体积、提升网络传输速率。</p>
<ul>
<li><p>content ⽅⾯   </p>
<ul>
<li>减少 HTTP 请求：合并⽂件、 CSS 精灵、 inline Image </li>
<li>减少 DNS 查询： DNS 缓存、将资源分布到恰当数量的主机名 </li>
<li>减少 DOM 元素数量</li>
</ul>
</li>
<li><p>Server ⽅⾯</p>
<ul>
<li>使⽤ CDN 配置 ETag 对组件使⽤ Gzip 压缩</li>
</ul>
</li>
<li><p>Cookie ⽅⾯</p>
<ul>
<li>减⼩ cookie ⼤⼩</li>
</ul>
</li>
<li><p>css ⽅⾯</p>
<ul>
<li>将样式表放到⻚⾯顶部 不使⽤ CSS 表达式 使⽤ <code>&lt;link&gt;</code> 不使⽤ @import</li>
</ul>
</li>
<li><p>Javascript ⽅⾯</p>
<ul>
<li>将脚本放到⻚⾯底部 </li>
<li>将 javascript 和 css 从外部引⼊ 压缩 javascript 和 css </li>
<li>删除不需要的脚本</li>
<li>减少 DOM 访问</li>
</ul>
</li>
<li><p>图⽚⽅⾯</p>
<ul>
<li>优化图⽚：根据实际颜⾊需要选择⾊深、压缩 </li>
<li>优化 css 精灵 </li>
<li>不要在 HTML 中拉伸图⽚</li>
</ul>
</li>
</ul>
<h1 id="资源压缩合并，减少HTTP请求"><a href="#资源压缩合并，减少HTTP请求" class="headerlink" title="资源压缩合并，减少HTTP请求"></a>资源压缩合并，减少HTTP请求</h1><p>比如可以使用webpack将多个文件压缩成一个文件，并且对代码进行压缩。使用雪碧图、base64格式的图片等等。而在vue cli3中可以开启gzip压缩，gizp压缩是一种http请求优化方式，通过减少文件体积来提高加载速度。html、js、css文件甚至json数据都可以用它压缩，可以减小60%以上的体积。</p>
<p>使用步骤：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先安装插件</span></span><br><span class="line">npm i -D compression-webpack-plugin</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后再在vue.config.js中进行配置</span></span><br><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">&quot;compression-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        plugins: [<span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">          test: <span class="regexp">/\.js$|\.html$|\.css/</span>,  <span class="comment">//匹配文件名</span></span><br><span class="line">          threshold: <span class="number">10240</span>,             <span class="comment">//对10k以上文件进行压缩</span></span><br><span class="line">          deleteOriginalAssets: <span class="literal">false</span>   <span class="comment">//是否删除源文件</span></span><br><span class="line">        &#125;)]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般浏览器都已支持.gz的资源文件，在http请求的Request Headers 中能看到 Accept-Encoding:gzip。</p>
<p>要使服务器返回.gz文件，还需要对服务器进行配置，根据Request Headers的Accept-Encoding标签进行鉴别，如果支持gzip就返回.gz文件。</p>
<h1 id="非核心代码异步加载"><a href="#非核心代码异步加载" class="headerlink" title="非核心代码异步加载"></a>非核心代码异步加载</h1><p>通常对于大型应用来说，完整加载所有javascript代码是十分耗时的工作。在页面渲染的这样一个过程中，有一个关键点是如果在解析内容的过程中遇到了脚本标签，如：<script src="example.js"></script>，浏览器就会暂停内容的解析，转而开始下载脚本。并且只有等脚本下载完并执行结束后，渲染引擎才会继续解析。那么这样一来，页面显示的时间必然会被延长。因此我们需要优化的点就是尽可能地让页面更早地被渲染出来。要解决上面说到的脚本加载问题，通常有三种解决方案：将脚本放在HTML末尾、动态加载脚本以及异步加载脚本。</p>
<ol>
<li>异步加载的方式</li>
</ol>
<ul>
<li>动态脚本加载</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.src = <span class="string">&quot;js/test.js&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(script);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>异步加载的方式</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defer &lt;script src=<span class="string">&quot;defer.js&quot;</span> defer&gt; &lt;/script&gt;   </span><br><span class="line"><span class="keyword">async</span> &lt;script src=<span class="string">&quot;defer.js&quot;</span> <span class="keyword">async</span>&gt; &lt;/script&gt;</span><br><span class="line"><span class="comment">//第三种方法，动态创建 script ，插⼊到 DOM 中，加载完毕后 callBack</span></span><br></pre></td></tr></table></figure>

<ul>
<li>defer是在HTML渲染完之后（DOM结构完全生成，以及其他脚本执行完成之后）才会执行，如果是多个，则按照加载的顺序执行，优先级比async高</li>
<li>async是在下载完脚本之后立即执行，渲染引擎会中断，执行完脚本之后才会继续渲染，如果是多个，执行顺序和加载顺序无关</li>
<li>直接使用src方式引入JS会阻塞页面的渲染</li>
</ul>
<h2 id="解决异步加载脚本的问题"><a href="#解决异步加载脚本的问题" class="headerlink" title="解决异步加载脚本的问题"></a>解决异步加载脚本的问题</h2><p>如何处理加载过程中这些脚本的互相依赖关系，就成了实现异步加载过程中所需要考虑的问题。一方面，对于页面中那些独立的脚本，如用户统计等插件就可以放心大胆地使用异步加载。而另一方面，对于那些确实需要处理依赖关系的脚本，业界已经有很成熟的解决方案了。如采用AMD规范的RequireJS,CMD规范的seaJS，或者使用ES6中的模块化开发。另一方面，也可以使用promise技术来实现处理异步脚本加载过程中的依赖问题：</p>
<p>针对每个脚本依赖都会创建一个promise对象来管理其状态。采用动态插入脚本的方式来管理脚本，然后利用脚本onload和onreadystatechange(兼容性处理)事件来监听脚本是否加载完成。一旦加载完毕，就会触发promise的resovle方法。最后，针对依赖的处理，是promise的all方法，这个方法只有在所有promise对象都resolved的时候才会触发resolve方法，这样一来，我们就可以确保在执行回调之前，所有依赖的脚本都已经加载并执行完毕。</p>
<h1 id="利用浏览器缓存（最重要的一步）-gt-缓存的分类-gt-缓存的原理"><a href="#利用浏览器缓存（最重要的一步）-gt-缓存的分类-gt-缓存的原理" class="headerlink" title="利用浏览器缓存（最重要的一步） -&gt; 缓存的分类 -&gt; 缓存的原理"></a>利用浏览器缓存（最重要的一步） -&gt; 缓存的分类 -&gt; 缓存的原理</h1><ol>
<li>缓存的分类</li>
</ol>
<ul>
<li>强缓存发现本地有请求文件的副本，直接使用，也就是说如果我们在服务端更新了文件，并不会被浏览器所得知，就无法替换失效的缓存</li>
<li>协商缓存则需要和服务器进行交流，通过确认之后才可以使用</li>
</ul>
<p><strong>a 强缓存：不会向服务器发送请求，直接从缓存中读取资源，返回状态码200</strong></p>
<ul>
<li><p>Expires Wed, 22 Oct 2018 08:41:00 GMT</p>
</li>
<li><p><em>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点，如果过期则会再次请求</em>*</p>
</li>
<li><p>Cache—Control:max-age=300</p>
</li>
<li><p><em>代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</em>*</p>
</li>
</ul>
<p>但是如果服务器同时下发了两个，则以相对时间为准。</p>
<p><strong>b 协商缓存：会去服务器比对，若没改变才直接读取本地缓存，返回的状态码是 304</strong><br>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p>
<p><strong>Last-Modified 和 If-Modified-Since</strong></p>
<p>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；<br>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，<strong>值就是Last-Modified中的值</strong> ；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。 </p>
<p>存在的弊端：</p>
<ul>
<li><p>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源</p>
</li>
<li><p>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</p>
</li>
<li><p>某些服务器不能精确的得到文件的最后修改时间。</p>
</li>
</ul>
<p><strong>Etag 和 If-None-Match</strong><br>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成，类似一个哈希值)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。<br>如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p>
<p><strong>PS：强缓存的优先级会比协商缓存优先级高，cache-control优先级 &gt; expire，Etag优先级 &gt; Last-modified</strong></p>
<p><strong>那有了Etag是不是可以放弃last-Modified了呢？</strong></p>
<ul>
<li><p>对那些一秒内修改特别频繁的文件，使用etag强验证的话，就需要占用服务器cpu资源频繁进行etag的计算，这样可能就不好用了。</p>
</li>
<li><p>只是给代码加上注释，但是服务器实质的内容并没有一点改变，如果使用Etag扫描全部文件可能会耗费大量性能，而使用last-modified只要返回最后修改时间即可，所以应该根据场景选择对应方案。</p>
</li>
</ul>
<h1 id="利用cdn"><a href="#利用cdn" class="headerlink" title="利用cdn"></a>利用cdn</h1><p>CDN(Content Delivery Network)又称为内容分发网络，使内容传输的更快，更稳定。<br>也就是说，<strong>把静态资源文件和动态网页分集群部署</strong>，静态资源会被部署到CDN节点上，网页中引用的资源也会变成对应的部署路径。<br>CDN 的核心点有两个: 一个是缓存，一个是回源。</p>
<ul>
<li>缓存<br>将从根服务器请求来的资源按要求缓存。</li>
<li>回源<br>当有用户访问某个资源的时候，如果被解析到的那个 CDN 节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。没有人访问，CDN 节点不会主动去源站请求资源。</li>
</ul>
<p>原理：不同地区的用户会访问到离自己最近的相同网络线路上的CDN节点，当请求达到CDN节点后，节点会判断自己的内容缓存是否有效，如果有效，则立即响应缓存内容给用户，从而加快响应速度。如果CDN节点的缓存失效，它会根据服务配置去我们的内容源服务器获取最新的资源响应给用户，并将内容缓存下来以便响应给后续访问的用户。因此，一个地区内只要有一个用户先加载资源，在CDN中建立了缓存，该地区的其他后续用户都能因此而受益。</p>
<p>不同地区的用户访问同一个域名却能得到不同CDN节点的IP地址，这要依赖于<strong>CDN服务商提供的智能域名解析服务</strong>，浏览器发起域名查询时，这种智能DNS服务会根据用户IP计算并返回离它最近的同网络CDN节点IP，引导浏览器与此节点建立连接以获取资源。</p>
<p>优点：</p>
<ul>
<li>CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低</li>
<li>大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源站的负载</li>
<li>提高网络访问的稳定性</li>
</ul>
<h1 id="预解析DNS"><a href="#预解析DNS" class="headerlink" title="预解析DNS"></a>预解析DNS</h1><p>还有一个可以优化网页速度的方式是利用dns的预解析技术。同preload类似，DNS Prefetch在网络层面上优化了资源加载的速度。<br>我们知道，针对DNS的前端优化，主要分为减少DNS的请求次数，还有就是进行DNS预先获取。DNS prefetch就是为了实现这后者。其用法也很简单，只要在link标签上加上对应的属性就行了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;x-dns-prefetch-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;on&quot;</span> /&gt;</span> /* 这是用来告知浏览器当前页面要做DNS预解析，可以选择on或者off */</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//example.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>复制代码在支持该标准的浏览器上，会自动对链接中的地址域名做DNS解析缓存。不过，像Goolge、火狐这样的现代浏览器即使不设置这个属性，也能在后台做自动预解析。如果你的页面中需要大量访问不同域名的资源，可以利用这项技术加快资源的获取，从而获得更好的用户体验。需要注意的是，DNS预解析虽好，但是也不能滥用。如果对多页面重复DNS预解析，会增加DNS的查询次数。</p>
<h1 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h1><ul>
<li><p>在开发中，可能会遇到这样的情况。有些资源不需要⻢上⽤到，但是希望尽早获取，这时候就可以使⽤预加载 </p>
</li>
<li><p>预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件， 可以使⽤以下代码开启预加载</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>预加载可以⼀定程度上降低⾸屏的加载时间，因为可以将⼀些不影响⾸屏但重要的⽂件延后加载，唯⼀缺点就是兼容性不好</p>
<h2 id="图片预加载"><a href="#图片预加载" class="headerlink" title="图片预加载"></a>图片预加载</h2><ol>
<li>使用 display:none</li>
</ol>
<p>给图片加上这个属性之后，图片不会再页面中显示，但是网络请求已经将图片加载到缓存里面了，等到需要使用的时候，再使用回调函数从缓存里面获取。</p>
<ol start="2">
<li>new Image</li>
</ol>
<p>使用new Image的方式新建一个image 对象，然后再为这个对象绑定一个src，当对应的js代码被执行之后，图片也会被下载下来，等到需要使用的时候，再使用回调函数从缓存里面获取。</p>
<ol start="3">
<li>使用XMLRequest 对象进行图片的预加载</li>
</ol>
<p>优点：能够更好地对预加载过程进行控制</p>
<p>缺点：存在跨域问题</p>
<ol start="4">
<li>使用preloader 库</li>
</ol>
<h1 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h1><p>可以通过预渲染将下载的⽂件预先在后台渲染，可以使⽤以下代码开启预渲染</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prerender&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://poetries.com&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>预渲染虽然可以提⾼⻚⾯的加载速度，但是要确保该⻚⾯百分百会被⽤户在之后打开，否则就⽩⽩浪费资源去渲染</p>
<h1 id="懒执⾏与懒加载"><a href="#懒执⾏与懒加载" class="headerlink" title="懒执⾏与懒加载"></a>懒执⾏与懒加载</h1><h2 id="懒执⾏"><a href="#懒执⾏" class="headerlink" title="懒执⾏"></a>懒执⾏</h2><p>懒执⾏就是将某些逻辑延迟到使⽤时再计算。该技术可以⽤于⾸屏优化，对于某些耗时逻辑并不需要在⾸屏就使⽤的，就可以使⽤懒执⾏。懒执⾏需要唤醒，⼀般可以通过定时器或者事件的调⽤来唤醒</p>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><ul>
<li>懒加载就是将不关键的资源延后加载</li>
</ul>
<p>如果img资源和相关的静态资源放在同一个cdn节点，但是img标签一般都是在script 之上的，而浏览器对同一个地址会有并发的限制，这样会导致js文件执行延迟。</p>
<p>懒加载的原理就是只加载⾃定义区域（通常监听scroll事件，判断当前是否是可视区域，但也可以是即将进⼊ 可视区域）内需要加载的东⻄。对于图⽚来说，先设置图⽚标签的 src 属性 为⼀张占位图，将真实的图⽚资源放⼊⼀个⾃定义属性中，当进⼊⾃定义区域 时，就将⾃定义属性替换为 src 属性，这样图⽚就会去下载资源，实现了图⽚懒加载。</p>
<p>PS：实现原理，主要通过判断图片顶部距离屏幕顶部的距离（offsetTop）是否小于屏幕的高度（document.documentElement.clientHeight），如果是的话，则说明已经进入了可视区域。</p>
<ul>
<li>懒加载不仅可以⽤于图⽚，也可以使⽤在别的资源上。⽐如进⼊可视区域才开始播放视频等</li>
</ul>
<h1 id="使用SSR（server-side-render）服务端渲染，数据直接输出到HTML中"><a href="#使用SSR（server-side-render）服务端渲染，数据直接输出到HTML中" class="headerlink" title="使用SSR（server side render）服务端渲染，数据直接输出到HTML中"></a>使用SSR（server side render）服务端渲染，数据直接输出到HTML中</h1><p>ssr是Server-Side Rendering的简写，即由服务端负责渲染页面直出，亦即同构应用。程序的大部分代码都可以在服务端和客户端运行。在服务端vue组件渲染为html字符串，然后直接返回给客户端，在客户端生成dom和操作dom。</p>
<p>能在服务端渲染为html字符串得益于vue组件结构是基于vnode的。vnode是dom的抽象表达，它不是真实的dom，它是由js对象组成的树，每个节点代表了一个dom。因为vnode，所以在服务端vue可以把js对象解析为html字符串。同样在客户端vnode因为是存在内存之中的，操作内存总比操作dom快的多，每次数据变化需要更新dom时，新旧vnode树经过diff算法，计算出最小变化集，大大提高了性能。</p>
<p><strong>服务端渲染 SSR 的优缺点如下：</strong></p>
<p>(1) 服务端渲染的优点：</p>
<ul>
<li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面</li>
<li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间</li>
</ul>
<p>(2) 服务端渲染的缺点：</p>
<ul>
<li><p>更多的开发条件限制： <strong>例如服务端渲染只支持 beforCreate 和 created 两个钩子函数</strong>（因为服务端不是浏览器环境，window、document等都是浏览器才有的对象，或者使用JS-dom的包，可以模拟浏览器环境），这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境。</p>
</li>
<li><p>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p>
</li>
</ul>
<h1 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h1><ul>
<li>css放在head里面，JS放在body的底部</li>
<li>懒加载（图片懒加载、下拉加载更多）</li>
<li>减少对DOM查询，对DOM查询做缓存</li>
<li>减少DOM操作，多个操作尽量合并在一起执行</li>
</ul>
<h1 id="事件节流和防抖"><a href="#事件节流和防抖" class="headerlink" title="事件节流和防抖"></a>事件节流和防抖</h1><p>防抖:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 按钮提交场景：防止多次提交按钮，只执行最后提交的一次</span></span><br><span class="line"><span class="comment">// 服务端验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似</span></span><br><span class="line">    <span class="keyword">const</span> debounce = <span class="function">(<span class="params">fn,delay</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.call(<span class="built_in">this</span>.arguments)</span><br><span class="line">            &#125;,delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>节流：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动</span></span><br><span class="line"><span class="comment">// 缩放场景：监控浏览器resize</span></span><br><span class="line"><span class="comment">// 动画场景：避免短时间内多次触发动画引起性能问题</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn,delay</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tag = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tag)&#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            tag = <span class="literal">false</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                fn.call(<span class="built_in">this</span>.arguments)</span><br><span class="line">                tag = <span class="literal">true</span></span><br><span class="line">            &#125;,delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间戳实现节流函数</span></span><br><span class="line">    <span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn,delay</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">let</span> startTime = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> currentTime = <span class="built_in">Date</span>.now</span><br><span class="line">            <span class="keyword">let</span> remaining = delay - (currentTime -startTime)</span><br><span class="line">            <span class="function"><span class="title">clearTimeout</span>(<span class="params">timer</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(renmaining &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">                    startTime = <span class="built_in">Date</span>.now()</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    timer = <span class="built_in">setTimeout</span>(fn,remaining)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="使用DOMContentLoaded，尽早执行操作"><a href="#使用DOMContentLoaded，尽早执行操作" class="headerlink" title="使用DOMContentLoaded，尽早执行操作"></a>使用DOMContentLoaded，尽早执行操作</h1><p>相比window.oonload，需要页面的全部资源加载完成才会执行，包括了图片还有视频等等<br>而DOMContentLoaded，只要DOM渲染完成即可执行，此时的图片和视频可能还没有加载完</p>
<h1 id="减少对DOM的操作"><a href="#减少对DOM的操作" class="headerlink" title="减少对DOM的操作"></a>减少对DOM的操作</h1><ul>
<li>缓存DOM查询</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未缓存 DOM 查询</span></span><br><span class="line">    <span class="keyword">var</span> i</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>).length;i++)&#123;</span><br><span class="line">        <span class="comment">//todo</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//缓存 DOM 查询   使用一个变量接收查询到的DOM</span></span><br><span class="line">    <span class="keyword">var</span> pList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> i</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; pList.length;i++)&#123;</span><br><span class="line">        <span class="comment">//todo</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>合并DOM的操作</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">element.style.borderColor = <span class="string">&#x27;#f00&#x27;</span>;</span><br><span class="line">element.style.borderStyle = <span class="string">&#x27;solid&#x27;</span>;</span><br><span class="line">element.style.borderWidth = <span class="string">&#x27;1px&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line">element.style.cssText += <span class="string">&#x27;border: 1px solid #f00;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>减少对DOM的操作，是为了减少重排和重绘。</p>
<p>重排会占用CPU，dom元素位置计算会消耗CPU的算力，所以应该尽量减少CPU的占用，使电脑不卡顿。<br>重绘会占用GPU，渲染页面时会消耗GPU的算力。</p>
<p>GPU的分类：</p>
<ul>
<li><p>家用GPU<br>适合做贴图、特效、光影等效果。不适合画图形。</p>
</li>
<li><p>专业GPU<br>适合画图形。不适合做贴图、特效、光影等效果。</p>
</li>
</ul>
<p>DOM操作基本就是画图形的，但浏览器中用的就是家用GPU，其画图形耗费的性能是专业GPU的几十倍。所以不提倡频繁用装有家用GPU的浏览器绘制页面。也就是不提倡频繁触发重绘。</p>
<h1 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h1><p>开发SPA项目的时候，项目中可能会存在很多的路由页面。如果我们将这些页面全部打包进一个JS文件的话，虽然说将多个请求合并了，但是同样加载了很多不需要的代码，会耗费更长的时间，所以首页能加载的文件体积需要越小越好，所以这个时候可以使用按需加载。</p>
<h2 id="按需加载组件"><a href="#按需加载组件" class="headerlink" title="按需加载组件"></a>按需加载组件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> tab <span class="keyword">from</span> <span class="string">&#x27;./tab0&#x27;</span></span><br><span class="line"><span class="keyword">const</span> tab0 = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;./tab0&#x27;</span>],resolve)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">	components:&#123;</span><br><span class="line">		Tab0</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="按需加载路由"><a href="#按需加载路由" class="headerlink" title="按需加载路由"></a>按需加载路由</h2><ol>
<li>vue异步加载组件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">  path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">  name: <span class="string">&#x27;Home&#x27;</span>, </span><br><span class="line">  component: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/components/home&#x27;</span>],resolve) </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>webpack 的 require.ensure() </li>
</ol>
<ul>
<li>   dependencies: 依赖的模块数组</li>
<li>   callback: 回调函数，该函数调用时会传一个require参数</li>
<li>   chunkName: 模块名，用于构建时生成文件时命名使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">    path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    component: <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([], <span class="function">() =&gt;</span> r(<span class="built_in">require</span>(<span class="string">&#x27;@/components/home&#x27;</span>)), <span class="string">&#x27;chunk&#x27;</span>) </span><br><span class="line">    <span class="comment">// r就是resolve</span></span><br><span class="line">    <span class="comment">// &#x27;chunk&#x27; 表示包名，相同的 chunk 名 会被打包到一起</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用动态的import()语法（推荐使用这种）</li>
</ol>
<p>vue中使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//没有指定webpackChunkName,每个组件打包成一个js文件</span></span><br><span class="line"><span class="keyword">const</span> test1 = <span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;@/components/test1.vue&#x27;</span>) </span><br><span class="line"><span class="keyword">const</span> test2 = <span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;@/components/test2.vue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定了相同的webpackChunkName，会合并打包成y一个js文件</span></span><br><span class="line"><span class="keyword">const</span> test3 = <span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&#x27;grounpTest&#x27; */</span> <span class="string">&#x27;@/components/test3.vue&#x27;</span>) </span><br><span class="line"><span class="keyword">const</span> test4 = <span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&#x27;grounpTest&#x27; */</span> <span class="string">&#x27;@/components/test4.vue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/test1&#x27;</span>, <span class="attr">component</span>: test1 &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/test2&#x27;</span>, <span class="attr">component</span>: test2 &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/test3&#x27;</span>, <span class="attr">component</span>: test3 &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/test4&#x27;</span>, <span class="attr">component</span>: test4 &#125;</span><br><span class="line">    ]</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<p>注：/* webpackChunkName: ‘grounpTest’ */使用命名chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack &gt; 2.4)</p>
<h1 id="前端SEO优化"><a href="#前端SEO优化" class="headerlink" title="前端SEO优化"></a>前端SEO优化</h1><ul>
<li>合理的 title 、 description 、 keywords ：搜索对着三项的权重逐个减⼩， title 值强调重点即可，重要关键词出现不要超过2次，⽽且要靠前，不同⻚⾯ title 要有所不 同； description 把⻚⾯内容⾼度概括，⻓度合适，不可过分堆砌关键词，不同⻚⾯ description 有所不同； keywords 列举出重要关键词即可 </li>
<li>语义化的 HTML 代码，符合W3C规范：语义化代码让搜索引擎容易理解⽹⻚<br>重要内容 HTML 代码放在Y前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓 取⻓度有限制，保证重要内容⼀定会被抓取 </li>
<li>重要内容不要⽤ js 输出：爬⾍不会执⾏js获取内容 </li>
<li>少⽤ iframe ：搜索引擎不会抓取 iframe 中的内容 </li>
<li>⾮装饰性图⽚必须加 alt 提⾼⽹站速度</li>
<li>⽹站速度是搜索引擎排序的⼀个重要指标</li>
</ul>
<h1 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h1><ol>
<li>不⽤图⽚。很多时候会使⽤到很多修饰类图⽚，其实这类修饰图⽚完全可以⽤ CSS 去代替（或者使用阿里的iconfont）</li>
<li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。⼀般图⽚都⽤ CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图⽚ </li>
<li>⼩图使⽤ base64 格式将图片内嵌到html 中，减少网站HTTP 的请求数量</li>
<li>将多个图标⽂件整合到⼀张图⽚中（雪碧图）</li>
<li>选择正确的图⽚格式： </li>
</ol>
<ul>
<li>对于能够显示 WebP 格式的浏览器尽量使⽤ WebP 格式。因为 WebP 格式具有更好 的图像数据压缩算法，能带来更⼩的图⽚体积，⽽且拥有⾁眼识别⽆差异的图像质量， 缺点就是兼容性并不好 </li>
<li>⼩图使⽤ PNG ，其实对于⼤部分图标这类图⽚，完全可以使⽤ SVG 代替</li>
<li>照⽚使⽤ JPEG</li>
</ul>
<h1 id="其他优化手段"><a href="#其他优化手段" class="headerlink" title="其他优化手段"></a>其他优化手段</h1><h2 id="利用多个域名存储网站资源"><a href="#利用多个域名存储网站资源" class="headerlink" title="利用多个域名存储网站资源"></a>利用多个域名存储网站资源</h2><ol>
<li><p>CDN缓存更方便（可以根据不同的资源类型（图片、音频、视频等）分别存储在cdn节点上）</p>
</li>
<li><p>突破浏览器并发限制（一般每个域名建立的链接不超过6个）</p>
</li>
<li><p>Cookieless，节省带宽，尤其是上行带宽一般比下行要慢（如果图片放在主站，那么每次请求图片的话都会携带cookie但是没必要，浪费了带宽）</p>
</li>
<li><p>对于UGC（用户生成内容，即用户原创内容）和主站隔离，防止不必要的安全问题(上传js窃取主站cookie之类的)。正是这个原因要求用户内容的域名必须不是自己主站的子域名，而是一个完全独立的第三方域名</p>
</li>
<li><p>节约主域名的连接数，优化页面的响应速度</p>
</li>
</ol>
<h2 id="尽量少使用iframe"><a href="#尽量少使用iframe" class="headerlink" title="尽量少使用iframe"></a>尽量少使用iframe</h2><ul>
<li>iframe 会阻塞主⻚⾯的 Onload 事件 </li>
<li>搜索引擎的检索程序⽆法解读这种⻚⾯，不利于 SEO </li>
<li>iframe 和主⻚⾯共享连接池，⽽浏览器对相同域的连接有限制，所以会影响⻚⾯的并⾏ 加载 使⽤ iframe 之前需要考虑这两个缺点。</li>
<li>如果需要使⽤ iframe ，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题</li>
</ul>
<h2 id="编程风格优化"><a href="#编程风格优化" class="headerlink" title="编程风格优化"></a>编程风格优化</h2><ol>
<li>少声明全局变量（占内存），缓存DOM节点查找的结果（消耗cpu），减少磁盘的I/O读取操作</li>
</ol>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/54cc04190252">深入理解浏览器的缓存机制</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/59a50dc1f265da246e6e108f">web前端资源文件的部署和优化</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/59b73ef75188253db70acdb5">前端性能优化之加载技术</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/06/css/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/06/css/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">浏览器的渲染机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-06 16:06:24" itemprop="dateCreated datePublished" datetime="2019-07-06T16:06:24+08:00">2019-07-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="DOCTYPE及其作用"><a href="#DOCTYPE及其作用" class="headerlink" title="DOCTYPE及其作用"></a>DOCTYPE及其作用</h1><p>由于历史的原因，浏览器对页面的渲染方式是不一样的。在 W3C 标准出来之前，浏览器对页面的渲染没有同一的标准，产生了差异，quirks mod（混杂模式或者兼容模式），但在W3C标准出台之后，浏览器对页面的渲染有了同一的标准即（严格模式或标准模式）。但是为了保证以前旧的页面仍然正常显示，有的浏览器就保存了这两种渲染模式（标准兼容模式）。那么究竟采用哪一种方式进行渲染，就要看DOCTYPE生命中的DTD。</p>
<p><strong>文档类型定义（DTD）Document Type Definition</strong> </p>
<p>简单说 DOCTYPE 是用来声明<strong>文档类型和DTD规范</strong> 的,告知浏览器的解析器用什么文档标准解析这个文档。，一个主要用途就是文件的合法性验证。如果文件代码不合法，那么浏览器解析的时候就会出错。<br>是一系列的语法规则，用来定义 XML 或者 HTML 的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式。<br>html5 不基于 SGML，因此不需要对 DTD 进行引用，也就没有严格模式与宽松模式的区别，html5 有相对宽松的语法，事实上，已经尽可能大的实现了向后兼容（老版本）。</p>
<p>常见的html的DOCTYPE</p>
<p>HTML5 <!DOCTYPE html></p>
<p>HTML4 严格模式 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"> </p>
<p>HTML4 宽松模式 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"></p>
<p>这里可以看到严格模式和宽松模式的区别主要在于后缀的dtd文件的引用。严格模式不包含展示性和弃用元素（比如font），宽松模式包含所有的 HTML 元素和属性。</p>
<h1 id="浏览器的渲染机制"><a href="#浏览器的渲染机制" class="headerlink" title="浏览器的渲染机制"></a>浏览器的渲染机制</h1><p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/tree.png" alt="markdown"></p>
<p>要了解浏览器的渲染机制，需要先明白以下的概念：</p>
<ol>
<li>DOM：Document Object Model（文档对象模型），当我们打开⼀个⽹⻚时，浏览器都会去请求对应的 HTML ⽂件。虽然平时我 们写代码时都会分为 JS 、 CSS 、 HTML ⽂件，也就是字符串，但是计算机 硬件是不理解这些字符串的，所以在⽹络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，浏览器会有html解析器进行解析，它会将这些字节数据转换为 字符串，也就是我们写的代码。（字节流转换成为字符流）</li>
</ol>
<p>当数据转换为字符串以后，浏览器会先将这些字符串通过<strong>词法分析转换为标记 （ token ）</strong>，这⼀过程在词法分析中叫做标记化（ tokenization ）。</p>
<p>那么什么是标记呢？这其实属于编译原理这⼀块的内容了。简单来说，标记还 是字符串，是构成代码的⼩单位。这⼀过程会将代码分拆成⼀块块，并给这 些内容打上标记，便于理解这些⼩单位的代码是什么意思。</p>
<p>当结束标记化后，<strong>通过词法分析</strong>，这些标记会紧接着转换为 Node ，这些 Node 会根据 不同 Node 之前的联系构建为树形的数据结构，称为 DOM 树。</p>
<ol start="2">
<li><p>CSSOM：CSS Object Model，浏览器将CSS解析成树形的数据结构，简称CSSOM（步骤类似上一步）。</p>
</li>
<li><p>Render Tree: DOM和CSSOM合并后生成Render Tree(但是如果遇到script标签的时候，会执行并阻塞渲染)。</p>
</li>
</ol>
<p>在这⼀过程中，不是简单的将两者合并就⾏了。渲染树只会包括需要显示的节点和这些节 点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。</p>
<ol start="4">
<li><p>Layout: 计算出Render Tree每个节点的具体位置。（布局）</p>
</li>
<li><p>Painting：通过显卡，开始调用 GPU 绘制，合成图层，将Layout后的节点内容分别呈现到屏幕上。（渲染）</p>
</li>
</ol>
<p>PS：</p>
<ul>
<li>css加载不会阻塞DOM树的解析。</li>
<li>css和script的加载会阻塞DOM树的渲染（白屏）。</li>
<li>css加载会阻塞后面js语句的执行，但是不会阻塞外部脚本的加载（因为 Renderer 进程中 JS 线程和渲染线程是互斥的）。</li>
</ul>
<h1 id="重排（回流）Reflow-（引起DOM树重新计算的行为）"><a href="#重排（回流）Reflow-（引起DOM树重新计算的行为）" class="headerlink" title="重排（回流）Reflow （引起DOM树重新计算的行为）"></a>重排（回流）Reflow <strong>（引起DOM树重新计算的行为）</strong></h1><p>DOM结构中的各个元素都有自己的盒子，这些都需要浏览器根据各种样式来计算，并根据计算结果将元素放到它该出现的位置，这个过程称为reflow。<br>以下是触发reflow的几种方法：</p>
<ol>
<li>增加、删除、修改DOM节点的时候，会导致Reflow。</li>
<li>移动DOM的位置，或者生成动画的时候。</li>
<li>修改CSS样式的时候。</li>
<li>Resize窗口的时候（移动端没有这个问题），或者滚动的时候。</li>
<li>修改网页的默认字体时。</li>
<li>获取某些属性，包括offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle()，<strong>获取时应当做适当的缓存</strong>。</li>
</ol>
<p>PS: 针对以上的第六点，为什么会导致获取某些属性的时候会导致浏览器的重排？</p>
<p>现代浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是<strong>当你获取布局信息的操作的时候，为了获取更加准确的信息，会强制队列刷新，也刷新了缓冲区域</strong>，所以必要的时候，获取的时候需要做适当的缓存。</p>
<h1 id="重绘Repaint-（元素样式的改变触发浏览器的行为）"><a href="#重绘Repaint-（元素样式的改变触发浏览器的行为）" class="headerlink" title="重绘Repaint （元素样式的改变触发浏览器的行为）"></a>重绘Repaint <strong>（元素样式的改变触发浏览器的行为）</strong></h1><p>当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称为Repaint。</p>
<p>触发Repaint</p>
<ol>
<li>DOM改动</li>
<li>CSS改动</li>
</ol>
<p>重排一定会导致重绘（改变网页的位置），但是重绘不一定会导致重排（如颜色的改变）。</p>
<p>减少重排的几个方法：</p>
<ul>
<li>样式集中改变，减少对 DOM 的操作。</li>
<li>对于多次重排的元素，使用 absolute 或者 fixed 脱离文档流。</li>
<li>尽量减少使用 table 布局，因为一个小的改动会导致整个 table 的重新布局，通常要浪费同等元素的时间的3倍。</li>
<li>不要在布局信息改变的时候做 DOM 查询。</li>
<li>动画元素脱离文档流（浮动、绝对定位和固定定位），减少回流的 Render Tree 的规模。</li>
<li>使用 opacity 替代 visibility，因为 visibility 会触发重绘，而使用 opacity 不会。</li>
<li>使用 visibility 替换 display:none，因为前者只会引起重绘，后者会引起回流改变布局。</li>
<li>通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）。</li>
</ul>
<p>PS：为什么操作DOM非常昂贵？</p>
<p><strong>操作DOM会导致重排和重绘，重排会占用、消耗CPU; 重绘会占用、消耗GPU。操作频繁会使得电脑卡顿</strong></p>
<h1 id="回流与重绘相关的eventLoop"><a href="#回流与重绘相关的eventLoop" class="headerlink" title="回流与重绘相关的eventLoop"></a>回流与重绘相关的eventLoop</h1><ul>
<li>当 Event loop 执⾏完 Microtasks 后，会判断 document 是否需要更新。- 因为浏览 器是 60Hz 的刷新率，每 16ms 才会更新⼀次。 </li>
<li>然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是⾄少 16ms 才会触发⼀次，并且⾃带节流功能。 </li>
<li>判断是否触发了 media query 。</li>
<li>更新动画并且发送事件。</li>
<li>判断是否有全屏操作事件 执⾏ requestAnimationFrame 回调 执⾏ IntersectionObserver 回调，该⽅法⽤于判断元素是否可⻅，可以⽤于懒加载上，但是兼容性不好。</li>
<li>更新界⾯。</li>
</ul>
<p>以上就是⼀帧中可能会做的事情。如果在⼀帧中有空闲时间，就会去执⾏ requestIdleCallback 回调。</p>
<h1 id="输入URL到浏览器显示页面发生了什么"><a href="#输入URL到浏览器显示页面发生了什么" class="headerlink" title="输入URL到浏览器显示页面发生了什么"></a>输入URL到浏览器显示页面发生了什么</h1><ol>
<li>在浏览器地址栏输⼊ URL</li>
<li>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 </li>
</ol>
<ul>
<li>如果资源未缓存，发起新请求 </li>
<li>如果已缓存，检验是否⾜够新鲜，⾜够新鲜直接提供给客户端，否则与服务器进⾏验 证。 </li>
<li>检验新鲜通常有两个HTTP头进⾏控制 Expires 和 Cache-Control ： HTTP1.0提供Expires，值为⼀个绝对时间表示缓存新鲜⽇期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的Y⼤新鲜时间</li>
</ul>
<ol start="3">
<li>浏览器解析URL获取协议，主机，端⼝，path </li>
<li>浏览器组装⼀个HTTP（GET）请求报⽂ </li>
<li>浏览器获取主机ip地址，过程如下： </li>
</ol>
<ul>
<li>浏览器缓存 </li>
<li>本机缓存 </li>
<li>hosts⽂件 </li>
<li>路由器缓存 </li>
<li>ISP DNS缓存 </li>
<li>DNS递归查询（可能存在负载均衡导致每次IP不⼀样） </li>
</ul>
<p>DNS 的作用就是通过域名查询到具体的 IP。</p>
<p>因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。</p>
<ul>
<li>浏览器输入 <a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a> 时，请求发起后，游览器首先会解析这个域名，首先它会查看<strong>本地硬盘的 hosts 文件</strong>，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</li>
<li>如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS 请求到<strong>本地DNS(域名分布系统)服务器</strong>。本地 DNS 服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</li>
<li>查询你输入的网址的 DNS 请求到达本地 DNS 服务器之后，本地 DNS 服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地 DNS 服务器还要向<strong>DNS根服务器进行查询</strong>，DNS 根服务器找出负责 com 这个⼀级域名的服务器 </li>
<li>根 DNS 服务器没有记录具体的域名和 IP 地址的对应关系，而是告诉本地 DNS 服务器，你可以到<strong>域服务器</strong>上去继续查询，并给出域服务器的地址。这种过程是迭代的过程</li>
<li>本地 DNS 服务器继续向域服务器发出请求，在这个例子中，请求的对象是 .com 域服务器。.com 域服务器收到请求之后，<strong>也不会直接返回域名和IP地址的对应关系</strong>，而是告诉本地 DNS 服务器，你的<strong>域名的解析服务器的地址</strong></li>
<li>最后，本地 DNS 服务器向域名的解析服务器发出请求，这时就能收到一个域名和 IP 地址对应关系，本地 DNS 服务器不仅要把 IP 地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</li>
</ul>
<p>本地硬盘 host 文件=&gt;本地 DNS 服务器(中国移动，中国电信)=&gt;根 DNS 服务器=&gt;域服务器=&gt;域名的解析服务器的地址=&gt;返回给本地 DNS 服务器，并作缓存。</p>
<ol start="6">
<li>打开⼀个 socket 与⽬标 IP 地址，端⼝建⽴ TCP 链接，三次握⼿如下： </li>
</ol>
<ul>
<li>客户端发送⼀个 TCP 的 SYN=1，Seq=X 的包到服务器端⼝ </li>
<li>服务器发回 SYN=1， ACK=X+1， Seq=Y 的响应包 </li>
<li>客户端发送 ACK=Y+1， Seq=Z </li>
</ul>
<ol start="7">
<li>服务器检查 HTTP 请求头是否包含缓存验证信息如果验证缓存新鲜，返回 304 等对应状态码 </li>
<li>处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作 </li>
<li>服务器将响应报⽂通过 TCP 连接发送回浏览器，关闭 TCP 连接四次挥手</li>
<li>浏览器接收 HTTP 响应，然后根据情况选择关闭 TCP 连接或者保留重⽤，关闭 TCP 连接的四 次握⼿如下： </li>
</ol>
<ul>
<li>主动⽅发送 Fin=1， Ack = Z， Seq = X 报⽂ </li>
<li>被动⽅发送 ACK = X+1， Seq = Z 报⽂ </li>
<li>被动⽅发送 Fin = 1， ACK = X， Seq = Y报⽂ </li>
<li>主动⽅发送 ACK = Y， Seq = X 报⽂ </li>
</ul>
<ol start="11">
<li>浏览器检查响应状态吗：是否为 1XX，3XX，4XX，5XX 这些情况处理与 2XX 不同</li>
<li>如果资源可缓存，进⾏缓存 </li>
<li>对响应进⾏解码（例如 gzip 压缩） </li>
<li>根据资源类型决定如何处理（假设资源为 HTML ⽂档）</li>
<li>解析 HTML ⽂档，构件 DOM 树，下载资源，构造 CSSOM 树，执⾏ js 脚本，这些操作没有严格的先后顺序，以下分别解释 </li>
<li>构建 DOM 树： </li>
</ol>
<ul>
<li>Tokenizing：根据 HTML 规范将字符流解析为标记 。</li>
<li>Lexing：词法分析将标记转换为对象并定义属性和规则 。</li>
<li>DOM construction：根据 HTML 标记关系将对象组成 DOM 树 。</li>
</ul>
<ol start="17">
<li>解析过程中遇到图⽚、样式表、js ⽂件，启动下载 。</li>
<li>构建 CSSOM 树： </li>
</ol>
<ul>
<li>Tokenizing：字符流转换为标记流。</li>
<li>Node：根据标记创建节点 。</li>
<li>CSSOM：节点创建 CSSOM 树 。</li>
</ul>
<ol start="19">
<li>根据 DOM 树和 CSSOM 树构建渲染树: </li>
</ol>
<ul>
<li>从 DOM 树的根节点遍历所有可⻅节点，不可⻅节点包括：<ul>
<li>script , meta 这样本身 不可⻅的标签。</li>
<li>被 css 隐藏的节点，如 display: none 。</li>
</ul>
</li>
<li>对每⼀个可⻅节点，找到恰当的 CSSOM 规则并应⽤ 。</li>
<li>发布可视节点的内容和计算样式 。</li>
</ul>
<ol start="20">
<li>js 解析如下： </li>
</ol>
<ul>
<li>浏览器创建 Document 对象并解析 HTML，将解析到的元素和⽂本节点添加到⽂档中，此时 document.readystate 为 loading 。</li>
<li>HTML解析器遇到没有 async 和 defer 的 script 时，将他们添加到⽂档中，然后执⾏⾏内 或外部脚本。这些脚本会同步执⾏，并且在脚本下载和执⾏时解析器会暂停。这样就可以⽤ document.write() 把⽂本插⼊到输⼊流中。同步脚本经常简单定义函数和注册事件 处理程序，他们可以遍历和操作 script 和他们之前的⽂档内容 。</li>
<li>当解析器遇到设置了 async 属性的 script 时，开始下载脚本并继续解析⽂档。脚本会在它下载完成后尽快执⾏，但是解析器不会停下来等它下载。异步脚本禁⽌使⽤ document.write()，它们可以访问⾃⼰ script和之前的⽂档元素。</li>
<li>当⽂档完成解析，document.readState变成interactive。</li>
<li>所有 defer 脚本会按照在⽂档出现的顺序执⾏，延迟脚本能访问完整⽂档树，禁⽌使⽤ document.write() 。</li>
<li>浏览器在 Document 对象上触发 DOMContentLoaded 事件 。</li>
<li>此时⽂档完全解析完成，浏览器可能还在等待如图⽚等内容加载，等这些内容完成载⼊ 并且所有异步脚本完成载⼊和执⾏，document.readState 变为 complete，window 触发 load 事件。</li>
</ul>
<ol start="21">
<li>显示⻚⾯。（HTML解析过程中会逐步显示⻚⾯）</li>
</ol>
<h1 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h1><p>传统的 javascript 动画是通过定时器 setTimeout 或者 setInterval 实现的。但是定时器动画一直存在两个问题，第一个就是动画的循时间环间隔不好确定，设置长了动画显得不够平滑流畅，设置短了浏览器的重绘频率会达到瓶颈，推荐的最佳循环间隔是 17ms（大多数电脑的显示器刷新频率是 60Hz，1000ms/60）；第二个问题是定时器第二个时间参数只是指定了多久后将动画任务添加到浏览器的 UI 线程队列中，如果<strong>UI线程处于忙碌状态，那么动画不会立刻执行（UI线程和JS线程也是互斥的）。</strong>为了解决这些问题，H5 中加入了 requestAnimationFrame。</p>
<p><strong>优点：</strong></p>
<ol>
<li>requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。</li>
<li>在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量。</li>
<li>requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销。</li>
</ol>
<p>须注意的是，requestAnimationFrame 也属于宏任务。使用方法和 setTimeout 一样。</p>
<h1 id="浏览器的工作原理"><a href="#浏览器的工作原理" class="headerlink" title="浏览器的工作原理"></a>浏览器的工作原理</h1><h2 id="进程和线程的概念"><a href="#进程和线程的概念" class="headerlink" title="进程和线程的概念"></a>进程和线程的概念</h2><ul>
<li><p>进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。（进程是一个工厂，工厂有它的独立资源，并且工厂之间相互独立）</p>
</li>
<li><p>线程：是进程中的一部分，一个没有线程的进程也可以被看作是单线程的，是 CPU 调度的一个基本单位。（线程是工厂中的工人，多个工人协作完成任务，一个工厂可以有一个或者多个工人，工人之间共享空间）</p>
</li>
</ul>
<p>进程之间的通信方式：</p>
<ul>
<li>无名管道：半双工通信方式（即数据只能在一个方向上流动），数据只能单向流动并且只能在具有亲缘关系的进程间使用。</li>
<li>有名管道：也是半双工通信方式，但是允许没有亲缘进程之间的通信。</li>
<li>高级管道：将另一个程序当作一个新的程序在当前程序进程中启动，则这个进程算是当前程序的子进程。</li>
<li>信号：用于通知接受进程某个事件已经发生。</li>
<li>消息队列：是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列 ID）来标识。</li>
<li>共享内存：指两个或多个进程共享一个给定的存储区。</li>
</ul>
<h2 id="浏览器的进程"><a href="#浏览器的进程" class="headerlink" title="浏览器的进程"></a>浏览器的进程</h2><h3 id="浏览器的单进程时代"><a href="#浏览器的单进程时代" class="headerlink" title="浏览器的单进程时代"></a>浏览器的单进程时代</h3><p>在前端处于刀耕火种的年代，微软通过在它的电脑设备上绑定了 ie 浏览器，逐渐的打败了昔日强敌网景，独霸整个 pc 时代。以 ie6 为例，这款浏览器就是典型的单进程浏览器，而且还是单线程浏览器。所以你可以想象，这个浏览器是奇慢无比，一个网页挂了就会导致浏览器里所有的页面都挂了。于是乎在后面的 ie 浏览器，通过多线程技术来试图提升浏览器的速度，但其实单进程无论怎么魔改，都会涉及到这些问题：</p>
<ol>
<li>不稳定。毕竟只要一个线程挂了就整个浏览器挂了，所以整个浏览器很不稳定。</li>
<li>不流畅。比如在通过网络获取资源，到渲染流程，如果浏览器上还有插件则还要考虑插件的运行，如果有一个脚本是死循环的，则导致所有页面都要等待这个脚本执行完毕，会导致整个页面十分的不流畅。并且单进程浏览器关闭一个页面也会存在内存泄漏的问题，毕竟不是多进程。多进程关掉一个页面相当于关掉一个进程，系统会自动回收资源。所以这样子会导致浏览器开的越久就越占用内存。</li>
<li>不安全。上面说到线程是可以共享进程里的资源的，如果一个插件是恶意的，它可以影响到整个浏览器，甚至可以控制你的电脑，来盗取账号密码。除了插件外，还有一些脚本可以通过钻漏洞来获取权限，引发很多严重的后果。</li>
</ol>
<h3 id="浏览器的多进程时代"><a href="#浏览器的多进程时代" class="headerlink" title="浏览器的多进程时代"></a>浏览器的多进程时代</h3><p>现代浏览器以 chrome 浏览器为例，目前的浏览器的多进程架构大致上是这样的：</p>
<ol>
<li>浏览器进程。该进程主要是负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>
<li>网络进程。该进程主要负责页面的网络资源加载，比如在地址栏输入一个网页地址，网络进程会将请求后得到的资源交给渲染进程处理。</li>
<li>渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。（浏览器的渲染进程是多线程的）</li>
<li>GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>
<li>插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ol>
<p>Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p>
<h1 id="webWorker实现多线程"><a href="#webWorker实现多线程" class="headerlink" title="webWorker实现多线程"></a>webWorker实现多线程</h1><p>Web Worker 是 HTML5 标准的一部分，这一规范定义了一套 API，它允许一段 JavaScript 程序运行在主线程之外的另外一个线程中。工作线程允许开发人员编写能够长时间运行而不被用户所中断的后台程序， 去执行事务或者逻辑，并同时保证页面对用户的及时响应，可以将一些大量计算的代码交给 web worker 运行而不冻结用户界面，web worker 就是为了解决这种花费大量时间的复杂运算而诞生的！</p>
<ul>
<li><p>允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</p>
</li>
<li><p>JS引擎线程与 worker 线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</p>
</li>
</ul>
<p>所以，如果有非常耗时的工作，请单独开一个 Worker 线程，这样里面不管如何翻天覆地都不会影响 JS 引擎主线程，只待计算出结果后，将结果返回给主线程即可。</p>
<p>而且注意下，JS 引擎是单线程的，这一点的本质仍然未改变，Worker 可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p>
<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d765572e51d45621320318e">现代浏览器工作原理（一）——浏览器进程</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/03/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/%E6%89%8B%E6%92%95webSocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/03/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/%E6%89%8B%E6%92%95webSocket/" class="post-title-link" itemprop="url">手撕websocket</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-03 12:56:15" itemprop="dateCreated datePublished" datetime="2019-07-03T12:56:15+08:00">2019-07-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Ajax/" itemprop="url" rel="index"><span itemprop="name">Ajax</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p>
<p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p>
<p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p>
<p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p>
<p>其他特点包括：</p>
<p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p>
<p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p>
<p>（3）数据格式比较轻量，性能开销小，通信高效。</p>
<p>（4）可以发送文本，也可以发送二进制数据。</p>
<p>（5）没有同源限制，客户端可以与任意服务器通信。</p>
<p>（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;wss://echo.websocket.org&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Connection open ...&#x27;</span>);</span><br><span class="line">    ws.send(<span class="string">&#x27;Hello WebSockets!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Received Message: &#x27;</span>, evt.data);</span><br><span class="line">    ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Connection closed.&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// url（必选），options（可选）</span></span><br><span class="line">fetch(<span class="string">&#x27;/some/url/&#x27;</span>, &#123;</span><br><span class="line">    method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 出错了，等价于 then 的第二个参数，但这样更好用更直观</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>参考文章：<br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leslie choi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
