<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yoursite.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta property="og:type" content="website">
<meta property="og:title" content="404 not found">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="404 not found">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="leslie choi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;2&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>404 not found</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">404 not found</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">leslie choi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/30/vue/14%20$listener%E5%92%8C$attrs%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/30/vue/14%20$listener%E5%92%8C$attrs%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">$listener 和 $attrs 的使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-30 08:43:20" itemprop="dateCreated datePublished" datetime="2020-07-30T08:43:20+08:00">2020-07-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="listener-和-attrs-的使用"><a href="#listener-和-attrs-的使用" class="headerlink" title="$listener 和 $attrs 的使用"></a>$listener 和 $attrs 的使用</h1><p>背景：假设有一个 father 组件，father 组件中引入了 child 组件，child 组件中又引入了 son 组件。那么 father 组件和 child 组件之间如何通信呢？</p>
<p>解决方案：</p>
<ol>
<li>万金油方案 Vuex，使用 Vuex 虽然能够实现数据之间的共享，但是项目中如果组件之间共享状态比较少，或者说项目比较小，那么使用 Vuex 确实没太大必要。</li>
<li>将 child 组件当成一个中间站，然后利用父子组件之间 prop 和 $emit，一层一层向上或者向下传递信息，虽然可行但是使用麻烦并且可维护性差。</li>
<li>自定义一个Vue 中央数据总线（todo），但是多人协作麻烦</li>
</ol>
<p>针对这种情况，在vue2.4中，为了解决该需求，引入了$attrs 和$listeners，新增了inheritAttrs 选项。</p>
<p><strong>父组件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Father&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;child :temp&#x3D;&quot;tempdata&quot; @tempFn&#x3D;&quot;fatherFn&quot; prop&#x3D;&#39;$attrs不会传递child组件中定义的props5值&#39;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &#39;.&#x2F;Child.vue&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">      Child</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      tempdata: &#39;i am father data&#39;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;&#125;,</span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fatherFn: function() &#123;</span><br><span class="line">      console.log(&#39;call father function!&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>子组件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;child&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;son v-bind&#x3D;&quot;$attrs&quot; v-on&#x3D;&quot;$listeners&quot;&gt;&lt;&#x2F;son&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from &#39;.&#x2F;Son&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Child&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;&#125;,</span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(&#39;this.$attrs&#39;,this.$attrs)  &#x2F;&#x2F;  &#123;prop: &#39;$attrs不会传递child组件中定义的props5值&#39;,temp: &#39;i am father data&#39;&#125;</span><br><span class="line">    console.log(&#39;this.$listeners&#39;,this.$listeners)  &#x2F;&#x2F;  &#123;tempFn: fn&#125;</span><br><span class="line">    this.$emit(&#39;tempFn&#39;)   &#x2F;&#x2F;   子组件调用父组件方法</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>孙组件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;son&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123; $attrs.temp &#125;&#125;--------&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;&#125;,</span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  methods: &#123;&#125;,</span><br><span class="line">  created() &#123;&#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    &#x2F;&#x2F; this.$emit(&#39;tempFn&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>$attrs：当前组件的属性，通俗的讲也就是在组件标签定义的一系列属性，如input的value，placeholder等，但是不包括在当前组件里面定义的props属性。</p>
</li>
<li><p>$listeners：当前组件监听的事件，通俗的讲也就是在使用组件的时候在标签中定义的事件，如@input，以及一些自定义事件@tempFn等。</p>
</li>
</ul>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p>(Vue中的$attrs和$listener)[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lsboom/p/11365293.html]">https://www.cnblogs.com/lsboom/p/11365293.html]</a><br>(绝对干货~！学会这些Vue小技巧，可以早点下班和女神约会了)[<a target="_blank" rel="noopener" href="https://juejin.im/post/5eddbaee5188254344768fdc#heading-10]">https://juejin.im/post/5eddbaee5188254344768fdc#heading-10]</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42966484/article/details/89408538">VUE中.sync 修饰符</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/30/vue/Vue%20%E7%BC%96%E7%A0%81%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/30/vue/Vue%20%E7%BC%96%E7%A0%81%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">vue 编码优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-30 08:43:20" itemprop="dateCreated datePublished" datetime="2020-07-30T08:43:20+08:00">2020-07-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-13 19:28:07" itemprop="dateModified" datetime="2021-04-13T19:28:07+08:00">2021-04-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="使用-Object-freeze-提升性能"><a href="#使用-Object-freeze-提升性能" class="headerlink" title="使用 Object.freeze() 提升性能"></a>使用 Object.freeze() 提升性能</h1><p>背景：在开发过程中，我们经常需要获取一些对象，像users信息，列表items，文章信息等等，但是我们不需要去修改这些信息。我们只是把这些信息展示出来，或者放在vuex中state里面。</p>
<p>Vue默认会对每个数组数据的每一层属性，添加双向数据绑定机制。当数组对象非常庞大时，消耗在这上面的双向数据绑定就越多。因为，在这种场景下，我们可以通过阻止Vue对这些数据添加双向数据绑定来提高一些性能。</p>
<p>根据 MDN 文档，使用 Object.freeze()，可以冻结一个对象，被冻结的对象则不能再被修改。即该对象不能添加、删除已有的属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。</p>
<p><strong>此外，冻结一个对象后该对象的原型也不能被修改。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&quot;james&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj)</span><br><span class="line"></span><br><span class="line">obj.prop = <span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.prop)</span><br></pre></td></tr></table></figure>

<p>PS: 顺便提一下密封对象和禁止对象属性拓展</p>
<ol>
<li><p>Object.preventExtensions()，禁止对象拓展，但是可以修改和删除对象的属性。<strong>Object.preventExtensions()仅阻止添加自身的属性。但其对象类型的原型依然可以添加新的属性。</strong></p>
</li>
<li><p>Object.seal()，可以修改对象属性，不可以删除和增加对象属性。</p>
</li>
</ol>
<p><strong>以上三个方法分别可用Object.isExtensible(), Object.isSealed(), Object.isFrozen() 来检测</strong></p>
<p>当你把一个普通的 JavaScript 对象传给 Vue 实例的  data  选项，Vue 将遍历此对象所有的属性，并使用  Object.defineProperty  把这些属性全部转为 getter/setter，这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>
<p>但 Vue 在遇到像 Object.freeze() 这样被设置为不可配置之后的对象属性时，不会为对象加上 setter getter 等数据劫持的方法，使用了 Object.freeze() 之后，减少了 observer 的开销。</p>
<p>由于 Object.freeze()会把对象冻结，所以比较适合展示类的场景，如果你的数据属性需要改变，可以重新替换成一个新的 Object.freeze()的对象。<strong>由于 Object.freeze()会把对象冻结，所以比较适合展示类的场景，如果你的数据属性需要改变，可以重新替换成一个新的 Object.freeze()的对象。</strong></p>
<h1 id="requireContext-导入组件-todo"><a href="#requireContext-导入组件-todo" class="headerlink" title="requireContext 导入组件(todo)"></a>requireContext 导入组件(todo)</h1><h1 id="sync-的使用"><a href="#sync-的使用" class="headerlink" title=".sync 的使用"></a>.sync 的使用</h1><p>背景：在 Vue1.x 版本，.sync 还可以进行双向数据绑定，即说明子组件中可以修改父组件的值。但是这与单向数据流的设计理念相违背，所以在 Vue2.0 版本中被舍弃。直到 Vue2.3 版本及以上，重新引进了 .sync 修饰符，这次只是作为语法糖的存在。存在的意义就是让我们手动更新父组件中的值，并且让其的数据改动来源更加明显。</p>
<p><strong>适用于单纯在子组件中修改父组件中数据的场景</strong></p>
<p>父组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;我是父组件中的按钮&quot; @click&#x3D;&quot;show&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- &lt;Son @upIsShow&#x3D;&quot;changeIsShow&quot; v-show&#x3D;&quot;isShow&quot; &#x2F;&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;Son @update:isShow&#x3D;&quot;changeIsShow&quot; v-show&#x3D;&quot;isShow&quot;&#x2F;&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;Son @update:isShow&#x3D;&quot;function(bol)&#123;isShow&#x3D;bol&#125;&quot; v-show&#x3D;&quot;isShow&quot;&#x2F;&gt; --&gt;</span><br><span class="line">    &lt;!-- &lt;Son @update:isShow&#x3D;&quot;bol&#x3D;&gt;isShow&#x3D;bol&quot; v-show&#x3D;&quot;isShow&quot;&#x2F;&gt; --&gt;</span><br><span class="line">    &lt;Son :isShow.sync&#x3D;&quot;isShow&quot; v-show&#x3D;&quot;isShow&quot; :age.sync&#x3D;&quot;age&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- 当子组件想要更改isShow的值，需要显式触发 this.$emit(&quot;update:isShow&quot;,false) 事件--&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;this.age&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from &quot;..&#x2F;components&#x2F;sync&#x2F;Son&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      isShow: false,</span><br><span class="line">      age: 20</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    show() &#123;</span><br><span class="line">      this.isShow &#x3D; true</span><br><span class="line">    &#125;,</span><br><span class="line">    changeIsShow(bol) &#123;</span><br><span class="line">      this.isShow &#x3D; bol</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    我是一个子组件！</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;点击消失&quot; @click&#x3D;&quot;upIsShow&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    upIsShow() &#123;</span><br><span class="line">      &#x2F;&#x2F; this.$emit(&quot;upIsShow&quot;, false)</span><br><span class="line">      this.$emit(&quot;update:isShow&quot;,false)</span><br><span class="line">      this.$emit(&quot;update:age&quot;,22)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="动态组件渲染"><a href="#动态组件渲染" class="headerlink" title="动态组件渲染"></a>动态组件渲染</h1><h1 id="常见性能优化方式"><a href="#常见性能优化方式" class="headerlink" title="常见性能优化方式"></a>常见性能优化方式</h1><ol>
<li><p>合理使用 v-show 和 v-if</p>
</li>
<li><p>合理使用 compited</p>
</li>
<li><p>v-for 加上 key，避免和 v-if 同时使用</p>
</li>
<li><p>合理使用 keep-alive</p>
</li>
<li><p>合理使用异步组件</p>
</li>
<li><p>自定义事件、DOM 事件及时销毁</p>
</li>
<li><p>data 层级不要嵌套太深</p>
</li>
<li><p>开发环境使用 vue-loader 做模版编译（预编译）</p>
</li>
<li><p>使用 SSR</p>
</li>
</ol>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d5e89aee51d453bdb1d9b61">利用Object.freeze()提升性能</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/56168a779849">Object.freeze()提高Vue.js中大型列表的性能【翻译+解读】</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/26/JavaScript/javascript%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/26/JavaScript/javascript%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">JavaScript 开发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-26 16:19:11" itemprop="dateCreated datePublished" datetime="2020-07-26T16:19:11+08:00">2020-07-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="判断设备"><a href="#判断设备" class="headerlink" title="判断设备"></a>判断设备</h1><ol>
<li>判断当前设备类型</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="title">getPhoneType</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> u = navigator.userAgent</span><br><span class="line">  <span class="keyword">if</span> (u.indexOf(<span class="string">&#x27;Android&#x27;</span>) &gt; -<span class="number">1</span> || u.indexOf(<span class="string">&#x27;Linux&#x27;</span>) &gt; -<span class="number">1</span>) &#123; <span class="comment">// 安卓手机</span></span><br><span class="line">    result = <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.indexOf(<span class="string">&#x27;iPhone&#x27;</span>) &gt; -<span class="number">1</span>) &#123; <span class="comment">// 苹果手机</span></span><br><span class="line">    result = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.indexOf(<span class="string">&#x27;Windows Phone&#x27;</span>) &gt; -<span class="number">1</span>) &#123; <span class="comment">// winphone手机</span></span><br><span class="line">    result = <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.indexOf(<span class="string">&#x27;iPhone Simulator&#x27;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    result = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>判断是否 IPhoneX 系列</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="title">isIphoneXall</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// iPhone X、iPhone XS</span></span><br><span class="line">  <span class="keyword">const</span> isIPhoneX = <span class="regexp">/iphone/gi</span>.test(<span class="built_in">window</span>.navigator.userAgent) &amp;&amp; <span class="built_in">window</span>.screen.width === <span class="number">375</span> &amp;&amp; <span class="built_in">window</span>.screen.height === <span class="number">812</span></span><br><span class="line">  <span class="comment">// iPhone XS Max</span></span><br><span class="line">  <span class="keyword">const</span> isIPhoneXSMax = <span class="regexp">/iphone/gi</span>.test(<span class="built_in">window</span>.navigator.userAgent) &amp;&amp; <span class="built_in">window</span>.screen.width === <span class="number">414</span> &amp;&amp; <span class="built_in">window</span>.screen.height === <span class="number">896</span></span><br><span class="line">  <span class="comment">// iPhone XR</span></span><br><span class="line">  <span class="keyword">const</span> isIPhoneXR = <span class="regexp">/iphone/gi</span>.test(<span class="built_in">window</span>.navigator.userAgent) &amp;&amp; <span class="built_in">window</span>.screen.width === <span class="number">414</span> &amp;&amp; <span class="built_in">window</span>.screen.height === <span class="number">896</span></span><br><span class="line">  <span class="keyword">if</span> (isIPhoneX || isIPhoneXSMax || isIPhoneXR) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="判断是否是-url"><a href="#判断是否是-url" class="headerlink" title="判断是否是 url"></a>判断是否是 url</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> isUrl = <span class="function"><span class="params">str</span> =&gt;</span> <span class="regexp">/^(((ht|f)tps?):\/\/)?[\w-]+(\.[\w-]+)+([\w.,@?^=%&amp;:/~+#-]*[\w@?^=%&amp;/~+#-])?$/</span>.test(str)</span><br><span class="line"><span class="comment">// e.g.</span></span><br><span class="line">isUrl(<span class="string">&#x27;https://www.baidu.com&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">isUrl(<span class="string">&#x27;https://www&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="连字符和驼峰互相转换"><a href="#连字符和驼峰互相转换" class="headerlink" title="连字符和驼峰互相转换"></a>连字符和驼峰互相转换</h1><ol>
<li>连字符转驼峰</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> toCamelCase = <span class="function">(<span class="params">str = <span class="string">&#x27;&#x27;</span>, separator = <span class="string">&#x27;-&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Argument must be a string&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> newExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;\\-\(\\w\)&#x27;</span>, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> str.replace(newExp, <span class="function">(<span class="params">matched, $<span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> $<span class="number">1.</span>toUpperCase()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g.</span></span><br><span class="line">toCamelCase(<span class="string">&#x27;hello-world&#x27;</span>) <span class="comment">// helloWorld</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>驼峰转连字符</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> fromCamelCase = <span class="function">(<span class="params">str = <span class="string">&#x27;&#x27;</span>, separator = <span class="string">&#x27;-&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Argument must be a string&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/([A-Z])/g</span>, <span class="string">`<span class="subst">$&#123;separator&#125;</span>$1`</span>).toLowerCase()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g.</span></span><br><span class="line">fromCamelCase(<span class="string">&#x27;helloWorld&#x27;</span>) <span class="comment">// hello-world</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>






<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>(【适合收藏】为了多点时间陪女朋友，我向BAT大佬跪求了这15条JS技巧)[<a target="_blank" rel="noopener" href="https://juejin.im/post/6854573211955560455]">https://juejin.im/post/6854573211955560455]</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/11/%E7%BD%91%E7%BB%9C/%E5%89%8D%E7%AB%AF%E7%99%BB%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/11/%E7%BD%91%E7%BB%9C/%E5%89%8D%E7%AB%AF%E7%99%BB%E5%BD%95/" class="post-title-link" itemprop="url">前端登录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-11 14:00:25" itemprop="dateCreated datePublished" datetime="2020-01-11T14:00:25+08:00">2020-01-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="传统的登录方案"><a href="#传统的登录方案" class="headerlink" title="传统的登录方案"></a>传统的登录方案</h1><p>http 是一种无状态的协议，也就是说它并不知道哪一个用户访问量了应用。针对 http 无状态的这样一个特点，解决的方法就是使用 cookie 记录用户的登录状态。  </p>
<p>每当用户登录之后，如果登录成功，服务端就会生成一条记录，这个记录保存了一个 sessionId，可以用来判断当前的用户是哪一个，然后再将这个 sessionId 发送到客户端，客户端可以将这个 session ID 保存到 cookie 中，下次这个用户再次向服务器发送请求的时候，就可以携带 Cookie，这个时候服务端就会验证 cookie 里面的信息，如果能在服务端中找到对应的记录，就说明用户已经通过了身份的验证，然后就可以把用户请求的数据返回给客户端。</p>
<p>上面的解决方法就是使用 session 配合 cookie 解决的，但是这样就存在一种问题，服务端需要存储登录用户生成的 Session，而这些 Session 可能会存储在内存中、磁盘、数据库里面，所以我们就必须定时去清理过期的 Session，这种认证方法出现的问题就是，如果用户量增多，那么服务器的开销就会不断增加，而且使用到 cookie，就很容易受到跨站点请求伪造（CSRF）的攻击</p>
<h1 id="token-登录验证"><a href="#token-登录验证" class="headerlink" title="token 登录验证"></a>token 登录验证</h1><p>针对这样一种情况，新增一种 token 的解决方案</p>
<p>简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</p>
<p>特点：服务端无状态化、可扩展性好 支持移动端设备 相对安全 支持跨程序调用</p>
<p><strong>传统的 token 的身份验证流程：</strong></p>
<ul>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</li>
<li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</li>
<li>服务端收到请求，然后去验证客户端请求里面带着的 token ，<strong>和数据库中的 token 进行对比</strong>，如果验证成功，就向客户端返回请求的数据</li>
</ul>
<p>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</p>
<p>基于 token 的用户认证是一种服务端无状态的认证方式，服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库。</p>
<p>token 完全由应用管理，所以它可以避开同源策略，也可以防止 CSRF 攻击。<strong>因为请求中发送 token，而不再是发送 cookie，即使说在客户端使用 cookie 存储 token，cookie 也只是一种存储机制，而不再是用于认证，所以相对比较安全</strong></p>
<h1 id="jwt-登录验证"><a href="#jwt-登录验证" class="headerlink" title="jwt 登录验证"></a>jwt 登录验证</h1><p>使用传统的token 进行身份验证，存在下面的缺点，就是<strong>服务端需要保存 token</strong>，以后用户再来访问的时候，需要携带token，然后再去数据库中获取token进行校验。</p>
<p>而使用JWT，是将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</p>
<p><strong>jwt 的身份认证流程</strong></p>
<ul>
<li>客户端输入账号密码进行登录，向服务端发送请求</li>
<li>如果用户登录成功，服务端使用密钥创建 JWT，然后将 JWT 返回给浏览器</li>
<li>在下一次浏览器向服务器发送请求的时候，将 JWT 一起发送给服务器</li>
<li>然后服务端检查 JWT 的签名，从 JWT 中获取用户的信息，检查通过则可以把响应发送给客户端</li>
</ul>
<p>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用 Bearer 模式添加 JWT，其内容看起来是下面这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure>

<p>JWT 原理：</p>
<p>JWT 生成的 token 是由三段字符串组成的，并且用.连接起来</p>
<ul>
<li>第一段字符串 header，内部包含加密算法/token 类型</li>
<li>第二段字符串 payload（可以为空），自定义值，比如用户 id，用户姓名，超时时间等用户非敏感的信息</li>
<li>第三段字符串：将前两段字符串使用明文拼接起来，然后对前两部分密文进行加密（加密算法可以自己定义）和加盐处理，然后再使用加密算法再对前两部分的密文再进行加密。</li>
</ul>
<p>以后用户再来访问的时候，都需要携带 token，然后后端需要对 token 进行检验</p>
<ul>
<li>第一步：获取 token，然后对 token 进行切割</li>
<li>第二步：对第二段进行解密，然后获取 payload 信息，检测 token 是否已经超时</li>
<li>第三步：把第一二段密文再进行拼接，再次执行加密，如果结果和传过来的密文一致，则说明 token 没有被修改过，则认证通过。</li>
</ul>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="使用-cookie-时需要考虑的问题"><a href="#使用-cookie-时需要考虑的问题" class="headerlink" title="使用 cookie 时需要考虑的问题"></a>使用 cookie 时需要考虑的问题</h2><ul>
<li>因为存储在客户端，容易被客户端篡改，使用前需要验证合法性</li>
<li>不要存储敏感数据，比如用户密码，账户余额</li>
<li>使用 httpOnly 在一定程度上提高安全性</li>
<li>尽量减少 cookie 的体积，能存储的数据量不能超过 4kb</li>
<li>设置正确的 domain 和 path，减少数据传输</li>
<li>cookie 无法跨域</li>
<li>一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie</li>
<li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</li>
</ul>
<h2 id="使用-session-时需要考虑的问题"><a href="#使用-session-时需要考虑的问题" class="headerlink" title="使用 session 时需要考虑的问题"></a>使用 session 时需要考虑的问题</h2><ul>
<li>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session</li>
<li>当网站采用集群部署的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。</li>
<li>当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。</li>
<li><strong>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？</strong> 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现</li>
<li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token。</li>
</ul>
<h2 id="使用-token-时需要考虑的问题"><a href="#使用-token-时需要考虑的问题" class="headerlink" title="使用 token 时需要考虑的问题"></a>使用 token 时需要考虑的问题</h2><ul>
<li>如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。</li>
<li>token 完全由应用管理，所以它可以避开同源策略</li>
<li>token 可以避免 CSRF 攻击(因为不需要 cookie 了)</li>
<li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</li>
</ul>
<h2 id="使用-JWT-时需要考虑的问题"><a href="#使用-JWT-时需要考虑的问题" class="headerlink" title="使用 JWT 时需要考虑的问题"></a>使用 JWT 时需要考虑的问题</h2><ul>
<li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）<br>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li>
<li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li>
<li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li>
<li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li>
<li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li>
<li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。<br>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li>
</ul>
<h2 id="使用加密算法时需要考虑的问题"><a href="#使用加密算法时需要考虑的问题" class="headerlink" title="使用加密算法时需要考虑的问题"></a>使用加密算法时需要考虑的问题</h2><ul>
<li>绝不要以明文存储密码</li>
<li><strong>永远使用 哈希算法 来处理密码，绝不要使用 Base64 或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码。</strong>编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道， 这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希这种说法， 但是编码就存在解码，加密就存在解密。</li>
<li>绝不要使用弱哈希或已被破解的哈希算法，像 MD5 或 SHA1 ，只使用强密码哈希算法。</li>
<li>绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样。如果你需要 “忘记密码” 的功能，可以随机生成一个新的 一次性的（这点很重要）密码，然后把这个密码发送给用户。</li>
</ul>
<h2 id="只要关闭浏览器-，session-真的就消失了？"><a href="#只要关闭浏览器-，session-真的就消失了？" class="headerlink" title="只要关闭浏览器 ，session 真的就消失了？"></a>只要关闭浏览器 ，session 真的就消失了？</h2><p>不对。对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 log off 的时候发个指令去删除 session。<br>然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session id 就消失了，再次连接服务器时也就无法找到原来的 session。<br>如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。<strong>恰恰是由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。</strong></p>
<h1 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p>
<p>SSO一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证。</p>
<p>大概流程就是这样</p>
<ul>
<li><p>用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将<strong>自己的地址</strong>作为参数</p>
</li>
<li><p>sso认证中心发现用户未登录，将用户引导至登录页面</p>
</li>
<li><p>用户输入用户名密码提交登录申请</p>
</li>
<li><p>sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌</p>
</li>
<li><p>sso认证中心带着令牌跳转会最初的请求地址（系统1）</p>
</li>
<li><p>系统1拿到令牌，去sso认证中心校验令牌是否有效</p>
</li>
<li><p>sso认证中心校验令牌，返回有效，注册系统1</p>
</li>
<li><p>系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源</p>
</li>
<li><p>用户访问系统2的受保护资源</p>
</li>
<li><p>系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</p>
</li>
<li><p>sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌</p>
</li>
<li><p>系统2拿到令牌，去sso认证中心校验令牌是否有效</p>
</li>
<li><p>sso认证中心校验令牌，返回有效，注册系统2</p>
</li>
<li><p>系统2使用该令牌创建与用户的局部会话，返回受保护资源</p>
</li>
</ul>
<p>用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系</p>
<ul>
<li><p>局部会话存在，全局会话一定存在</p>
</li>
<li><p>全局会话存在，局部会话不一定存在</p>
</li>
<li><p>全局会话销毁，局部会话必须销毁</p>
</li>
</ul>
<p>总结：</p>
<ul>
<li>SSO系统生成一个token，并将用户信息存到Redis中，并设置过期时间</li>
<li>其他系统请求SSO系统进行登录，得到SSO返回的token，写到Cookie中</li>
<li>每次请求时，Cookie都会带上，拦截器得到token，判断是否已经登录<br>（关于cookie跨域的问题，多个域名共享Cookie，在写到客户端的时候设置Cookie的domain。）</li>
</ul>
<h2 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h2><p>现在我们有两个系统，分别是 <code>www.java3y.com</code> 和 <code>www.java4y.com</code> ，一个SSO<code>www.sso.com</code></p>
<p>首先，用户想要访问系统A <code>www.java3y.com</code>受限的资源(比如说购物车功能，购物车功能需要登录后才能访问)，系统A <code>www.java3y.com</code> 发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：</p>
<p><code>www.sso.com?service=www.java3y.com</code></p>
<p>sso认证中心发现用户未登录，将用户引导至登录页面，用户进行输入用户名和密码进行登录，用户与认证中心建立全局会话（生成一份Token，写到Cookie中，保存在浏览器上）</p>
<p>随后，认证中心重定向回系统A，并把Token携带过去给系统A，重定向的地址如下：</p>
<p><code>www.java3y.com?token=xxxxxxx</code></p>
<p>接着，系统A去sso认证中心验证这个Token是否正确，如果正确，则系统A和用户建立局部会话（创建Session）。到此，系统A和用户已经是登录状态了。</p>
<p>此时，用户想要访问系统B <code>www.java4y.com</code> 受限的资源(比如说订单功能，订单功能需要登录后才能访问)，系统B <code>www.java4y.com</code> 发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：</p>
<p><code>www.sso.com?service=www.java4y.com</code></p>
<p>注意，因为之前用户与认证中心<a target="_blank" rel="noopener" href="http://www.sso.com已经建立了全局会话(当时已经把cookie保存到浏览器上了),所以这次系统b重定向到认证中心/">www.sso.com已经建立了全局会话（当时已经把Cookie保存到浏览器上了），所以这次系统B重定向到认证中心</a> <code>www.sso.com</code> 是可以带上Cookie的。<br>认证中心根据带过来的Cookie发现已经与用户建立了全局会话了，认证中心重定向回系统B，并把Token携带过去给系统B，重定向的地址如下：</p>
<p><code>www.java4y.com?token=xxxxxxx</code></p>
<p>接着，系统B去sso认证中心验证这个Token是否正确，如果正确，则系统B和用户建立局部会话（创建Session）。到此，系统B和用户已经是登录状态了。</p>
<p>看到这里，其实SSO认证中心就类似一个中转站。</p>
<h2 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a>代码实现思路</h2><ol>
<li><p>新建一个SSO的类,这个类有baseUrL的属性,因为每次验证都需要传过来一个地址。</p>
</li>
<li><p>然后SSO类主要存在以下两个个方法。</p>
</li>
</ol>
<ul>
<li><p>验证TGT(Ticket Grangting Ticket)是否有效,如果有效,则可以证明用户在CAS成功登录过(用来判断是否登陆过)。</p>
</li>
<li><p>验证Service ticket(ST),务票据，服务的惟一标识码 , 由 CASServer 发出（ Http 传送），用户访问Service时，service发现用户没有ST，则要求用户去CAS获取ST.用户向CAS发出获取ST的请求，CAS发现用户有TGT，则签发一个ST，返回给用户。用户拿着ST去访问service，service拿ST去CAS验证，验证通过后，允许用户访问资源。</p>
</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e055d9ef265da33997a42cc">傻傻分不清之 Cookie、Session、Token、JWT</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/25/css/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/08/25/css/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">移动端常见问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-25 20:29:25" itemprop="dateCreated datePublished" datetime="2019-08-25T20:29:25+08:00">2019-08-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="300毫秒延迟的由来和解决方法"><a href="#300毫秒延迟的由来和解决方法" class="headerlink" title="300毫秒延迟的由来和解决方法"></a>300毫秒延迟的由来和解决方法</h1><ol>
<li><p>300 毫秒延迟的主要原因是解决双击缩放。双击缩放，顾名思义，即用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 那么这和 300 毫秒延迟有什么联系呢？ 假定这么一个场景。用户在 iOS Safari 里边点击了一个链接。由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。 <strong>鉴于iPhone的成功，其他移动浏览器都复制了 iPhone Safari 浏览器的多数约定，包括双击缩放，几乎现在所有的移动端浏览器都有这个功能。</strong></p>
</li>
<li><p>解决方案</p>
</li>
</ol>
<ul>
<li>粗暴型，禁用缩放，添加viewport meta标签</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用fastclick</li>
</ul>
<p>移动端事件触发顺序：在移动端，手指点击一个元素，会经过：touchstart –&gt; touchmove -&gt; touchend –&gt;click。</p>
<p>fastclick.js的原理是：FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即触发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉。</p>
<h1 id="SPA单页面应用优化"><a href="#SPA单页面应用优化" class="headerlink" title="SPA单页面应用优化"></a>SPA单页面应用优化</h1><ol>
<li>SSR服务端渲染直出</li>
</ol>
<p>服务端渲染主要有两个目的，一是 SEO，二是加快内容展现。<br>在带来这两个好处的同时，<strong>我们也需要评估服务端渲染的成本，首先我们需要服务端的支持，因此涉及到了服务构建、部署等，同时 web 项目是一个流量较大的网站，也需要考虑服务器的负载，以及相应的缓存策略，</strong>特别像我们行业，由于地理位置的不同，不同用户看到的页面也是不一样的，也就是所谓的千人千面，这也为缓存造成了一定困难。</p>
<p>ssr是Server-Side Rendering的简写，即由服务端负责渲染页面直出，亦即同构应用。程序的大部分代码都可以在服务端和客户端运行。在服务端vue组件渲染为html字符串，然后直接返回给客户端，在客户端生成dom和操作dom。</p>
<p>能在服务端渲染为html字符串得益于vue组件结构是基于vnode的。vnode是dom的抽象表达，它不是真实的dom，它是由js对象组成的树，每个节点代表了一个dom。因为vnode，所以在服务端vue可以把js对象解析为html字符串。同样在客户端vnode因为是存在内存之中的，操作内存总比操作dom快的多，每次数据变化需要更新dom时，新旧vnode树经过diff算法，计算出最小变化集，大大提高了性能。</p>
<p><strong>服务端渲染 SSR 的优缺点如下：</strong></p>
<p>(1) 服务端渲染的优点：</p>
<ul>
<li><p>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面</p>
</li>
<li><p>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间</p>
</li>
</ul>
<p>(2) 服务端渲染的缺点：</p>
<ul>
<li><p>更多的开发条件限制： <strong>例如服务端渲染只支持 beforCreate 和 created 两个钩子函数</strong>，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境</p>
</li>
<li><p>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p>
</li>
</ul>
<ol start="2">
<li>使用预渲染</li>
</ol>
<p>所谓预渲染，就是在项目的构建过程中，通过一些渲染机制，比如 puppeteer或者 jsdom 将页面在构建的过程中就渲染好，然后插入到 html 中，这样在页面启动之前首先看到的就是预渲染的页面了</p>
<p>预渲染渲染的页面数据是在构建过程中就已经打包到了 html 中， 当真实访问页面的时候，真实数据可能已经和预渲染的数据有了很大的出入，而且预渲染的页面也是一个不可交互的页面，在页面没有启动之前，用户无法和预渲染的页面进行任何交互，预渲染页面中的数据反而会影响到用户获取真实的信息，当涉及到一些价格、金额、地理位置的地方甚至会导致用户做出一些错误的决定。</p>
<p>预渲染虽然可以提⾼⻚⾯的加载速度，但是要确保该⻚⾯百分百会被⽤户在之后打开，否则就⽩⽩浪费资源去渲染</p>
<ol start="3">
<li>使用骨架图</li>
</ol>
<p>因为移动端经常要考虑到用户的网络问题，如果网络慢的话对于用户的体验是非常差的，那我们就必须在这个基础上进行优化。举个常见的场景就是首页有个轮播图，在网络慢的情况下，很有可能是轮播图下面的其他区域内容先渲染出来，等到几秒过后，本来应该是在中间的区域，会先在顶部渲染出来，然后等到轮播图渲染出来之后，再被挤到原来的区域，所以用户视觉上会有一个页面抖动的情况，这种情况当然是要避免出现的。所以最好的话，可以提前给每一个区域占个坑。最简单的实现方式就是通过CSS来实现，需要先根据设计稿，计算出宽高比，使用padding-bottom，然后再加上个灰色的背景颜色。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">	<span class="attribute">overflow</span>: hidden;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">padding-bottom</span>: <span class="number">30%</span>;</span><br><span class="line">	<span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然还有其他的实现思路，比如说使用骨架屏<br>骨架屏个人理解就是特殊的loading，但是体验比普通loading一直转圈圈好很多，可以让用户能够感知到即将加载页面的基本 CSS 样式和页面布局。</p>
<p>比如每次饿了么点外卖的时候网络不好，或者登录掘金论坛的时候，可能首先渲染出来的时候是屏幕填了一个个的坑，显示出了页面的大概布局应该就是用的骨架屏原理，但是使用注意保证骨架屏图片体积尽可能小，因为要保证以最快的时间加载出来，而且打入本地app<br>如果说使用vue开发的话，也可以直接也可以使用插件vue-skeleton-webpack-plugin</p>
<ul>
<li>webpack.dev.conf.js和webpack.prod.conf.js中引入插件</li>
<li>创建骨架屏组件 src/skeleton.vue</li>
<li>创建骨架屏组件的入口文件src/entry-skeleton.js</li>
</ul>
<ol start="4">
<li>使用offline-plugin搭配webpack轻松实现PWA进行优化</li>
</ol>
<p>使用PWA的离线缓存，类似于HTTP cache缓存，但是相对来说缓存更可控。</p>
<h1 id="科普PWA"><a href="#科普PWA" class="headerlink" title="科普PWA"></a>科普PWA</h1><p>PWA(Progressive web apps, 渐进式Web应用)</p>
<ul>
<li>可以生成桌面小图标，不需要打开浏览器，方便用户访问</li>
<li>通过网络缓存提升页面访问速度，达到渐进式的页面甚至离线访问，提升用户体验</li>
<li>实现类似app的推送功能，生成系统通知推送给用户</li>
</ul>
<p>service worker是实现PWA的核心，service worker是一个独立的浏览器线程，不会对当前程序的执行线程造成阻塞，通过service worker可以实现页面离线访问、用户消息推送等功能。<br>使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p>
<p>Service Worker 实现缓存功能一般分为三个步骤：</p>
<ul>
<li>首先需要先注册 Service Worker</li>
<li>然后监听到 install 事件以后就可以缓存需要的文件</li>
<li>下次用户访问的时候就可以通过<strong>拦截请求的方式</strong>查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据</li>
</ul>
<p>PWA确实是当下很热门的技术，因为它提升了web应用的体验，甚至达到可以和原生app体验相提并论，但是它的问题就是兼容性问题，相信如果兼容性问题得到解决，这种技术一定会被大面积推广到实际应用。iOS11.3之前都不支持，因此vue cli3脚手架在集成时默认在ios下是关闭的</p>
<h1 id="移动端资源压缩"><a href="#移动端资源压缩" class="headerlink" title="移动端资源压缩"></a>移动端资源压缩</h1><p>我们常将网络性能优化措施归结为三大方面：减少请求数、减小请求资源体积、提升网络传输速率。</p>
<ol>
<li>JS 压缩</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">        minimizer: [</span><br><span class="line">            <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">                cache: <span class="literal">true</span>,</span><br><span class="line">                parallel: <span class="literal">true</span>,</span><br><span class="line">                sourceMap: <span class="literal">true</span> <span class="comment">// set to true if you want JS source maps</span></span><br><span class="line">            &#125;),</span><br><span class="line">            ...Plugins</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>HTML 压缩：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: __dirname + <span class="string">&#x27;/views/index.html&#x27;</span>, <span class="comment">// new 一个这个插件的实例，并传入相关的参数</span></span><br><span class="line">            filename: <span class="string">&#x27;../index.html&#x27;</span>,</span><br><span class="line">            minify: &#123;</span><br><span class="line">                removeComments: <span class="literal">true</span>,</span><br><span class="line">                collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">                removeRedundantAttributes: <span class="literal">true</span>,</span><br><span class="line">                useShortDoctype: <span class="literal">true</span>,</span><br><span class="line">                removeEmptyAttributes: <span class="literal">true</span>,</span><br><span class="line">                removeStyleLinkTypeAttributes: <span class="literal">true</span>,</span><br><span class="line">                keepClosingSlash: <span class="literal">true</span>,</span><br><span class="line">                minifyJS: <span class="literal">true</span>,</span><br><span class="line">                minifyCSS: <span class="literal">true</span>,</span><br><span class="line">                minifyURLs: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            chunksSortMode: <span class="string">&#x27;dependency&#x27;</span></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>提取公共资源：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123; <span class="comment">// 抽离第三方插件</span></span><br><span class="line">          test: <span class="regexp">/node_modules/</span>, <span class="comment">// 指定是 node_modules 下的第三方包</span></span><br><span class="line">          chunks: <span class="string">&#x27;initial&#x27;</span>,</span><br><span class="line">          name: <span class="string">&#x27;common/vendor&#x27;</span>, <span class="comment">// 打包后的文件名，任意命名    </span></span><br><span class="line">          priority: <span class="number">10</span> <span class="comment">// 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包</span></span><br><span class="line">        &#125;,</span><br><span class="line">        utils: &#123; <span class="comment">// 抽离自定义公共代码</span></span><br><span class="line">          test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          chunks: <span class="string">&#x27;initial&#x27;</span>,</span><br><span class="line">          name: <span class="string">&#x27;common/utils&#x27;</span>,</span><br><span class="line">          minSize: <span class="number">0</span> <span class="comment">// 只要超出 0 字节就生成一个新包</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>提取 css 并压缩：</li>
</ol>
<p>在使用 webpack 的过程中，我们通常会以模块的形式引入 css 文件（webpack 的思想不就是万物皆模块嘛），但是在上线的时候，我们还需要将这些 css 提取出来，并且压缩，这些看似复杂的过程只需要简单的几行配置就行：<br>（PS: 我们需要用到mini-css-extract-plugin ，所以还得大家自行 npm install）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [..., &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                _mode === <span class="string">&#x27;development&#x27;</span> ? <span class="string">&#x27;style-loader&#x27;</span> : MiniCssExtractPlugin.loader, &#123;</span><br><span class="line">                    loader: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        importLoaders: <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        ident: <span class="string">&#x27;postcss&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>将 webpack 开发环境修改为生产环境：</li>
</ol>
<p>在使用 webpack 打包项目时，它常常会引入一些调试代码，以作相关调试，我们在上线时不需要这部分内容，通过配置剔除：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool: <span class="string">&#x27;false&#x27;</span></span><br></pre></td></tr></table></figure>

<p>最后，我们还应该在服务器上开启 Gzip 传输压缩，它能将我们的文本类文件体积压缩至原先的四分之一，效果立竿见影，还是切换到我们的 nginx 配置文档，添加如下两项配置项目：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip on;</span><br><span class="line">gzip_types text/plain application/javascriptapplication/x-javascripttext/css application/xml text/javascriptapplication/x-httpd-php application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml;</span><br></pre></td></tr></table></figure>

<p><strong>特别注意！不要对图片文件进行 Gzip 压缩！</strong></p>
<ol start="6">
<li>使用雪碧图</li>
</ol>
<p>雪碧图的概念大家一定在生活中经常听见，其实雪碧图是减小请求数的显著运用。而且很奇妙的是，多张图片拼在一块后，总体积会比之前所有图片的体积之和小（你可以亲自试试）。这里给大家推荐一个自动化生成雪碧图的工具：<a target="_blank" rel="noopener" href="https://www.toptal.com/developers/css/sprite-generator">https://www.toptal.com/developers/css/sprite-generator</a></p>
<p>只要你添加相关资源文件，他就会自动帮你生成雪碧图以及对应的 CSS 样式。</p>
<p>优点：</p>
<ul>
<li>减少HTTP 请求数，极大地提高页面加载速度</li>
<li>增加图片信息的重复度，提高压缩比，减少图片大小</li>
</ul>
<p>缺点：</p>
<ul>
<li>图片合并麻烦，如果雪碧图无法加载则会导致整个页面出现显示问题，所以必须控制雪碧图大小不能太大</li>
<li>维护麻烦，修改一个图片可能需要重新布局整个图片、样式</li>
</ul>
<ol start="7">
<li>使用字体图标（iconfont）</li>
</ol>
<p>无论是压缩后的图片，还是雪碧图，终归还是图片，只要是图片，就还是会占用大量网络传输资源。但是字体图标的出现，却让前端开发者看到了另外一个神奇的世界。（iconfont本身是基于SVG的，只适用一些相对简单的业务场景）</p>
<p>我最喜欢用的是阿里矢量图标库（网址：<code>http://www.iconfont.cn/</code>），里面有大量的矢量图资源，而且你只需要像在淘宝采购一样把他们添加至购物车就能把它们带回家，整理完资源后还能自动生成CDN 链接，可以说是完美的一条龙服务了。（图片来自官网首页）</p>
<p>图片能做的很多事情，矢量图都能作，<strong>而且它只是往 HTML 里插入字符和 CSS 样式而已，和图片请求比起来资源占用完全不在一个数量级，</strong>如果你的项目里有小图标，就使用矢量图吧。</p>
<h1 id="1像素边框问题"><a href="#1像素边框问题" class="headerlink" title="1像素边框问题"></a>1像素边框问题</h1><p><strong>物理像素</strong></p>
<p>移动设备出厂时，不同设备自带的不同像素，也称硬件像素；</p>
<p><strong>逻辑像素</strong></p>
<p>即css中像素，和设备屏幕的像素没有必然的关系</p>
<p><strong>dpr(devicePixelRatio)设备像素比</strong></p>
<p>dpr = 物理像素 / 分辨率</p>
<p><strong>在不缩放的情况下，一个css像素就对应一个dpr</strong></p>
<p>css像素 = 物理像素 / dpr</p>
<p>为什么移动端CSS里面写了1px，实际上看起来比1px粗；了解设备物理像素和逻辑像素的同学应该很容易理解，其实这两个px的含义其实是不一样的，UI设计师要求的1px是指设备的物理像素1px，而CSS里记录的像素是逻辑像素，它们之间存在一个比例关系，可以用javascript中的window.devicePixelRatio来获取，也可以用媒体查询的-webkit-min-device-pixel-ratio来获取。</p>
<p>当然，比例多少与设备相关。</p>
<p>在手机上border无法达到我们想要的效果。这是因为devicePixelRatio特性导致，iPhone的devicePixelRatio==2，而border-width: 1px描述的是设备独立像素，所以，border被放大到物理像素2px显示，在iPhone上就显得较粗。</p>
<p>解决方法：</p>
<ol>
<li>使用 border-image</li>
</ol>
<p>缺点：需要再单独制作图片，并且圆角可能出现模糊</p>
<ol start="2">
<li> viewport + rem + js方案</li>
</ol>
<p>整体思路就是利用viewport + rem + js 动态的修改页面的缩放比例，实现小于1像素的显示。在页面初始化时，在头部引入原始默认状态如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">id</span>=<span class="string">&quot;WebViewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来的任务就是js的动态修改缩放比 以及 实现rem根元素字体大小的设置:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> viewport = <span class="built_in">document</span>.querySelector(<span class="string">&quot;meta[name=viewport]&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.devicePixelRatio == <span class="number">1</span>) &#123;</span><br><span class="line">    viewport.setAttribute(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&#x27;</span>)</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.devicePixelRatio == <span class="number">2</span>) &#123;</span><br><span class="line">    viewport.setAttribute(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&#x27;</span>)</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.devicePixelRatio == <span class="number">3</span>) &#123;</span><br><span class="line">    viewport.setAttribute(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;width=device-width, initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no&#x27;</span>)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> docEl = <span class="built_in">document</span>.documentElement;</span><br><span class="line"><span class="keyword">var</span> fontsize = <span class="number">10</span> * (docEl.clientWidth / <span class="number">320</span>) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">docEl.style.fontSize = fontsize;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>媒体查询 + 伪类 + transform（推荐）</li>
</ol>
<p>在以上的用法中，无非逃不开一种思想，就是将1px缩小为0.5px来展示，</p>
<p>然而,0.5px并不是所有的设备或浏览器都支持，就考虑用媒体查询或viewport将其缩放比例。其实1像素问题的产生基本发生在设置边框或分割线的时候，场景并不覆盖全局样式，因此，直接缩放需要设置的元素，才是我们真正需要的。</p>
<p>tranform就能实现这个需求。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 2倍屏 */</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">2.0</span>) &#123;</span><br><span class="line">    <span class="selector-class">.border-bottom</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">        -webkit-<span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3倍屏 */</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">3.0</span>) &#123;</span><br><span class="line">    <span class="selector-class">.border-bottom</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">        -webkit-<span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.33</span>);</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.33</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>PS：使用rem布局时，个人习惯将字体设置为50px(浏览器默认是16px)，这样在换算成rem单位的时候，就可以直接乘以0.2就好了。（50px换算成10rem）；另外也可以将默认字体设置为62.5%，这样在换算单位的时候，就可以将1rem换算为10px。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5bcc169ae51d450e85308d86">首页白屏的引发的思考(一)</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247489586&idx=1&sn=2168d42df837521da50b3ed7f8932698&chksm=f951ad71ce262467728b7940de1a2311c523f264f4ca7e705712bf655a844fab93706cbe1ca3&token=1792152421&lang=zh_CN#rd">首屏时间从12.67s到1.06s，我是如何做到的？</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/21/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/ajax%E3%80%81axios%E3%80%81fetch%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/08/21/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/ajax%E3%80%81axios%E3%80%81fetch%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">ajax、axios、fetch的区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-21 11:43:20" itemprop="dateCreated datePublished" datetime="2019-08-21T11:43:20+08:00">2019-08-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Ajax/" itemprop="url" rel="index"><span itemprop="name">Ajax</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>背景</strong></p>
<p>前端的技术发展速度非常的快，异步请求也是其重要的体现之一，从最早的原生XHR，再到JqueryAjax的统治时代，再到近来，fetch、axios等技术也开始出现并大量投入使用。</p>
<h1 id="原生Ajax"><a href="#原生Ajax" class="headerlink" title="原生Ajax"></a>原生Ajax</h1><p>Ajax是指一种<strong>创建交互式网页应用</strong>的网页开发技术，并且可以做到无需重新加载整个网页的情况下，能够更新部分网页，也叫作局部更新。是最早出现的发送后端请求技术，隶属于原始js中，核心是使用XMLHttpRequest对象，多个请求之间如果有先后关系的话，就会出现回调地狱。</p>
<p><strong>使用步骤：</strong></p>
<ol>
<li>创建XmlHttpRequest对象</li>
<li>调用open方法设置基本请求信息</li>
<li>设置发送的数据，发送请求（send）</li>
<li>注册监听的回调函数（onreadystatechange）</li>
<li>拿到返回值，对页面进行更新</li>
</ol>
<p><strong>状态值：</strong></p>
<p>0    请求还未初始化，还未调用open()          —-未初始化<br>1    请求已建立但未发送，还未调用send()       —-载入<br>2    接受原始响应数据，为解析做准备            —-载入完成<br>3    正在解析数据                             —-解析<br>4    响应完成，数据解析完成                     —-解析完成</p>
<p><strong>优点：可以实现局部刷新，并且原生支持不需要使用任何插件</strong></p>
<p><strong>缺点：可能破坏浏览器后退功能，并且会出现回调地狱</strong></p>
<h1 id="Jquery-Ajax"><a href="#Jquery-Ajax" class="headerlink" title="Jquery Ajax"></a>Jquery Ajax</h1><p>jquery的ajax就是在原生的ajax的基础上进行了封装，并且添加上了对JSONP的支持。</p>
<p>优点：</p>
<ul>
<li>使用方便</li>
</ul>
<p>缺点：</p>
<ul>
<li>本身是针对mvc的编程模式，不太适合目前mvvm的编程模式</li>
<li>基于原⽣的 XHR 开发， XHR 本身的架构不清晰，已经有了 fetch 的替代⽅案 </li>
<li>jQuery本身比较大，如果单纯的使用ajax可以自己封装一个，不然会影响性能体验</li>
<li>回调地狱</li>
</ul>
<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>axios 是 vue 官方推荐使用的一个库，<strong>axios 一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生 XHR 的封装，只不过它是 Promise 的实现版本，</strong>不是原生js,使用时需要对其进行安装，符合最新的ES规范，它本身具有以下优点：</p>
<ul>
<li>支持 Promise API</li>
<li>客户端支持防止CSRF</li>
<li>自动转换JSON数据</li>
<li>从 node.js 创建 http 请求</li>
<li>拦截请求和响应</li>
<li>从浏览器中创建 XMLHttpReques</li>
</ul>
<p>PS:防止 CSRF :就是让你的每个请求都带一个从 cookie 中拿到的 key, 根据浏览器同源策略，假冒的网站是拿不到你 cookie 中得 key 的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。</p>
<h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><p>fetch 号称是 AJAX 的替代品，是在 ES6 出现的，使用了 ES6 中的 promise 对象。Fetch 是基于 promise 设计的。fetch 不是 ajax 的进一步封装，而是原生 js，没有使用 XMLHttpRequest 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(url).then(fun2)</span><br><span class="line">        .then(fun3)</span><br><span class="line">        .....</span><br><span class="line">        .catch(fun)</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>解决回调地狱</li>
<li>使用起来更加简洁</li>
</ul>
<p>缺点：</p>
<ul>
<li>API 偏底层，需要封装</li>
<li>默认不带 Cookie，需要手动添加</li>
<li>浏览器支持情况不是很友好，需要第三方的ployfill</li>
<li>fetch 没有办法原⽣监测请求的进度，⽽XHR可以</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ajax 是最早出现发送后端请求的技术，属于原生 js 范畴,核心是使用 XMLHttpRequest 对象,使用较多并有先后顺序的话，容易产生回调地狱。</p>
<p>fetch 号称可以代替 ajax 的技术，是基于 es6 中的 Promise 对象设计的，参数和 jQuery 中的 ajax 类似，它并不是对 ajax 进一步封装，它属于原生 js 范畴。没有使用 XMLHttpRequest 对象。</p>
<p>axios 不是原生 js,使用时需要对其进行安装，客户端和服务器端都可以使用，可以在请求和响应阶段进行拦截，基于 promise 对象。<br>axios 既提供了并发的封装，也没有 fetch 的各种问题，而且体积也较小，当之无愧现在最应该选用的请求的方式。这大概就是目前官方推荐使用 axios 的原因了吧。</p>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jennyya/article/details/83687622">ajax、fetch、axios区别</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8bc48f8fde75">ajax和axios、fetch的区别</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/vue/vue%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/27/vue/vue%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">vue常见面试题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-27 10:43:20" itemprop="dateCreated datePublished" datetime="2019-07-27T10:43:20+08:00">2019-07-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-14 23:00:06" itemprop="dateModified" datetime="2021-04-14T23:00:06+08:00">2021-04-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MVVM的理解"><a href="#MVVM的理解" class="headerlink" title="MVVM的理解"></a>MVVM的理解</h1><p>MVVM 模式，顾名思义即 Model-View-ViewModel 模式,是一个软件架构设计模式。</p>
<ol>
<li><p>Model 层: 对应数据层模型，它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。</p>
</li>
<li><p>View 层：作为视图模板存在，在 MVVM 里，整个 View 是一个动态模板。除了定义结构、布局外，它展示的是 ViewModel 层的数据和状态。View 层不负责处理状态，View 层做的是 数据绑定的声明、 指令的声明、 事件绑定的声明。</p>
</li>
<li><p>ViewModel 层(核心):MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，<strong>因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</strong> 这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。<br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/MVVM.png" alt="markdown"></p>
</li>
</ol>
<h2 id="MVVM的优缺点"><a href="#MVVM的优缺点" class="headerlink" title="MVVM的优缺点"></a>MVVM的优缺点</h2><p><strong>优点</strong></p>
<ol>
<li><p>分离视图（View）和模型（Model）,降低代码耦合，提高视图或者逻辑的重用性。</p>
</li>
<li><p>提高可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码</p>
</li>
<li><p>自动更新dom: 利用双向绑定,数据更新后视图自动更新，让开发者从繁琐的手动更新dom中解放</p>
</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><p>Bug很难被调试: 因为使用双向绑定的模式，当你看到界面异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的</p>
</li>
<li><p>一个大的模块中model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存</p>
</li>
<li><p>对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高</p>
</li>
</ol>
<h2 id="MVVM和MVC的区别是什么？与其他框架（jquery）的区别是什么？哪些场景适合？"><a href="#MVVM和MVC的区别是什么？与其他框架（jquery）的区别是什么？哪些场景适合？" class="headerlink" title="MVVM和MVC的区别是什么？与其他框架（jquery）的区别是什么？哪些场景适合？"></a>MVVM和MVC的区别是什么？与其他框架（jquery）的区别是什么？哪些场景适合？</h2><p>mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</p>
<p>区别：vue数据驱动，通过数据来显示视图层而不是节点操作。<br>场景：数据操作比较多的场景，更加便捷</p>
<h1 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h1><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是Vue的生命周期。</p>
<ol>
<li><p>beforeCreate:挂载元素el和数据对象都是为undefined<br>dom元素都没有被创建出来，在这个期间我们一般不做事情</p>
</li>
<li><p>created：挂载元素el未初始化，但是data和methods都已经被初始化好了（最重要）<br>数据和data中的数据绑定完成，这里我们可以做初级的数据获取，ajax请求最好放在created里面，因为此时已经可以访问this了，请求到数据就可以直接放在data里面。</p>
</li>
<li><p>beforeMount：挂载元素el和data已经初始化，但是此时是虚拟dom节点</p>
</li>
<li><p>mounted：Vue实例挂载完成，数据成功渲染（最重要）<br>官方实例的异步请求是在mounted生命周期中调用的，而实际上也可以在created生命周期中调用(推荐，因为在服务端并没有这个钩子)。</p>
</li>
</ol>
<p>只要执行完整个mounted，就表示整个Vue实例已经完成初始化。此时组件已经脱离了创建阶段，进入运行阶段<br>运行阶段的两个生命周期函数，这两个事件会根据data数据的改变，有选择性触发0到多次</p>
<ol start="5">
<li><p>beforeUpdate：表示界面还没有被更新，但是数据被更新了</p>
</li>
<li><p>update： 事件执行的时候，页面和data数据已经保持同步，都是最新的</p>
</li>
<li><p>beforeDestory：执行该函数的时候，实例身上的所有data和所有的methods以及过滤器、指令等等都处于可用状态，还没有真正执行销毁的过程</p>
</li>
</ol>
<p><strong>何时使用 beforeDestory</strong></p>
<ul>
<li>解绑自定义事件 event.$off</li>
<li>清除定时器</li>
<li>解绑自定义的 DOM 事件，比如 window scorrl 等</li>
</ul>
<ol start="8">
<li>执行到该函数的时候，组件中的而所有数据、方法、指令过滤器都不可用</li>
</ol>
<p>除了以上8个比较常见的生命周期之外，vue其实还有其他3个生命周期</p>
<p>如果我们在组件中使用了keep-alive用来缓存组件,避免多次加载相应的组件,减少性能消耗，那么这个时候生命周期会多出来两个，并且上面的8个生命周期钩子将会失效。</p>
<ol start="9">
<li><p>activated：被包裹的组件被激活的状态下使用的生命周期钩子。</p>
</li>
<li><p>deactivated：在被包裹的组件停止的时候停用。</p>
</li>
<li><p>errorCaptured: 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</p>
</li>
</ol>
<h1 id="v-show-与-v-if-有什么区别"><a href="#v-show-与-v-if-有什么区别" class="headerlink" title="v-show 与 v-if 有什么区别"></a>v-show 与 v-if 有什么区别</h1><ul>
<li><p>v-if 是真正的条件渲染，因为它会确保在切换过程中会<strong>触发销毁/挂载组件</strong>；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
</li>
<li><p>v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。DOM结构还是一直保留。</p>
</li>
</ul>
<p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>
<h1 id="Vue-的父组件和子组件生命周期钩子函数执行顺序"><a href="#Vue-的父组件和子组件生命周期钩子函数执行顺序" class="headerlink" title="Vue 的父组件和子组件生命周期钩子函数执行顺序"></a>Vue 的父组件和子组件生命周期钩子函数执行顺序</h1><p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>
<p>加载渲染过程<br>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
<p>子组件更新过程<br>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
<p>父组件更新过程<br>父 beforeUpdate -&gt; 父 updated</p>
<p>销毁过程<br>父 beforeDestory -&gt; 子 beforeDestory -&gt; 子 destroyed -&gt; 父 destroyed</p>
<h1 id="Vue组件之间的通信"><a href="#Vue组件之间的通信" class="headerlink" title="Vue组件之间的通信"></a>Vue组件之间的通信</h1><ul>
<li><strong>props/$emit+v-on: 通过props将数据自上而下传递，而通过$emit和v-on来向上传递信息。</strong> （适用于父子组件之间的通信）</li>
<li>EventBus: 通过EventBus进行信息的发布与订阅</li>
<li><strong>vuex: 是全局数据管理库，可以通过vuex管理全局的数据流</strong></li>
<li>$attrs/$listeners: Vue2.4中加入的$attrs/$listeners可以进行跨级的组件通信 （适用于 隔代组件通信）</li>
<li>provide/inject：祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。（适用于 隔代组件通信）</li>
</ul>
<h1 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h1><p>单向数据流指只能从一个方向修改数据，姑且我们可以这样理解，如下图所示。一个父组件下有两个子组件1和子组件2，父组件可以向子组件传递数据。假如子组件都获取到了父组件的name，在子组件1中对name重新修改之后，子组件2和父组件中的值并不会发生改变，这正是因为Vue中的机制是单向数据流，子组件不能直接改变父组件的状态。但反过来，如果是父组件中的name修改了，当然两个子组件中的name也就改变了。</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/FtoC.png" alt="markdown"></p>
<h1 id="Vuex状态管理"><a href="#Vuex状态管理" class="headerlink" title="Vuex状态管理"></a>Vuex状态管理</h1><p>Vuex 是单向数据流的一种实现。</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/dangxiang.png" alt="markdown"></p>
<p>一个应用可以看作是由上面三部分组成: View, Actions,State,数据的流动也是从View =&gt; Actions =&gt; State =&gt;View 以此达到数据的单向流动。但是，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：</p>
<ul>
<li>多个视图依赖于同一状态。</li>
<li>来自不同视图的行为需要变更同一状态。</li>
</ul>
<p>当项目较大, 组件嵌套过多的时候,使用传参的方式会变得非常繁琐 多组件共享同一个State会在数据传递时出现很多问题.Vuex就是为了解决这些问题而产生的。<br>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。</p>
<ol>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。<br>主要包括以下几个模块：</li>
</ol>
<ul>
<li>State：存放基本数据，可以在这里设置默认的初始状态。用 this.$store.state 来访问。</li>
<li>Getters：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li>
<li>Mutations：是唯一更改 store 中状态的方法，且必须是同步函数。用 this.$store.commit(‘xxx’, data) 来通知 Mutations 来改状态。</li>
<li>Actions：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。用 this.$store.dispatch(‘xxx’, data) 来存触发 Action。</li>
<li>Modules：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中,模块化vuex。</li>
</ul>
<p><strong>完整流程：</strong></p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/vuex.png" alt="markdown"></p>
<p>Vuex原理<br>一个实例化的Vuex.Store由state, mutations和actions三个属性组成:</p>
<ul>
<li>state中保存着共有数据</li>
<li>改变state中的数据有且只有通过mutations中的方法,且mutations中的方法必须是同步的</li>
<li>如果要写异步的方法,需要些在actions中, 并通过commit到mutations中进行state中数据的更改</li>
</ul>
<h1 id="Vue实现双向数据绑定"><a href="#Vue实现双向数据绑定" class="headerlink" title="Vue实现双向数据绑定"></a>Vue实现双向数据绑定</h1><p>是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。在vue3.0中通过Proxy代理对象进行类似的操作。</p>
<p>Vue主要通过以下4个步骤实现双向数据绑定</p>
<ul>
<li>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</li>
<li>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</li>
<li>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</li>
<li>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</li>
</ul>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/observer.png" alt="markdown"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;数据绑定&quot;</span> id=<span class="string">&quot;dataBinding&quot;</span>&gt;</span><br><span class="line">&lt;span id=<span class="string">&quot;data&quot;</span>&gt;&lt;/span&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.showData()</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">  <span class="function"><span class="title">showData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj1 = &#123;&#125;;                        <span class="comment">//新建一个对象obj1</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj1,<span class="string">&#x27;hello&#x27;</span>,&#123;  <span class="comment">//为obj定义一个名为 hello 的访问器属性 </span></span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">&#x27;dataBinding&#x27;</span>).value = newVal;</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">&#x27;data&#x27;</span>).innerHTML = newVal;</span><br><span class="line">        &#125;,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;keyup&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        obj1.hello = e.target.value;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(obj1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="computed-和-watch-有什么区别"><a href="#computed-和-watch-有什么区别" class="headerlink" title="computed 和 watch 有什么区别?"></a>computed 和 watch 有什么区别?</h1><ul>
<li><strong>computed:</strong></li>
</ul>
<p>computed是计算属性,也就是计算值,它更多用于计算值的场景<br>computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算<br>computed适用于计算比较消耗性能的计算场景</p>
<ul>
<li><strong>watch:</strong></li>
</ul>
<p>更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作<br>无缓存性，页面重新渲染时值不变化也会执行。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;demo&quot;</span>&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Foo&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Bar&#x27;</span>,</span><br><span class="line">    fullName: <span class="string">&#x27;Foo Bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.fullName = val + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.fullName = <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>虽然说 methods 和 computed、watch 都可以完成相同的功能，但是需要根据不同的场景选择对应的方法，大多数场景下，使用 computed 属性，能够在简化代码的同时，提高性能。</p>
<p>小结:</p>
<ul>
<li>当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的</li>
</ul>
<h1 id="computed实现原理"><a href="#computed实现原理" class="headerlink" title="computed实现原理"></a>computed实现原理</h1><ul>
<li>初始化 data，使用 Object.defineProperty 将这些属性转化为 getter/setter</li>
<li>初始化 computed，遍历 computed 里面的每个属性，每一个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，然后使用 Object.defineProterty转化</li>
<li>Object.defineProterty 依赖收集，用于依赖发生变化的时候，触发属性重新计算</li>
<li>若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先计算其他的依赖收集</li>
</ul>
<h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><ol>
<li>什么是虚拟DOM</li>
</ol>
<p>虚拟DOM其实就是一个JavaScript对象。通过这个JavaScript对象来描述真实DOM。</p>
<ol start="2">
<li>为什么要使用虚拟DOM</li>
</ol>
<p>优点：</p>
<ul>
<li><p>保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此框架的虚拟 DOM至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；真实DOM的操作，一般都会对某块元素的整体重新渲染,采用虚拟DOM的话，当数据变化的时候，只需要局部刷新变化的位置就好了。</p>
</li>
<li><p>无需手动操作DOM: 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，极大提高开发效率</p>
</li>
<li><p>跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等</p>
</li>
</ul>
<p>缺点:</p>
<ul>
<li>无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化,比如VScode采用直接手动操作DOM的方式进行极端的性能优化</li>
</ul>
<h1 id="虚拟-DOM-的实现原理"><a href="#虚拟-DOM-的实现原理" class="headerlink" title="虚拟 DOM 的实现原理"></a>虚拟 DOM 的实现原理</h1><ul>
<li><p>用 JS 对象描述出 DOM 树的结构，然后在初始化构建中，用这个描述树去构建真正的 DOM，并实际展现到页面中</p>
</li>
<li><p>使用 diff 算法，当有数据状态变更时，重新构建一个新的 JS 的 DOM 树，通过新旧对比 DOM 树的变化 diff，<strong>并记录两棵树差异</strong></p>
</li>
<li><p>使用 patch 算法，将两个虚拟 DOM 对象的差异应用到真正的 DOM 树，视图也就更新了。所以虚拟 dom 的本质可以理解为在 JS 和 DOM 之间做了一个缓存。 </p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>vdom<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 20px&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>js 大概模拟 dom 结构</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tag: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">&#x27;container&#x27;</span>,</span><br><span class="line">    id: <span class="string">&#x27;box&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      tag: <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">      children: <span class="string">&#x27;vdom&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      tag: <span class="string">&#x27;ul&#x27;</span>,</span><br><span class="line">      props: &#123; <span class="attr">style</span>: <span class="string">&#x27;font-size: 20px&#x27;</span>&#125;,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          tag: <span class="string">&#x27;li&#x27;</span>,</span><br><span class="line">          children: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="如何理解Vue的响应式系统？"><a href="#如何理解Vue的响应式系统？" class="headerlink" title="如何理解Vue的响应式系统？"></a>如何理解Vue的响应式系统？</h1><p>响应式系统简述:</p>
<ul>
<li>任何一个 Vue Component 都有一个与之对应的 Watcher 实例。</li>
<li>Vue 的 data 上的属性会被object.defineProperty()添加 getter 和 setter 属性。</li>
<li>当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, <strong>getter 方法会被调用</strong> , 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)</li>
<li>data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新。</li>
</ul>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/vueWatcher.png" alt="markdown"></p>
<h1 id="谈谈你对-keep-alive-的了解？"><a href="#谈谈你对-keep-alive-的了解？" class="headerlink" title="谈谈你对 keep-alive 的了解？"></a>谈谈你对 keep-alive 的了解？</h1><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p>
<ul>
<li>一般结合路由和动态组件一起使用，用于缓存组件；</li>
<li>提供 include 和 exclude 属性(另外还有max参数，设置最大缓存组件的个数)，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，<strong>其中 exclude 的优先级比 include 高；</strong></li>
<li>对应两个生命周期钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li>
</ul>
<h1 id="组件中的data为什么是一个函数"><a href="#组件中的data为什么是一个函数" class="headerlink" title="组件中的data为什么是一个函数?"></a>组件中的data为什么是一个函数?</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// data</span></span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">	message: <span class="string">&quot;子组件&quot;</span>,</span><br><span class="line">	childName:<span class="built_in">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new Vue</span></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为<strong>组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响</strong>，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 <strong>new Vue 的实例，是不会被复用的</strong>，因此不存在引用对象的问题。</p>
<h1 id="vue-ssr-服务端渲染"><a href="#vue-ssr-服务端渲染" class="headerlink" title="vue-ssr 服务端渲染"></a>vue-ssr 服务端渲染</h1><p>ssr是Server-Side Rendering的简写，即由服务端负责渲染页面直出，亦即同构应用。程序的大部分代码都可以在服务端和客户端运行。在服务端vue组件渲染为html字符串，然后直接返回给客户端，在客户端生成dom和操作dom。</p>
<p>能在服务端渲染为html字符串得益于vue组件结构是基于vnode的。vnode是dom的抽象表达，它不是真实的dom，它是由js对象组成的树，每个节点代表了一个dom。因为vnode所以在服务端vue可以把js对象解析为html字符串。同样在客户端vnode因为是存在内存之中的，操作内存总比操作dom快的多（操作DOM会导致重排和重绘，重排会占用、消耗CPU; 重绘会占用、消耗GPU），每次数据变化需要更新dom时，新旧vnode树经过diff算法，计算出最小变化集，大大提高了性能。</p>
<p><strong>服务端渲染 SSR 的优缺点如下：</strong></p>
<p>(1) 服务端渲染的优点：</p>
<ul>
<li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面</li>
<li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间</li>
</ul>
<p>(2) 服务端渲染的缺点：</p>
<ul>
<li>更多的开发条件限制： <strong>例如服务端渲染只支持 beforCreate 和 created 两个钩子函数</strong>，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
<li>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。（在同构应用中，如果需要获取数据最好在mounted生命周期中异步加载数据，因为服务端渲染只支持 beforCreate 和 created 两个钩子函数，如果放在created生命周期中，有可能会影响SSR的构建）</li>
</ul>
<h1 id="vue-router-路由模式有几种？"><a href="#vue-router-路由模式有几种？" class="headerlink" title="vue-router 路由模式有几种？"></a>vue-router 路由模式有几种？</h1><p>vue-router 有 3 种路由模式：hash、history、abstract</p>
<ul>
<li>hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li>
<li>history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li>
<li>abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。</li>
</ul>
<p><strong>配置 Vue-router 异步加载</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">      component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(</span><br><span class="line">        <span class="string">&#x27;../components/index&#x27;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="router的实现原理"><a href="#router的实现原理" class="headerlink" title="router的实现原理"></a>router的实现原理</h1><p><strong>更新视图而不重新请求页面</strong>,vue-router在实现单页面前端路由时，提供了两种方式：Hash模式和History模式；根据mode参数来决定采用哪一种方式。</p>
<ol>
<li>Hash模式：</li>
</ol>
<p>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。 hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说hash 出现在 URL 中，但<strong>不会被包含在 http 请求中，对后端完全没有影响</strong>，因此改变 hash 不会重新加载页面；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。hash 模式的原理是 **onhashchange 事件(监测hash值变化)**，可以在 window 对象上监听这个事件，从而进行页面的跳转和渲染</p>
<ol start="2">
<li>History模式：</li>
</ol>
<p>由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入”mode: ‘history’，不过这种模式需要后台再进行配置，如果后台配置不正确，访问页面则会返回404错误。HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p>
<p>history 路由模式的实现主要基于存在下面几个特性：</p>
<ul>
<li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li>
<li>我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li>
<li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li>
</ul>
<ol start="3">
<li>vue-router的使用方式</li>
</ol>
<ul>
<li>npm i vue-router -S下载路由</li>
<li>在main.js中引入 import VueRouter from ‘vue-router’;</li>
<li>安装插件Vue.use(VueRouter);</li>
<li>创建路由对象并配置路由规则 let router = new VueRouter({routes:[{path:’/home’,component:Home}]});</li>
<li>将其路由对象传递给Vue的实例，options中加入 router:router</li>
<li>在app.vue中留坑 <router-view></router-view><br>（router-view即页面中需要切换的部分）</li>
</ul>
<ol start="4">
<li>hash 和 history 两种模式的优缺点</li>
</ol>
<p><strong>hash优点：</strong></p>
<ul>
<li>兼容性比较好，兼容性达到了ie8</li>
<li>绝大数框架的框架都基本支持hash路由方式</li>
<li>除了会发送ajax和资源加载之外不会发送其他请求</li>
<li>不需要在服务端进行任何设置和开发</li>
</ul>
<p><strong>hash缺点：</strong></p>
<ul>
<li>服务端无法准确捕获路由的信息</li>
<li>对于需要锚点功能的需求会与当前路由机制发生冲突</li>
<li>对于需要重定向的操作，后端无法获取url全部内容，导致后台无法得到url数据，典型的例子就是微信公众号的oauth验证</li>
</ul>
<p><strong>history优点：</strong></p>
<ul>
<li>当发生路由重定向时不会丢失url数据 ，后端也可以拿到这个数据</li>
<li>当然，绝大多数框架一样实现了 browser路由的方式</li>
<li>后端可以准确追踪到路由</li>
<li>可以使用history.state获取路由的信息</li>
</ul>
<p><strong>history缺点：</strong></p>
<ul>
<li><p>兼容性不如hash 。兼容性只到ie10</p>
</li>
<li><p>需要后端支持，每次返回html文档</p>
</li>
</ul>
<h1 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h1><p>有的时候，我们需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。</p>
<p>为此我们有很多种方法可以植入路由的导航过程：<strong>全局的, 单个路由独享的, 或者组件级的</strong></p>
<h2 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h2><ul>
<li>router.beforeEach 全局前置守卫 进入路由之前</li>
<li>router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用</li>
<li>router.afterEach 全局后置钩子 进入路由之后</li>
</ul>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js 入口文件</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span>; <span class="comment">// 引入路由</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123; </span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">router.beforeResolve(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;afterEach 全局后置钩子&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>to,from,next 这三个参数：</p>
<p>to和from是将要进入和将要离开的路由对象,路由对象指的是平时通过this.$route获取到的路由对象。</p>
<p>next:Function 这个参数是个函数，且必须调用，否则不能进入路由(页面空白)。</p>
<ul>
<li><p>next() 进入该路由。</p>
</li>
<li><p>next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。</p>
</li>
<li><p>next 跳转新路由，当前的导航被中断，重新开始一个新的导航。</p>
</li>
</ul>
<h2 id="路由独享守卫"><a href="#路由独享守卫" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h2><p>beforeEnter</p>
<p>如果你不想全局配置守卫的话，你可以为某些路由单独配置守卫</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123; </span><br><span class="line">        <span class="comment">// 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="路由组件内的守卫"><a href="#路由组件内的守卫" class="headerlink" title="路由组件内的守卫"></a>路由组件内的守卫</h2><ul>
<li>beforeRouteEnter 进入路由前</li>
<li>beforeRouteUpdate (2.2) 路由复用同一个组件时</li>
<li>beforeRouteLeave 导航离开该组件的对应路由时调用，我们用它来禁止用户离开，比如还未保存草稿，或者在用户离开前，将setInterval销毁，防止离开之后，定时器还在调用。</li>
</ul>
<h2 id="完整的路由导航解析流程"><a href="#完整的路由导航解析流程" class="headerlink" title="完整的路由导航解析流程"></a>完整的路由导航解析流程</h2><p>完整的路由导航解析流程(不包括其他生命周期)：</p>
<ul>
<li>触发进入其他路由。</li>
<li>调用要离开路由的组件守卫beforeRouteLeave</li>
<li>调用局前置守卫：beforeEach</li>
<li>在重用的组件里调用 beforeRouteUpdate</li>
<li>调用路由独享守卫 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在将要进入的路由组件中调用beforeRouteEnter</li>
<li>调用全局解析守卫 beforeResolve</li>
<li>导航被确认。</li>
<li>调用全局后置钩子的 afterEach 钩子。</li>
<li>触发DOM更新(mounted)。</li>
<li>执行beforeRouteEnter 守卫中传给 next 的回调函数</li>
</ul>
<h1 id="触发钩子的完整顺序"><a href="#触发钩子的完整顺序" class="headerlink" title="触发钩子的完整顺序"></a>触发钩子的完整顺序</h1><p>将路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件：</p>
<ol>
<li>beforeRouteLeave:路由组件的组件离开路由前钩子，可取消路由离开。</li>
<li>beforeEach: 路由全局前置守卫，可用于登录验证、全局路由loading等。</li>
<li>beforeEnter: 路由独享守卫</li>
<li>beforeRouteEnter: 路由组件的组件进入路由前钩子。</li>
<li>beforeResolve:路由全局解析守卫</li>
<li>afterEach:路由全局后置钩子</li>
<li>beforeCreate:组件生命周期，不能访问this。</li>
<li>created:组件生命周期，可以访问this，不能访问dom。</li>
<li>beforeMount:组件生命周期</li>
<li>deactivated: 离开缓存组件a，或者触发a的beforeDestory和destroyed组件销毁钩子。</li>
<li>mounted:访问/操作dom。</li>
<li>activated:进入缓存组件，进入a的嵌套子组件(如果有的话)。</li>
<li>执行beforeRouteEnter回调函数next。</li>
</ol>
<h1 id="SPA单页面应用的优缺点"><a href="#SPA单页面应用的优缺点" class="headerlink" title="SPA单页面应用的优缺点"></a>SPA单页面应用的优缺点</h1><p>SPA分为2种。 第一种，SPA即指水疗、芳香按摩、沐浴、去死角等等。现代SPA主要透过人体的五大感官功能，即听觉（疗效音乐）、味觉（花草茶、健康饮食）、触觉（按摩）、视觉等达到全方位的放松，将精、气、神三者合一，实现身心的放松。</p>
<p>第二种，spa指的是single page application，就是只有一张Web页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序，它在加载页面时，不会加载整个页面，而是只更新某个指定的容器中内容。 浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。因此，对单页应用来说模块化的开发和设计显得相当重要。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h2><ol>
<li>用户体验好,快,内容的改变不需要重新加载整个页面</li>
<li>基于上面一点,spa相对于服务器压力小</li>
<li>良好的前后端分离</li>
<li>同一套后端程序代码,不用修改就可以用web界面,手机,平板等多种客户端</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h2><p>1.不利于seo：右键点击SEO应用查看源码，所有的页面和业务逻辑都封装在app.js中，对于搜索引擎来说，只能够抓取到app.js中的代码，有的搜索引擎会执行js查看页面内容，有的却无法执行，所以无法知道页面的具体内容，故而对SEO不友好。</p>
<p>2.初次加载耗时相对增多</p>
<p>3.导航不可用,如果一定要导航需要自行实现前进,后退</p>
<p>而前端路由router就是管理SPA单页面应用的路径管理器。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起url和页面之间的映射关系。</p>
<h1 id="Vue-中的-key-有什么作用？"><a href="#Vue-中的-key-有什么作用？" class="headerlink" title="Vue 中的 key 有什么作用？"></a>Vue 中的 key 有什么作用？</h1><p><strong>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。没有设置key时，有些节点不会复用，而是直接创建新的，删除旧的。</strong>可以用于 diff 中 sameVnode 算法的判断。<strong>并且 key 不能是 index 和 random</strong></p>
<p>首先讲一下diff算法的处理方法，对操作前后的dom树同一层的节点进行对比，一层一层对比，如下图：</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/key1.png" alt="markdown"></p>
<p>当某一层有很多相同的节点时，也就是列表节点时，Diff算法的更新过程默认情况下也是遵循以上原则。</p>
<p>比如以下的情况，想要在B和C之间添加一个F<br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/key2.png" alt="markdown"></p>
<p>在没有绑定key的时候，diff算法执行起来是这样子的</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/key3.png" alt="markdown"></p>
<p>即把C更新成F，D更新成C，E更新成D，最后再插入E，这样导致了节点没有得到复用，也造成了误差<br>所以我们需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/key4.png" alt="markdown"></p>
<p><strong>准确: 如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug</strong></p>
<p><strong>快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度O(n),Map的时间复杂度仅仅为O(1)</strong></p>
<p>在以下例子中做动态改变的时候，尽量不要使用 index 作为循环的 key，如果你用 index 作为 key，比如在删除第二项的时候，index 就会从 0，1，2 变为 0，1（而不是 0，2），那么仍有可能引起更新错误。<br>diff算法默认使用“就地复用”的策略，是一个首尾交叉对比的过程。<br>用 index 作为 key 和不加 key 是一样的，都采用“就地复用”的策略，所以不推荐使用 index 作为 key，因为增加删除某一个项可能会导致其他 index 动态变化，那么有可能引起更新错误,所以必须要用唯一的键值表示 key。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span> key:0 ，id:201401,name:chen<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span> key:1 , id:201402,name:sun<span class="tag">&lt;/<span class="name">li</span>&gt;</span>    <span class="comment">&lt;!--如果我们要在中间插入一条数组&#123;id:201404,name:zhou&#125;--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span> key:2 , id:201403,name:wang<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>key:0 ，id:201401,name:chen  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>key:1 ，id:201404,name:zhou  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>key:2 , id:201402,name:sun  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>key:3 , id:201403,name:wang  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当我们在中间插入新元素的时候 新元素的key值理所应当变成了index=1，key值也就变成了1 而原本index==1的li元素的index就变成了2，原本index==2的元素key值就变成了3 。<br>这样就导致虚拟dom的diff算法在做比较的时候发现，key值为1，2，3的元素和原来的key值为1，2，3的元素对比的时候发现二者不一样，<strong>diff算法就会重新渲染这三个元素</strong>，原本key值为1，2的元素内容没有发生变化，但是因为key值使用的是index所以还需要重新渲染，这就失去了虚拟dom在性能上的优势</p>
<h1 id="Vue中的diff算法"><a href="#Vue中的diff算法" class="headerlink" title="Vue中的diff算法"></a>Vue中的diff算法</h1><p>vue 和 react 的虚拟 DOM 的 Diff 算法大致相同，其核心是基于两个简单的假设：</p>
<ol>
<li>两个相同的组件产生类似的 DOM 结构，不同的组件产生不同的 DOM 结构。</li>
<li>同一层级的一组节点，他们可以通过唯一的 id 进行区分。</li>
</ol>
<p>vue 虚拟 DOM 的 Diff 算法的复杂度从 O(n^3) 降到了 O(n)<br>使用传统的 Diff 算法通过循环递归遍历节点进行对比，其复杂度要达到O(n^3)，其中 n 是节点总数，效率十分低下</p>
<p>优化后的算法：</p>
<ul>
<li>只比较同一层级，不跨级比较</li>
<li>元素 element(tag) 不相同，直接删掉重建，不再进行深度比较。</li>
<li>元素 element(tag) 和 key 相同，则认为是相同节点，不再进行深度比较。</li>
</ul>
<p>Vue 中的 diff 算法，就是用来比较虚拟 DOM 和需要渲染的真实 DOM 之间的差异。所以下面这张图可以很好的解释这个过程。<strong>比较只会在同个层级之间进行，不会跨层级比较</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 之前 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>           <span class="comment">&lt;!-- 层级1 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>            <span class="comment">&lt;!-- 层级2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span> aoy <span class="tag">&lt;/<span class="name">b</span>&gt;</span>   <span class="comment">&lt;!-- 层级3 --&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>diff<span class="tag">&lt;/<span class="name">Span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">P</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 之后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>            <span class="comment">&lt;!-- 层级1 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>             <span class="comment">&lt;!-- 层级2 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">b</span>&gt;</span> aoy <span class="tag">&lt;/<span class="name">b</span>&gt;</span>        <span class="comment">&lt;!-- 层级3 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>diff<span class="tag">&lt;/<span class="name">Span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最理想的就是将<code>&lt;span&gt;</code>直接移动到<code>&lt;p&gt;</code>的后边，这是最优的操作。但是实际的diff操作是移除<code>&lt;p&gt;</code>里的<code>&lt;span&gt;</code>，然后再创建一个新的<code>&lt;span&gt;</code>插到<code>&lt;p&gt;</code>的后边。<br>因为新加的<code>&lt;span&gt;</code>在层级2，旧的在层级3，属于不同层级的比较。</p>
<p>diff算法的过程其实就是调用patch函数，就像是打补丁一样修改真实DOM。<br>patch函数有两个参数，vnode和oldVnode，也就是新旧两个虚拟节点。</p>
<h2 id="sameVnode"><a href="#sameVnode" class="headerlink" title="sameVnode"></a><strong>sameVnode</strong></h2><p>在这之前，我们先了解完整的vnode都有什么属性，举个一个简单的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// body下的 &lt;div id=&quot;v&quot; class=&quot;classA&quot;&gt;&lt;div&gt; 对应的 oldVnode 就是</span></span><br><span class="line">&#123;</span><br><span class="line">  el:  div  <span class="comment">//对真实的节点的引用，本例中就是document.querySelector(&#x27;#id.classA&#x27;)</span></span><br><span class="line">  tagName: <span class="string">&#x27;DIV&#x27;</span>,   <span class="comment">//节点的标签</span></span><br><span class="line">  sel: <span class="string">&#x27;div#v.classA&#x27;</span>  <span class="comment">//节点的选择器</span></span><br><span class="line">  data: <span class="literal">null</span>,       <span class="comment">// 一个存储节点属性的对象，对应节点的el[prop]属性，例如onclick , style</span></span><br><span class="line">  children: [], <span class="comment">//存储子节点的数组，每个子节点也是vnode结构</span></span><br><span class="line">  text: <span class="literal">null</span>,    <span class="comment">//如果是文本节点，对应文本节点的textContent，否则为null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到patch的第一部分，sameVnode函数就是看这两个节点是否值得比较：<br>判断两个Vnode节点是否是同一个节点，需要满足下面的条件</p>
<ul>
<li>key相同</li>
<li>tag（当前节点的标签名）相同</li>
<li>isComment（是否为注释节点）相同</li>
<li>是否data（当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息）都有定义</li>
<li>当标签是 input 的时候，type必须相同</li>
</ul>
<p>当两个VNode的tag、key、isComment都相同，并且同时定义或未定义data的时候，且如果标签为input则type必须相同。这时候这两个VNode则算sameVnode，可以直接进行patchVnode操作。</p>
<h2 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a><strong>patchVnode</strong></h2><p>patchVnode的规则是这样的：</p>
<ol>
<li><p>如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。</p>
</li>
<li><p>新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。</p>
</li>
<li><p>如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。</p>
</li>
<li><p>当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。</p>
</li>
<li><p>当新老节点都无子节点的时候，只是文本的替换。</p>
</li>
</ol>
<h2 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a><strong>updateChildren</strong></h2><p>首先代码很复杂，所以在这里直接上图。</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/diff1.png" alt="markdown"></p>
<p>首先，在新老两个VNode节点的左右头尾两侧都有一个变量标记，在遍历过程中这几个变量都会向中间靠拢。当oldStartIdx &gt; oldEndIdx或者newStartIdx &gt; newEndIdx时结束循环。</p>
<p>首先，在新老两个VNode节点的左右头尾两侧都有一个变量标记，在遍历过程中这几个变量都会向中间靠拢。当oldStartIdx &gt; oldEndIdx或者newStartIdx &gt; newEndIdx时结束循环。</p>
<p>索引与VNode节点的对应关系： oldStartIdx =&gt; oldStartVnode oldEndIdx =&gt; oldEndVnode newStartIdx =&gt; newStartVnode newEndIdx =&gt; newEndVnode</p>
<p>在遍历中，如果存在key，并且满足sameVnode，会将该DOM节点进行复用，否则则会创建一个新的DOM节点。</p>
<p>首先，oldStartVnode、oldEndVnode与newStartVnode、newEndVnode两两比较一共有2*2=4种比较方法。</p>
<h3 id="sameVnode-oldStartVnode-newStartVnode-或者sameVnode-oldEndVnode-newEndVnode"><a href="#sameVnode-oldStartVnode-newStartVnode-或者sameVnode-oldEndVnode-newEndVnode" class="headerlink" title="sameVnode(oldStartVnode, newStartVnode)或者sameVnode(oldEndVnode, newEndVnode)"></a>sameVnode(oldStartVnode, newStartVnode)或者sameVnode(oldEndVnode, newEndVnode)</h3><p>当新老VNode节点的start或者end满足sameVnode时，也就是sameVnode(oldStartVnode, newStartVnode)或者sameVnode(oldEndVnode, newEndVnode)，直接将该VNode节点进行patchVnode即可。</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/diff2.png" alt="markdown"></p>
<h3 id="sameVnode-oldStartVnode-newEndVnode"><a href="#sameVnode-oldStartVnode-newEndVnode" class="headerlink" title="sameVnode(oldStartVnode, newEndVnode)"></a>sameVnode(oldStartVnode, newEndVnode)</h3><p>如果oldStartVnode与newEndVnode满足sameVnode</p>
<p>这时候说明oldStartVnode已经跑到了oldEndVnode后面去了，进行patchVnode的同时还需要将真实DOM节点移动到oldEndVnode的后面</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/diff3.png" alt="markdown"></p>
<h3 id="sameVnode-oldEndVnode-newStartVnode"><a href="#sameVnode-oldEndVnode-newStartVnode" class="headerlink" title="sameVnode(oldEndVnode, newStartVnode)"></a>sameVnode(oldEndVnode, newStartVnode)</h3><p>如果oldEndVnode与newStartVnode满足sameVnode</p>
<p>这说明oldEndVnode跑到了oldStartVnode的前面，进行patchVnode的同时真实的DOM节点移动到了oldStartVnode的前面</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/diff4.png" alt="markdown"></p>
<h3 id="sameVnode-newStartVnode"><a href="#sameVnode-newStartVnode" class="headerlink" title="sameVnode(?, newStartVnode)"></a>sameVnode(?, newStartVnode)</h3><p>则通过createKeyToOldIdx会得到一个oldKeyToIdx，里面存放了一个key为旧的VNode，value为对应index序列的哈希表。从这个哈希表中可以找到是否有与newStartVnode一致key的旧的VNode节点，如果同时满足sameVnode，patchVnode的同时会将这个真实DOM（elmToMove）移动到oldStartVnode对应的真实DOM的前面。</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/diff5.png" alt="markdown"></p>
<p>当然也有可能newStartVnode在旧的VNode节点找不到一致的key，或者是即便key相同却不是sameVnode，这个时候会调用createElm创建一个新的DOM节点</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/diff6.png" alt="markdown"></p>
<p>到这里循环已经结束了，那么剩下我们还需要处理多余或者不够的真实DOM节点。</p>
<h3 id="处理剩余节点"><a href="#处理剩余节点" class="headerlink" title="处理剩余节点"></a>处理剩余节点</h3><ol>
<li>当结束时oldStartIdx &gt; oldEndIdx，这个时候老的VNode节点已经遍历完了，但是新的节点还没有。说明了新的VNode节点实际上比老的VNode节点多，也就是比真实DOM多，需要将剩下的（也就是新增的）VNode节点插入到真实DOM节点中去，此时调用addVnodes（批量调用createElm的接口将这些节点加入到真实DOM中去）。</li>
</ol>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/diff7.png" alt="markdown"></p>
<ol start="2">
<li>同理，当newStartIdx &gt; newEndIdx时，新的VNode节点已经遍历完了，但是老的节点还有剩余，说明真实DOM节点多余了，需要从文档中删除，这时候调用removeVnodes将这些多余的真实DOM删除。</li>
</ol>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/diff8.png" alt="markdown"></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>尽量不要跨层级的修改dom</li>
<li>设置key可以最大化的利用节点</li>
<li>diff的效率并不是每种情况下都是最优的</li>
</ul>
<h1 id="webpack的plugin与loader区别"><a href="#webpack的plugin与loader区别" class="headerlink" title="webpack的plugin与loader区别"></a>webpack的plugin与loader区别</h1><p><strong>loader：</strong></p>
<p>用于对模块源码的转换，loader描述了webpack如何处理非javascript模块，并且在buld中引入这些依赖。loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，SCSS转换为CSS</p>
<p><strong>plugin：</strong></p>
<p>对于plugin，它就是一个扩展器，它丰富了wepack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，<strong>而是直接对整个构建过程起作用。，</strong>不仅局限于资源的加载。</p>
<h1 id="webpack-实现热更新的原理"><a href="#webpack-实现热更新的原理" class="headerlink" title="webpack 实现热更新的原理"></a>webpack 实现热更新的原理</h1><p>Webpack 热更新（ Hot Module Replacement，简称 HMR，后续均以 HMR 替代），无需完全刷新整个页面的同时，更新所有类型的模块。</p>
<ol>
<li><p>Webpack编译期，为需要热更新的 entry 注入热更新代码(EventSource通信，核心是Webpack-hot-middleware 插件的作用，就是提供浏览器和 Webpack 服务器之间的通信机制、且在浏览器端接收 Webpack 服务器端的更新变化。)</p>
</li>
<li><p>页面首次打开后，服务端与客户端通过 EventSource 建立通信渠道，把下一次的 hash 返回客户端</p>
</li>
<li><p>客户端获取到hash，这个hash将作为下一次请求服务端 hot-update.js 和 hot-update.json的hash</p>
</li>
<li><p>修改页面代码后，Webpack 的Complier 类会调用 Watch 方法监听文件变更，当监听到文件修改后，开始编译，编译完成后，发送 build 消息给客户端</p>
</li>
<li><p>客户端获取到hash，成功后客户端构造hot-update.js script链接，然后插入主文档</p>
</li>
<li><p>hot-update.js 插入成功后，执行hotAPI 的 createRecord 和 reload方法，获取到 Vue 组件的 render方法，重新 render 组件， 继而实现 UI 无刷新更新。</p>
</li>
</ol>
<h1 id="内置的过渡动画"><a href="#内置的过渡动画" class="headerlink" title="内置的过渡动画"></a>内置的过渡动画</h1><ul>
<li><p>v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</p>
</li>
<li><p>v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</p>
</li>
<li><p>v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。</p>
</li>
<li><p>v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</p>
</li>
<li><p>v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</p>
</li>
<li><p>v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。</p>
</li>
</ul>
<p>对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 transition，则 v- 是这些类名的默认前缀。如果你使用了 <transition name="my-transition">，那么 v-enter 会替换为 my-transition-enter。</p>
<h1 id="vue-3-0-新特性"><a href="#vue-3-0-新特性" class="headerlink" title="vue 3.0 新特性"></a>vue 3.0 新特性</h1><h2 id="基于-Proxy-的观察者机制"><a href="#基于-Proxy-的观察者机制" class="headerlink" title="基于 Proxy 的观察者机制"></a>基于 Proxy 的观察者机制</h2><p>在vue 3.0之前是使用Object.defineProperty，那为什么要使用Proxy替代Object.defineProperty呢，主要是Object.defineProperty存在以下问题：</p>
<ol>
<li>在Vue中，Object.defineProperty无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。Vue 框架是<strong>通过遍历数组 和递归遍历对象</strong>，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听，部分方法如下：</li>
</ol>
<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()</li>
</ul>
<p>由于只针对了以上7种方法进行了hack处理,所以其他数组的属性也是检测不到的，还是具有一定的局限性。</p>
<ol start="2">
<li>Object.defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue里，是通过递归以及遍历data 对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象，不管是对操作性还是性能都会有一个很大的提升。</li>
</ol>
<p>所以使用Proxy的优点如下：</p>
<ul>
<li>可以劫持整个对象，并返回一个新对象</li>
<li>Proxy可以直接监听对象而非属性</li>
<li>Proxy可以直接监听数组的变化</li>
<li>Proxy有多达13种拦截方法,、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的</li>
<li>Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</li>
</ul>
<p><strong>Object.defineProperty的优势</strong></p>
<ul>
<li>兼容性好,支持IE9</li>
</ul>
<h2 id="PWA-支持"><a href="#PWA-支持" class="headerlink" title="PWA 支持"></a>PWA 支持</h2><p>当我们选择启用 PWA 功能时，在打包生成的代码时会默认生成 service-worker.js 和 manifest.json 相关文件。熟悉PWA的同学都知道service-worker.js 和 manifest.json 是PWA的重要配置文件</p>
<p>PWA(Progressive web apps, 渐进式Web应用)</p>
<ul>
<li>可以生成桌面小图标，不需要打开浏览器，方便用户访问</li>
<li>通过网络缓存提升页面访问速度，达到渐进式的页面甚至离线访问，提升用户体验</li>
<li>实现类似app的推送功能，生成系统通知推送给用户</li>
</ul>
<p>service worker是实现PWA的核心，service worker是一个独立的浏览器线程，不会对当前程序的执行线程造成阻塞，通过service worker可以实现页面离线访问、用户消息推送等功能。<br>使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p>
<p>Service Worker 实现缓存功能一般分为三个步骤：</p>
<ul>
<li>首先需要先注册 Service Worker</li>
<li>然后监听到 install 事件以后就可以缓存需要的文件</li>
<li>下次用户访问的时候就可以通过<strong>拦截请求的方式</strong>查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据</li>
</ul>
<p>PWA确实是当下很热门的技术，因为它提升了web应用的体验，甚至达到原生app体验，但是它的问题就是兼容性问题，相信如果兼容性问题得到解决，这种技术一定会被大面积推广到实际应用。iOS11.3之前都不支持，因此vue cli3脚手架在集成时默认在ios下是关闭的</p>
<h2 id="使用图形化界面"><a href="#使用图形化界面" class="headerlink" title="使用图形化界面"></a>使用图形化界面</h2><p>你也可以通过 vue ui 命令以图形化界面创建和管理项目：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure>

<h2 id="项目改变"><a href="#项目改变" class="headerlink" title="项目改变"></a>项目改变</h2><p>相比 vue-cli 2.X 创建的目录，vue-cli 3.0 创建的目录看不见 webpack 的配置<br>需要手动配置 webpack：在根目录下新建一个 vue.config.js 文件</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>虚拟DOM重写</li>
<li>优化 slots 的生成：在 Vue 中，当父组件重新渲染时，其子组件也必须重新渲染。使用Vue 3，可以单独重新渲染父级和子级。</li>
<li>静态树提升(Static Tree Hoisting)</li>
<li>静态属性提升</li>
</ul>
<h1 id="Vue框架怎么实现对象和数组的监听（源码）"><a href="#Vue框架怎么实现对象和数组的监听（源码）" class="headerlink" title="Vue框架怎么实现对象和数组的监听（源码）"></a>Vue框架怎么实现对象和数组的监听（源码）</h1><p>如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是  Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observe a list of Array items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observe(items[i])  <span class="comment">// observe 功能为监测数据的变化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对属性进行递归遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val) <span class="comment">// observe 功能为监测数据的变化</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是<strong>通过遍历数组 和递归遍历对象</strong>，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p>
<h1 id="vue自定义指令"><a href="#vue自定义指令" class="headerlink" title="vue自定义指令"></a>vue自定义指令</h1><p>使用 Vue.directive(id, [definition]) 定义全局的指令来进行自定义指令</p>
<p>参数1 ：指令的名称，注意，在定义的时候，指令的名称前面，不需要加 v-前缀，但是： 在调用的时候，必须在置顶的名称前加上 v-前缀来进行调用</p>
<p>参数2：是一个对象， 这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">&quot;focus&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">// 注意： 在每个函数中， 第一个参数永远是el， 表示被绑定了指令的那个元素，这个el参数，是一个原生的JS对象</span></span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123; <span class="comment">// 每当指令绑定到元素上的时候，会立即执行这个bind函数，只执行一次</span></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123; <span class="comment">// inserted 表示元素插入到DOM中的时候，会执行inserted函数【触发一次】</span></span><br><span class="line">        el.focus()</span><br><span class="line">    &#125;,</span><br><span class="line">    updated: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123; <span class="comment">// 当VNode更新的时候，会执行updated，可能会触发多次</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注意： Vue中所有的指令，在调用的时候，都以 v- 开头 --&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;form-control&quot;</span> v-model=<span class="string">&quot;keywords&quot;</span> v-focus&gt;</span><br></pre></td></tr></table></figure>

<h1 id="mixin-和-mixins-的区别"><a href="#mixin-和-mixins-的区别" class="headerlink" title="mixin 和 mixins 的区别"></a>mixin 和 mixins 的区别</h1><ol>
<li>Vue.mixin</li>
</ol>
<p>全局注册混入对象。注意使用！ 一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。</p>
<ol start="2">
<li>mixins</li>
</ol>
<p>mixins 选项接受一个混入对象的数组。这些混入实例对象可以像正常的实例对象一样包含选项，他们将在 Vue.extend() 里最终选择使用相同的选项合并逻辑合并。举例：如果你的混入包含一个钩子而创建组件本身也有一个，两个函数将被调用。</p>
<p>Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>) &#125;,</span><br><span class="line">  mixins: [mixin]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure>

<h1 id="如何渲染⼏万条数据并不卡住界⾯"><a href="#如何渲染⼏万条数据并不卡住界⾯" class="headerlink" title="如何渲染⼏万条数据并不卡住界⾯"></a>如何渲染⼏万条数据并不卡住界⾯</h1><ol>
<li><p>考察了如何在不卡住⻚⾯的情况下渲染数据，也就是说不能⼀次性将⼏ 万条都渲染出来，⽽应该⼀次渲染部分 DOM ，那么就可以通过 requestAnimationFrame 来每 16 ms 刷新⼀次</p>
</li>
<li><p>通过用户的滚动行为来进行渲染</p>
</li>
</ol>
<h1 id="为什么-v-if-和-v-for-不能混用？"><a href="#为什么-v-if-和-v-for-不能混用？" class="headerlink" title="为什么 v-if 和 v-for 不能混用？"></a>为什么 v-if 和 v-for 不能混用？</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有如下的列表数据</span></span><br><span class="line">list: [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    age: <span class="number">23</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;john&#x27;</span>,</span><br><span class="line">    age: <span class="number">33</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;petty&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需求是只需要渲染出 30 岁以下的数据，那么有可能得到以下的代码</span></span><br><span class="line"></span><br><span class="line">&lt;!-- html模版 --&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;item in list&quot;</span> v-<span class="keyword">if</span>=<span class="string">&quot;item.age&lt;30&quot;</span>&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123;item.age&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>但是官方不推荐这种写法，原因如下：</strong></p>
<ol>
<li><p>当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级。</p>
</li>
<li><p>哪怕我们只渲染出一小部分用户的元素，也得在每次重渲染的时候遍历整个列表，不论活跃用户是否发生了变化。</p>
</li>
</ol>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a><strong>参考文章：</strong></h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d59f2a451882549be53b170">30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度）</a><br><a target="_blank" rel="noopener" href="https://github.com/aooy/blog/issues/2">解析vue2.0的diff算法</a><br><a target="_blank" rel="noopener" href="https://github.com/answershuto/learnVue/blob/master/docs/VirtualDOM%E4%B8%8Ediff(Vue%E5%AE%9E%E7%8E%B0)">VirtualDOM与diff(Vue实现)</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904183619944462">从源码解惑，为什么v-if和v-for不应该一起用？</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/23/css/HTML/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/23/css/HTML/" class="post-title-link" itemprop="url">HTML</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-23 15:19:35" itemprop="dateCreated datePublished" datetime="2019-07-23T15:19:35+08:00">2019-07-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h1><p>在我的理解为：根据内容，使用最合适的HTML标签。<br>场景：加入一个文章标题，要求这个标题的字体比正文的要大一些，还要加粗。能够实现这种效果的方法有很多，比如用CSS样式进行渲染。这样的效果看起来像是一个标题，但是他对浏览器来说，只是一个被渲染过的文本，无法知道他是一个标题。若要让浏览器知道他是一个标题，应该用hn标签来进行标记。<br>从这个例子可以总结出： 语义化的HTML文档，不关心内容的显示效果。 说的通俗一点： 标题脱了CSS这层外衣，它还是一个标题。</p>
<h2 id="语义化标签的优势"><a href="#语义化标签的优势" class="headerlink" title="语义化标签的优势"></a>语义化标签的优势</h2><ul>
<li>代码结构清晰，方便阅读，有利于团队合作开发。</li>
<li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。</li>
<li>有利于搜索引擎优化（SEO）。</li>
</ul>
<h2 id="HTML5新增的语义化标签"><a href="#HTML5新增的语义化标签" class="headerlink" title="HTML5新增的语义化标签"></a>HTML5新增的语义化标签</h2><ul>
<li>header：页眉通常包括网站标志、主导航、全站链接以及搜索框</li>
<li>nav：标记导航，仅对文档中重要的链接群使用</li>
<li>main：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能</li>
<li>article：定义外部的内容，其中的内容独立于文档的其余部分</li>
<li>section：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分</li>
<li>footer：页脚，只有当父级是body时，才是整个页面的页脚</li>
</ul>
<h1 id="meta标签的理解和总结"><a href="#meta标签的理解和总结" class="headerlink" title="meta标签的理解和总结"></a>meta标签的理解和总结</h1><p>meta常用于定义页面的说明，关键字，最后修改日期，和其它的元数据。它不会显示在页面上，但是机器却可以识别。<br>这些元数据将服务于浏览器（如何布局或重载页面），搜索引擎和其它网络服务。</p>
<p><strong>组成：meta标签一共有两个属性，分别是http-equiv属性和name属性</strong></p>
<h2 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h2><p>name属性主要用于描述网页，比如网页的关键词，叙述等。与之对应的属性值为content，content中的内容是对name填入类型的具体描述，便于搜索引擎抓取。<br>meta标签中name属性语法格式是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;参数&quot;</span> <span class="attr">content</span>=<span class="string">&quot;具体的描述&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>A. keywords(关键字)</strong><br>说明：用于告诉搜索引擎，你网页的关键字。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Lxxyx,博客，文科生，前端&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>B. description(网站内容的描述)</strong><br>说明：用于告诉搜索引擎，你网站的主要内容。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;文科生，热爱前端与编程。目前大二，这是我的前端博客&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（SEO优先级按照title、description、keywords的顺序递减）</p>
<ul>
<li><strong>C. viewport(移动端的窗口)</strong><br>说明：这个概念较为复杂，具体的会在下篇博文中讲述。<br>这个属性常用于设计移动端网页。在用bootstrap,AmazeUI等框架时候都有用过viewport。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>C. viewport(移动端的窗口)</strong><br>说明：robots用来告诉爬虫哪些页面需要索引，哪些页面不需要索引。<br>content的参数有all,none,index,noindex,follow,nofollow。默认是all。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;none&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>E. author(作者)</strong><br>说明：用于标注网页作者</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;leslie,leslie_choi@yeah.net&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>G. copyright(版权)</strong><br>说明：用于标注版权信息</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;copyright&quot;</span> <span class="attr">content</span>=<span class="string">&quot;leslie&quot;</span>&gt;</span> //代表该网站为leslie个人版权所有。</span><br></pre></td></tr></table></figure>

<h2 id="http-equiv属性"><a href="#http-equiv属性" class="headerlink" title="http-equiv属性"></a>http-equiv属性</h2><p>equiv的全称是”equivalent”，意思是相等，相当于。<br>所以在这里的作用就是相当于HTTP的作用，类似于定义http参数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;参数&quot;</span> <span class="attr">content</span>=<span class="string">&quot;具体的描述&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>A. content-Type(设定网页字符集)(推荐使用HTML5的方式)</strong></li>
</ul>
<p>说明：用于设定网页字符集，便于浏览器解析与渲染页面</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=utf-8&quot;</span>&gt;</span>  //旧的HTML，不推荐</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> //HTML5设定网页字符集的方式，推荐使用UTF-8</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>B. X-UA-Compatible(浏览器采取何种版本渲染当前页面)</strong></li>
</ul>
<p>说明：用于告知浏览器以何种版本来渲染页面。（一般都设置为最新模式，在各大框架中这个设置也很常见。）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span>/&gt;</span> //指定IE和Chrome使用最新版本渲染当前页面</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>C.cache-control(指定请求和响应遵循的缓存机制)</strong></li>
</ul>
<p><strong>用法一：指导浏览器如何缓存某个响应以及缓存多长时间。</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;cache-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>共有以下几种用法：</p>
<p>1、no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。</p>
<p>2、no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）</p>
<p>3、public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果</p>
<p>4、private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）</p>
<p>5、maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。</p>
<p><strong>用法二：禁止百度自动转码。</strong></p>
<p>用于禁止当前页面在移动端浏览时，被百度自动转码。虽然百度的本意是好的，但是转码效果很多时候却不尽人意。所以可以在head中加入例子中的那句话，就可以避免百度自动转码了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Cache-Control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-siteapp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>D. expires(网页到期时间)</strong></li>
</ul>
<p>用于设定网页的到期时间，过期后网页必须到服务器上重新传输。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;expires&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Sunday 26 October 2016 01:00 GMT&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>refresh(自动刷新并指向某页面)</strong></li>
</ul>
<p>网页将在设定的时间内，自动刷新并调向设定的网址。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;2；URL=http://www.baidu.com&quot;</span>&gt;</span> //意思是2秒后跳转</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Set-Cookie(cookie设定)</strong> </li>
</ul>
<p>如果网页过期。那么这个网页存在本地的cookies也会被自动删除。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Set-Cookie&quot;</span> <span class="attr">content</span>=<span class="string">&quot;name, date&quot;</span>&gt;</span> //格式</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Set-Cookie&quot;</span> <span class="attr">content</span>=<span class="string">&quot;User=Lxxyx; path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT&quot;</span>&gt;</span> //具体范例</span><br></pre></td></tr></table></figure>

<h2 id="设置页面不缓存的方法"><a href="#设置页面不缓存的方法" class="headerlink" title="设置页面不缓存的方法"></a>设置页面不缓存的方法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;pragma&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Cache-Control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache, must-revalidate&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;expires&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="H5和CSS3的新特性"><a href="#H5和CSS3的新特性" class="headerlink" title="H5和CSS3的新特性"></a>H5和CSS3的新特性</h1><h2 id="html5有哪些新特性"><a href="#html5有哪些新特性" class="headerlink" title="html5有哪些新特性"></a>html5有哪些新特性</h2><ol>
<li>拖拽释放(Drag and drop) API </li>
<li>语义化更好的内容标签（header,nav,footer,aside,article,section）</li>
<li>音频、视频API(audio,video)</li>
<li>画布(Canvas) API</li>
<li>地理(Geolocation) API</li>
<li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；sessionStorage 的数据在浏览器关闭后自动删除。</li>
<li>sessionStorage 的数据在浏览器关闭后自动删除</li>
<li>表单控件，calendar、date、time、email、url、search  </li>
<li>新的技术webworker, websocket, Geolocation</li>
</ol>
<h3 id="html5-的离线存储以及工作原理"><a href="#html5-的离线存储以及工作原理" class="headerlink" title="html5 的离线存储以及工作原理"></a>html5 的离线存储以及工作原理</h3><p>在⽤户没有与因特⽹连接时，可以正常访问站点或应⽤，在⽤户与因特⽹连接时，更新⽤ 户机器上的缓存⽂件</p>
<p>原理：HTML5 的离线存储是基于⼀个新建的 .appcache ⽂件的缓存机制(不是存储技 术)，通过这个⽂件上的解析清单离线存储资源，这些资源就会像 cookie ⼀样被存储了下 来。之后当⽹络在处于离线状态下时，浏览器会通过被离线存储的数据进⾏⻚⾯展示</p>
<p>使用方法：</p>
<ol>
<li>⻚⾯头部像下⾯⼀样加⼊⼀个 manifest 的属性</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">&quot;demo.appcache&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在 cache.manifest ⽂件的编写离线存储的资源 </p>
</li>
<li><p>在离线状态时，操作 window.applicationCache 进⾏需求实现</p>
</li>
</ol>
<p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest ⽂件，如 果是第⼀次访问 app ，那么浏览器就会根据manifest⽂件的内容下载相应的资源并且进⾏ 离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使⽤离线的资 源加载⻚⾯，然后浏览器会对⽐新的 manifest ⽂件与旧的 manifest ⽂件，如果⽂件没有发⽣改变，就不做任何操作，如果⽂件改变了，那么就会重新下载⽂件中的资源并进⾏离线存储。</p>
<p>离线的情况下，浏览器就直接使⽤离线存储的资源。</p>
<h2 id="CSS3-新增属性"><a href="#CSS3-新增属性" class="headerlink" title="CSS3 新增属性"></a>CSS3 新增属性</h2><ol>
<li>颜色：新增RGBA，HSLA模式</li>
<li>文字阴影（text-shadow、）</li>
<li>边框： 圆角（border-radius）边框阴影： box-shadow</li>
<li>盒子模型：box-sizing</li>
<li>背景：background-size 设置背景图片的尺寸background-origin 设置背景图片的原点。background-clip 设置背景图片的裁切区域，以”，”分隔可以设置多背景，用于自适应布局</li>
<li>渐变：linear-gradient、radial-gradient</li>
<li>过渡：transition，可实现动画</li>
<li>自定义动画</li>
<li>在CSS3中唯一引入的伪元素是 ：：selection.</li>
<li>媒体查询，多栏布局</li>
<li>border-image</li>
<li>2D转换：transform：translate(x，y) rotate(x，y) skew(x，y) scale(x，y)</li>
</ol>
<h2 id="H5中已经废弃的标签"><a href="#H5中已经废弃的标签" class="headerlink" title="H5中已经废弃的标签"></a>H5中已经废弃的标签</h2><ul>
<li>br 换行，已经被 p 标签进行替换</li>
<li>hr 画线</li>
<li>font、big、center</li>
<li>在企业开发中，不到万不得已 不要轻易使用被废弃的标签</li>
<li>strong ：定义重要性强调的文字</li>
<li>ins 定义插入的文字</li>
<li>em 定义强调的文字</li>
<li>del定义被删除的文字</li>
<li>frame 等等</li>
</ul>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/entry/588074c62f301e00696b481d">关于 HTML 中 meta 标签的理解和总结</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/13/JavaScript/%E6%8F%90%E9%AB%98%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/13/JavaScript/%E6%8F%90%E9%AB%98%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">提高页面性能</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-13 22:12:24" itemprop="dateCreated datePublished" datetime="2019-07-13T22:12:24+08:00">2019-07-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们常将网络性能优化措施归结为三大方面：减少请求数、减小请求资源体积、提升网络传输速率。</p>
<ul>
<li><p>content ⽅⾯   </p>
<ul>
<li>减少 HTTP 请求：合并⽂件、 CSS 精灵、 inline Image </li>
<li>减少 DNS 查询： DNS 缓存、将资源分布到恰当数量的主机名 </li>
<li>减少 DOM 元素数量</li>
</ul>
</li>
<li><p>Server ⽅⾯</p>
<ul>
<li>使⽤ CDN 配置 ETag 对组件使⽤ Gzip 压缩</li>
</ul>
</li>
<li><p>Cookie ⽅⾯</p>
<ul>
<li>减⼩ cookie ⼤⼩</li>
</ul>
</li>
<li><p>css ⽅⾯</p>
<ul>
<li>将样式表放到⻚⾯顶部 不使⽤ CSS 表达式 使⽤ <code>&lt;link&gt;</code> 不使⽤ @import</li>
</ul>
</li>
<li><p>Javascript ⽅⾯</p>
<ul>
<li>将脚本放到⻚⾯底部 </li>
<li>将 javascript 和 css 从外部引⼊ 压缩 javascript 和 css </li>
<li>删除不需要的脚本</li>
<li>减少 DOM 访问</li>
</ul>
</li>
<li><p>图⽚⽅⾯</p>
<ul>
<li>优化图⽚：根据实际颜⾊需要选择⾊深、压缩 </li>
<li>优化 css 精灵 </li>
<li>不要在 HTML 中拉伸图⽚</li>
</ul>
</li>
</ul>
<h1 id="资源压缩合并，减少HTTP请求"><a href="#资源压缩合并，减少HTTP请求" class="headerlink" title="资源压缩合并，减少HTTP请求"></a>资源压缩合并，减少HTTP请求</h1><p>比如可以使用webpack将多个文件压缩成一个文件，并且对代码进行压缩。使用雪碧图、base64格式的图片等等。而在vue cli3中可以开启gzip压缩，gizp压缩是一种http请求优化方式，通过减少文件体积来提高加载速度。html、js、css文件甚至json数据都可以用它压缩，可以减小60%以上的体积。</p>
<p>使用步骤：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先安装插件</span></span><br><span class="line">npm i -D compression-webpack-plugin</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后再在vue.config.js中进行配置</span></span><br><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">&quot;compression-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        plugins: [<span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">          test: <span class="regexp">/\.js$|\.html$|\.css/</span>,  <span class="comment">//匹配文件名</span></span><br><span class="line">          threshold: <span class="number">10240</span>,             <span class="comment">//对10k以上文件进行压缩</span></span><br><span class="line">          deleteOriginalAssets: <span class="literal">false</span>   <span class="comment">//是否删除源文件</span></span><br><span class="line">        &#125;)]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般浏览器都已支持.gz的资源文件，在http请求的Request Headers 中能看到 Accept-Encoding:gzip。</p>
<p>要使服务器返回.gz文件，还需要对服务器进行配置，根据Request Headers的Accept-Encoding标签进行鉴别，如果支持gzip就返回.gz文件。</p>
<h1 id="非核心代码异步加载"><a href="#非核心代码异步加载" class="headerlink" title="非核心代码异步加载"></a>非核心代码异步加载</h1><p>通常对于大型应用来说，完整加载所有javascript代码是十分耗时的工作。在页面渲染的这样一个过程中，有一个关键点是如果在解析内容的过程中遇到了脚本标签，如：<script src="example.js"></script>，浏览器就会暂停内容的解析，转而开始下载脚本。并且只有等脚本下载完并执行结束后，渲染引擎才会继续解析。那么这样一来，页面显示的时间必然会被延长。因此我们需要优化的点就是尽可能地让页面更早地被渲染出来。要解决上面说到的脚本加载问题，通常有三种解决方案：将脚本放在HTML末尾、动态加载脚本以及异步加载脚本。</p>
<ol>
<li>异步加载的方式</li>
</ol>
<ul>
<li>动态脚本加载</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.src = <span class="string">&quot;js/test.js&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(script);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>异步加载的方式</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defer &lt;script src=<span class="string">&quot;defer.js&quot;</span> defer&gt; &lt;/script&gt;   </span><br><span class="line"><span class="keyword">async</span> &lt;script src=<span class="string">&quot;defer.js&quot;</span> <span class="keyword">async</span>&gt; &lt;/script&gt;</span><br><span class="line"><span class="comment">//第三种方法，动态创建 script ，插⼊到 DOM 中，加载完毕后 callBack</span></span><br></pre></td></tr></table></figure>

<ul>
<li>defer是在HTML渲染完之后（DOM结构完全生成，以及其他脚本执行完成之后）才会执行，如果是多个，则按照加载的顺序执行，优先级比async高</li>
<li>async是在下载完脚本之后立即执行，渲染引擎会中断，执行完脚本之后才会继续渲染，如果是多个，执行顺序和加载顺序无关</li>
<li>直接使用src方式引入JS会阻塞页面的渲染</li>
</ul>
<h2 id="解决异步加载脚本的问题"><a href="#解决异步加载脚本的问题" class="headerlink" title="解决异步加载脚本的问题"></a>解决异步加载脚本的问题</h2><p>如何处理加载过程中这些脚本的互相依赖关系，就成了实现异步加载过程中所需要考虑的问题。一方面，对于页面中那些独立的脚本，如用户统计等插件就可以放心大胆地使用异步加载。而另一方面，对于那些确实需要处理依赖关系的脚本，业界已经有很成熟的解决方案了。如采用AMD规范的RequireJS,CMD规范的seaJS，或者使用ES6中的模块化开发。另一方面，也可以使用promise技术来实现处理异步脚本加载过程中的依赖问题：</p>
<p>针对每个脚本依赖都会创建一个promise对象来管理其状态。采用动态插入脚本的方式来管理脚本，然后利用脚本onload和onreadystatechange(兼容性处理)事件来监听脚本是否加载完成。一旦加载完毕，就会触发promise的resovle方法。最后，针对依赖的处理，是promise的all方法，这个方法只有在所有promise对象都resolved的时候才会触发resolve方法，这样一来，我们就可以确保在执行回调之前，所有依赖的脚本都已经加载并执行完毕。</p>
<h1 id="利用浏览器缓存（最重要的一步）-gt-缓存的分类-gt-缓存的原理"><a href="#利用浏览器缓存（最重要的一步）-gt-缓存的分类-gt-缓存的原理" class="headerlink" title="利用浏览器缓存（最重要的一步） -&gt; 缓存的分类 -&gt; 缓存的原理"></a>利用浏览器缓存（最重要的一步） -&gt; 缓存的分类 -&gt; 缓存的原理</h1><ol>
<li>缓存的分类</li>
</ol>
<ul>
<li>强缓存发现本地有请求文件的副本，直接使用，也就是说如果我们在服务端更新了文件，并不会被浏览器所得知，就无法替换失效的缓存</li>
<li>协商缓存则需要和服务器进行交流，通过确认之后才可以使用</li>
</ul>
<p><strong>a 强缓存：不会向服务器发送请求，直接从缓存中读取资源，返回状态码200</strong></p>
<ul>
<li><p>Expires Wed, 22 Oct 2018 08:41:00 GMT</p>
</li>
<li><p><em>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点，如果过期则会再次请求</em>*</p>
</li>
<li><p>Cache—Control:max-age=300</p>
</li>
<li><p><em>代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</em>*</p>
</li>
</ul>
<p>但是如果服务器同时下发了两个，则以相对时间为准。</p>
<p><strong>b 协商缓存：会去服务器比对，若没改变才直接读取本地缓存，返回的状态码是 304</strong><br>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p>
<p><strong>Last-Modified 和 If-Modified-Since</strong></p>
<p>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；<br>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，<strong>值就是Last-Modified中的值</strong> ；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。 </p>
<p>存在的弊端：</p>
<ul>
<li><p>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源</p>
</li>
<li><p>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</p>
</li>
<li><p>某些服务器不能精确的得到文件的最后修改时间。</p>
</li>
</ul>
<p><strong>Etag 和 If-None-Match</strong><br>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成，类似一个哈希值)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。<br>如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p>
<p><strong>PS：强缓存的优先级会比协商缓存优先级高，cache-control优先级 &gt; expire，Etag优先级 &gt; Last-modified</strong></p>
<p><strong>那有了Etag是不是可以放弃last-Modified了呢？</strong></p>
<ul>
<li><p>对那些一秒内修改特别频繁的文件，使用etag强验证的话，就需要占用服务器cpu资源频繁进行etag的计算，这样可能就不好用了。</p>
</li>
<li><p>只是给代码加上注释，但是服务器实质的内容并没有一点改变，如果使用Etag扫描全部文件可能会耗费大量性能，而使用last-modified只要返回最后修改时间即可，所以应该根据场景选择对应方案。</p>
</li>
</ul>
<h1 id="利用cdn"><a href="#利用cdn" class="headerlink" title="利用cdn"></a>利用cdn</h1><p>CDN(Content Delivery Network)又称为内容分发网络，使内容传输的更快，更稳定。<br>也就是说，<strong>把静态资源文件和动态网页分集群部署</strong>，静态资源会被部署到CDN节点上，网页中引用的资源也会变成对应的部署路径。<br>CDN 的核心点有两个: 一个是缓存，一个是回源。</p>
<ul>
<li>缓存<br>将从根服务器请求来的资源按要求缓存。</li>
<li>回源<br>当有用户访问某个资源的时候，如果被解析到的那个 CDN 节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。没有人访问，CDN 节点不会主动去源站请求资源。</li>
</ul>
<p>原理：不同地区的用户会访问到离自己最近的相同网络线路上的CDN节点，当请求达到CDN节点后，节点会判断自己的内容缓存是否有效，如果有效，则立即响应缓存内容给用户，从而加快响应速度。如果CDN节点的缓存失效，它会根据服务配置去我们的内容源服务器获取最新的资源响应给用户，并将内容缓存下来以便响应给后续访问的用户。因此，一个地区内只要有一个用户先加载资源，在CDN中建立了缓存，该地区的其他后续用户都能因此而受益。</p>
<p>不同地区的用户访问同一个域名却能得到不同CDN节点的IP地址，这要依赖于<strong>CDN服务商提供的智能域名解析服务</strong>，浏览器发起域名查询时，这种智能DNS服务会根据用户IP计算并返回离它最近的同网络CDN节点IP，引导浏览器与此节点建立连接以获取资源。</p>
<p>优点：</p>
<ul>
<li>CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低</li>
<li>大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源站的负载</li>
<li>提高网络访问的稳定性</li>
</ul>
<h1 id="预解析DNS"><a href="#预解析DNS" class="headerlink" title="预解析DNS"></a>预解析DNS</h1><p>还有一个可以优化网页速度的方式是利用dns的预解析技术。同preload类似，DNS Prefetch在网络层面上优化了资源加载的速度。<br>我们知道，针对DNS的前端优化，主要分为减少DNS的请求次数，还有就是进行DNS预先获取。DNS prefetch就是为了实现这后者。其用法也很简单，只要在link标签上加上对应的属性就行了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;x-dns-prefetch-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;on&quot;</span> /&gt;</span> /* 这是用来告知浏览器当前页面要做DNS预解析，可以选择on或者off */</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//example.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>复制代码在支持该标准的浏览器上，会自动对链接中的地址域名做DNS解析缓存。不过，像Goolge、火狐这样的现代浏览器即使不设置这个属性，也能在后台做自动预解析。如果你的页面中需要大量访问不同域名的资源，可以利用这项技术加快资源的获取，从而获得更好的用户体验。需要注意的是，DNS预解析虽好，但是也不能滥用。如果对多页面重复DNS预解析，会增加DNS的查询次数。</p>
<h1 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h1><ul>
<li><p>在开发中，可能会遇到这样的情况。有些资源不需要⻢上⽤到，但是希望尽早获取，这时候就可以使⽤预加载 </p>
</li>
<li><p>预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件， 可以使⽤以下代码开启预加载</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>预加载可以⼀定程度上降低⾸屏的加载时间，因为可以将⼀些不影响⾸屏但重要的⽂件延后加载，唯⼀缺点就是兼容性不好</p>
<h2 id="图片预加载"><a href="#图片预加载" class="headerlink" title="图片预加载"></a>图片预加载</h2><ol>
<li>使用 display:none</li>
</ol>
<p>给图片加上这个属性之后，图片不会再页面中显示，但是网络请求已经将图片加载到缓存里面了，等到需要使用的时候，再使用回调函数从缓存里面获取。</p>
<ol start="2">
<li>new Image</li>
</ol>
<p>使用new Image的方式新建一个image 对象，然后再为这个对象绑定一个src，当对应的js代码被执行之后，图片也会被下载下来，等到需要使用的时候，再使用回调函数从缓存里面获取。</p>
<ol start="3">
<li>使用XMLRequest 对象进行图片的预加载</li>
</ol>
<p>优点：能够更好地对预加载过程进行控制</p>
<p>缺点：存在跨域问题</p>
<ol start="4">
<li>使用preloader 库</li>
</ol>
<h1 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h1><p>可以通过预渲染将下载的⽂件预先在后台渲染，可以使⽤以下代码开启预渲染</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prerender&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://poetries.com&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>预渲染虽然可以提⾼⻚⾯的加载速度，但是要确保该⻚⾯百分百会被⽤户在之后打开，否则就⽩⽩浪费资源去渲染</p>
<h1 id="懒执⾏与懒加载"><a href="#懒执⾏与懒加载" class="headerlink" title="懒执⾏与懒加载"></a>懒执⾏与懒加载</h1><h2 id="懒执⾏"><a href="#懒执⾏" class="headerlink" title="懒执⾏"></a>懒执⾏</h2><p>懒执⾏就是将某些逻辑延迟到使⽤时再计算。该技术可以⽤于⾸屏优化，对于某些耗时逻辑并不需要在⾸屏就使⽤的，就可以使⽤懒执⾏。懒执⾏需要唤醒，⼀般可以通过定时器或者事件的调⽤来唤醒</p>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><ul>
<li>懒加载就是将不关键的资源延后加载</li>
</ul>
<p>如果img资源和相关的静态资源放在同一个cdn节点，但是img标签一般都是在script 之上的，而浏览器对同一个地址会有并发的限制，这样会导致js文件执行延迟。</p>
<p>懒加载的原理就是只加载⾃定义区域（通常监听scroll事件，判断当前是否是可视区域，但也可以是即将进⼊ 可视区域）内需要加载的东⻄。对于图⽚来说，先设置图⽚标签的 src 属性 为⼀张占位图，将真实的图⽚资源放⼊⼀个⾃定义属性中，当进⼊⾃定义区域 时，就将⾃定义属性替换为 src 属性，这样图⽚就会去下载资源，实现了图⽚懒加载。</p>
<p>PS：实现原理，主要通过判断图片顶部距离屏幕顶部的距离（offsetTop）是否小于屏幕的高度（document.documentElement.clientHeight），如果是的话，则说明已经进入了可视区域。</p>
<ul>
<li>懒加载不仅可以⽤于图⽚，也可以使⽤在别的资源上。⽐如进⼊可视区域才开始播放视频等</li>
</ul>
<h1 id="使用SSR（server-side-render）服务端渲染，数据直接输出到HTML中"><a href="#使用SSR（server-side-render）服务端渲染，数据直接输出到HTML中" class="headerlink" title="使用SSR（server side render）服务端渲染，数据直接输出到HTML中"></a>使用SSR（server side render）服务端渲染，数据直接输出到HTML中</h1><p>ssr是Server-Side Rendering的简写，即由服务端负责渲染页面直出，亦即同构应用。程序的大部分代码都可以在服务端和客户端运行。在服务端vue组件渲染为html字符串，然后直接返回给客户端，在客户端生成dom和操作dom。</p>
<p>能在服务端渲染为html字符串得益于vue组件结构是基于vnode的。vnode是dom的抽象表达，它不是真实的dom，它是由js对象组成的树，每个节点代表了一个dom。因为vnode，所以在服务端vue可以把js对象解析为html字符串。同样在客户端vnode因为是存在内存之中的，操作内存总比操作dom快的多，每次数据变化需要更新dom时，新旧vnode树经过diff算法，计算出最小变化集，大大提高了性能。</p>
<p><strong>服务端渲染 SSR 的优缺点如下：</strong></p>
<p>(1) 服务端渲染的优点：</p>
<ul>
<li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面</li>
<li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间</li>
</ul>
<p>(2) 服务端渲染的缺点：</p>
<ul>
<li><p>更多的开发条件限制： <strong>例如服务端渲染只支持 beforCreate 和 created 两个钩子函数</strong>（因为服务端不是浏览器环境，window、document等都是浏览器才有的对象，或者使用JS-dom的包，可以模拟浏览器环境），这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境。</p>
</li>
<li><p>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p>
</li>
</ul>
<h1 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h1><ul>
<li>css放在head里面，JS放在body的底部</li>
<li>懒加载（图片懒加载、下拉加载更多）</li>
<li>减少对DOM查询，对DOM查询做缓存</li>
<li>减少DOM操作，多个操作尽量合并在一起执行</li>
</ul>
<h1 id="事件节流和防抖"><a href="#事件节流和防抖" class="headerlink" title="事件节流和防抖"></a>事件节流和防抖</h1><p>防抖:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 按钮提交场景：防止多次提交按钮，只执行最后提交的一次</span></span><br><span class="line"><span class="comment">// 服务端验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似</span></span><br><span class="line">    <span class="keyword">const</span> debounce = <span class="function">(<span class="params">fn,delay</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.call(<span class="built_in">this</span>.arguments)</span><br><span class="line">            &#125;,delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>节流：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动</span></span><br><span class="line"><span class="comment">// 缩放场景：监控浏览器resize</span></span><br><span class="line"><span class="comment">// 动画场景：避免短时间内多次触发动画引起性能问题</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn,delay</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tag = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tag)&#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            tag = <span class="literal">false</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                fn.call(<span class="built_in">this</span>.arguments)</span><br><span class="line">                tag = <span class="literal">true</span></span><br><span class="line">            &#125;,delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间戳实现节流函数</span></span><br><span class="line">    <span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn,delay</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">let</span> startTime = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> currentTime = <span class="built_in">Date</span>.now</span><br><span class="line">            <span class="keyword">let</span> remaining = delay - (currentTime -startTime)</span><br><span class="line">            <span class="function"><span class="title">clearTimeout</span>(<span class="params">timer</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(renmaining &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">                    startTime = <span class="built_in">Date</span>.now()</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    timer = <span class="built_in">setTimeout</span>(fn,remaining)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="使用DOMContentLoaded，尽早执行操作"><a href="#使用DOMContentLoaded，尽早执行操作" class="headerlink" title="使用DOMContentLoaded，尽早执行操作"></a>使用DOMContentLoaded，尽早执行操作</h1><p>相比window.oonload，需要页面的全部资源加载完成才会执行，包括了图片还有视频等等<br>而DOMContentLoaded，只要DOM渲染完成即可执行，此时的图片和视频可能还没有加载完</p>
<h1 id="减少对DOM的操作"><a href="#减少对DOM的操作" class="headerlink" title="减少对DOM的操作"></a>减少对DOM的操作</h1><ul>
<li>缓存DOM查询</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未缓存 DOM 查询</span></span><br><span class="line">    <span class="keyword">var</span> i</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>).length;i++)&#123;</span><br><span class="line">        <span class="comment">//todo</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//缓存 DOM 查询   使用一个变量接收查询到的DOM</span></span><br><span class="line">    <span class="keyword">var</span> pList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> i</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; pList.length;i++)&#123;</span><br><span class="line">        <span class="comment">//todo</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>合并DOM的操作</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">element.style.borderColor = <span class="string">&#x27;#f00&#x27;</span>;</span><br><span class="line">element.style.borderStyle = <span class="string">&#x27;solid&#x27;</span>;</span><br><span class="line">element.style.borderWidth = <span class="string">&#x27;1px&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line">element.style.cssText += <span class="string">&#x27;border: 1px solid #f00;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>减少对DOM的操作，是为了减少重排和重绘。</p>
<p>重排会占用CPU，dom元素位置计算会消耗CPU的算力，所以应该尽量减少CPU的占用，使电脑不卡顿。<br>重绘会占用GPU，渲染页面时会消耗GPU的算力。</p>
<p>GPU的分类：</p>
<ul>
<li><p>家用GPU<br>适合做贴图、特效、光影等效果。不适合画图形。</p>
</li>
<li><p>专业GPU<br>适合画图形。不适合做贴图、特效、光影等效果。</p>
</li>
</ul>
<p>DOM操作基本就是画图形的，但浏览器中用的就是家用GPU，其画图形耗费的性能是专业GPU的几十倍。所以不提倡频繁用装有家用GPU的浏览器绘制页面。也就是不提倡频繁触发重绘。</p>
<h1 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h1><p>开发SPA项目的时候，项目中可能会存在很多的路由页面。如果我们将这些页面全部打包进一个JS文件的话，虽然说将多个请求合并了，但是同样加载了很多不需要的代码，会耗费更长的时间，所以首页能加载的文件体积需要越小越好，所以这个时候可以使用按需加载。</p>
<h2 id="按需加载组件"><a href="#按需加载组件" class="headerlink" title="按需加载组件"></a>按需加载组件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> tab <span class="keyword">from</span> <span class="string">&#x27;./tab0&#x27;</span></span><br><span class="line"><span class="keyword">const</span> tab0 = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;./tab0&#x27;</span>],resolve)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">	components:&#123;</span><br><span class="line">		Tab0</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="按需加载路由"><a href="#按需加载路由" class="headerlink" title="按需加载路由"></a>按需加载路由</h2><ol>
<li>vue异步加载组件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">  path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">  name: <span class="string">&#x27;Home&#x27;</span>, </span><br><span class="line">  component: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/components/home&#x27;</span>],resolve) </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>webpack 的 require.ensure() </li>
</ol>
<ul>
<li>   dependencies: 依赖的模块数组</li>
<li>   callback: 回调函数，该函数调用时会传一个require参数</li>
<li>   chunkName: 模块名，用于构建时生成文件时命名使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">    path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    component: <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([], <span class="function">() =&gt;</span> r(<span class="built_in">require</span>(<span class="string">&#x27;@/components/home&#x27;</span>)), <span class="string">&#x27;chunk&#x27;</span>) </span><br><span class="line">    <span class="comment">// r就是resolve</span></span><br><span class="line">    <span class="comment">// &#x27;chunk&#x27; 表示包名，相同的 chunk 名 会被打包到一起</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用动态的import()语法（推荐使用这种）</li>
</ol>
<p>vue中使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//没有指定webpackChunkName,每个组件打包成一个js文件</span></span><br><span class="line"><span class="keyword">const</span> test1 = <span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;@/components/test1.vue&#x27;</span>) </span><br><span class="line"><span class="keyword">const</span> test2 = <span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;@/components/test2.vue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定了相同的webpackChunkName，会合并打包成y一个js文件</span></span><br><span class="line"><span class="keyword">const</span> test3 = <span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&#x27;grounpTest&#x27; */</span> <span class="string">&#x27;@/components/test3.vue&#x27;</span>) </span><br><span class="line"><span class="keyword">const</span> test4 = <span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&#x27;grounpTest&#x27; */</span> <span class="string">&#x27;@/components/test4.vue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/test1&#x27;</span>, <span class="attr">component</span>: test1 &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/test2&#x27;</span>, <span class="attr">component</span>: test2 &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/test3&#x27;</span>, <span class="attr">component</span>: test3 &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/test4&#x27;</span>, <span class="attr">component</span>: test4 &#125;</span><br><span class="line">    ]</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<p>注：/* webpackChunkName: ‘grounpTest’ */使用命名chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack &gt; 2.4)</p>
<h1 id="前端SEO优化"><a href="#前端SEO优化" class="headerlink" title="前端SEO优化"></a>前端SEO优化</h1><ul>
<li>合理的 title 、 description 、 keywords ：搜索对着三项的权重逐个减⼩， title 值强调重点即可，重要关键词出现不要超过2次，⽽且要靠前，不同⻚⾯ title 要有所不 同； description 把⻚⾯内容⾼度概括，⻓度合适，不可过分堆砌关键词，不同⻚⾯ description 有所不同； keywords 列举出重要关键词即可 </li>
<li>语义化的 HTML 代码，符合W3C规范：语义化代码让搜索引擎容易理解⽹⻚<br>重要内容 HTML 代码放在Y前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓 取⻓度有限制，保证重要内容⼀定会被抓取 </li>
<li>重要内容不要⽤ js 输出：爬⾍不会执⾏js获取内容 </li>
<li>少⽤ iframe ：搜索引擎不会抓取 iframe 中的内容 </li>
<li>⾮装饰性图⽚必须加 alt 提⾼⽹站速度</li>
<li>⽹站速度是搜索引擎排序的⼀个重要指标</li>
</ul>
<h1 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h1><ol>
<li>不⽤图⽚。很多时候会使⽤到很多修饰类图⽚，其实这类修饰图⽚完全可以⽤ CSS 去代替（或者使用阿里的iconfont）</li>
<li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。⼀般图⽚都⽤ CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图⽚ </li>
<li>⼩图使⽤ base64 格式将图片内嵌到html 中，减少网站HTTP 的请求数量</li>
<li>将多个图标⽂件整合到⼀张图⽚中（雪碧图）</li>
<li>选择正确的图⽚格式： </li>
</ol>
<ul>
<li>对于能够显示 WebP 格式的浏览器尽量使⽤ WebP 格式。因为 WebP 格式具有更好 的图像数据压缩算法，能带来更⼩的图⽚体积，⽽且拥有⾁眼识别⽆差异的图像质量， 缺点就是兼容性并不好 </li>
<li>⼩图使⽤ PNG ，其实对于⼤部分图标这类图⽚，完全可以使⽤ SVG 代替</li>
<li>照⽚使⽤ JPEG</li>
</ul>
<h1 id="其他优化手段"><a href="#其他优化手段" class="headerlink" title="其他优化手段"></a>其他优化手段</h1><h2 id="利用多个域名存储网站资源"><a href="#利用多个域名存储网站资源" class="headerlink" title="利用多个域名存储网站资源"></a>利用多个域名存储网站资源</h2><ol>
<li><p>CDN缓存更方便（可以根据不同的资源类型（图片、音频、视频等）分别存储在cdn节点上）</p>
</li>
<li><p>突破浏览器并发限制（一般每个域名建立的链接不超过6个）</p>
</li>
<li><p>Cookieless，节省带宽，尤其是上行带宽一般比下行要慢（如果图片放在主站，那么每次请求图片的话都会携带cookie但是没必要，浪费了带宽）</p>
</li>
<li><p>对于UGC（用户生成内容，即用户原创内容）和主站隔离，防止不必要的安全问题(上传js窃取主站cookie之类的)。正是这个原因要求用户内容的域名必须不是自己主站的子域名，而是一个完全独立的第三方域名</p>
</li>
<li><p>节约主域名的连接数，优化页面的响应速度</p>
</li>
</ol>
<h2 id="尽量少使用iframe"><a href="#尽量少使用iframe" class="headerlink" title="尽量少使用iframe"></a>尽量少使用iframe</h2><ul>
<li>iframe 会阻塞主⻚⾯的 Onload 事件 </li>
<li>搜索引擎的检索程序⽆法解读这种⻚⾯，不利于 SEO </li>
<li>iframe 和主⻚⾯共享连接池，⽽浏览器对相同域的连接有限制，所以会影响⻚⾯的并⾏ 加载 使⽤ iframe 之前需要考虑这两个缺点。</li>
<li>如果需要使⽤ iframe ，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题</li>
</ul>
<h2 id="编程风格优化"><a href="#编程风格优化" class="headerlink" title="编程风格优化"></a>编程风格优化</h2><ol>
<li>少声明全局变量（占内存），缓存DOM节点查找的结果（消耗cpu），减少磁盘的I/O读取操作</li>
</ol>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/54cc04190252">深入理解浏览器的缓存机制</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/59a50dc1f265da246e6e108f">web前端资源文件的部署和优化</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/59b73ef75188253db70acdb5">前端性能优化之加载技术</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/06/css/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/06/css/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">浏览器的渲染机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-06 16:06:24" itemprop="dateCreated datePublished" datetime="2019-07-06T16:06:24+08:00">2019-07-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="DOCTYPE及其作用"><a href="#DOCTYPE及其作用" class="headerlink" title="DOCTYPE及其作用"></a>DOCTYPE及其作用</h1><p>由于历史的原因，浏览器对页面的渲染方式是不一样的。在 W3C 标准出来之前，浏览器对页面的渲染没有同一的标准，产生了差异，quirks mod（混杂模式或者兼容模式），但在W3C标准出台之后，浏览器对页面的渲染有了同一的标准即（严格模式或标准模式）。但是为了保证以前旧的页面仍然正常显示，有的浏览器就保存了这两种渲染模式（标准兼容模式）。那么究竟采用哪一种方式进行渲染，就要看DOCTYPE生命中的DTD。</p>
<p><strong>文档类型定义（DTD）Document Type Definition</strong> </p>
<p>简单说 DOCTYPE 是用来声明<strong>文档类型和DTD规范</strong> 的,告知浏览器的解析器用什么文档标准解析这个文档。，一个主要用途就是文件的合法性验证。如果文件代码不合法，那么浏览器解析的时候就会出错。<br>是一系列的语法规则，用来定义 XML 或者 HTML 的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式。<br>html5 不基于 SGML，因此不需要对 DTD 进行引用，也就没有严格模式与宽松模式的区别，html5 有相对宽松的语法，事实上，已经尽可能大的实现了向后兼容（老版本）。</p>
<p>常见的html的DOCTYPE</p>
<p>HTML5 <!DOCTYPE html></p>
<p>HTML4 严格模式 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"> </p>
<p>HTML4 宽松模式 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"></p>
<p>这里可以看到严格模式和宽松模式的区别主要在于后缀的dtd文件的引用。严格模式不包含展示性和弃用元素（比如font），宽松模式包含所有的 HTML 元素和属性。</p>
<h1 id="浏览器的渲染机制"><a href="#浏览器的渲染机制" class="headerlink" title="浏览器的渲染机制"></a>浏览器的渲染机制</h1><p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/tree.png" alt="markdown"></p>
<p>要了解浏览器的渲染机制，需要先明白以下的概念：</p>
<ol>
<li>DOM：Document Object Model（文档对象模型），当我们打开⼀个⽹⻚时，浏览器都会去请求对应的 HTML ⽂件。虽然平时我 们写代码时都会分为 JS 、 CSS 、 HTML ⽂件，也就是字符串，但是计算机 硬件是不理解这些字符串的，所以在⽹络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，浏览器会有html解析器进行解析，它会将这些字节数据转换为 字符串，也就是我们写的代码。（字节流转换成为字符流）</li>
</ol>
<p>当数据转换为字符串以后，浏览器会先将这些字符串通过<strong>词法分析转换为标记 （ token ）</strong>，这⼀过程在词法分析中叫做标记化（ tokenization ）。</p>
<p>那么什么是标记呢？这其实属于编译原理这⼀块的内容了。简单来说，标记还 是字符串，是构成代码的⼩单位。这⼀过程会将代码分拆成⼀块块，并给这 些内容打上标记，便于理解这些⼩单位的代码是什么意思。</p>
<p>当结束标记化后，<strong>通过词法分析</strong>，这些标记会紧接着转换为 Node ，这些 Node 会根据 不同 Node 之前的联系构建为树形的数据结构，称为 DOM 树。</p>
<ol start="2">
<li><p>CSSOM：CSS Object Model，浏览器将CSS解析成树形的数据结构，简称CSSOM（步骤类似上一步）。</p>
</li>
<li><p>Render Tree: DOM和CSSOM合并后生成Render Tree(但是如果遇到script标签的时候，会执行并阻塞渲染)。</p>
</li>
</ol>
<p>在这⼀过程中，不是简单的将两者合并就⾏了。渲染树只会包括需要显示的节点和这些节 点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。</p>
<ol start="4">
<li><p>Layout: 计算出Render Tree每个节点的具体位置。（布局）</p>
</li>
<li><p>Painting：通过显卡，开始调用 GPU 绘制，合成图层，将Layout后的节点内容分别呈现到屏幕上。（渲染）</p>
</li>
</ol>
<p>PS：</p>
<ul>
<li>css加载不会阻塞DOM树的解析。</li>
<li>css和script的加载会阻塞DOM树的渲染（白屏）。</li>
<li>css加载会阻塞后面js语句的执行，但是不会阻塞外部脚本的加载（因为 Renderer 进程中 JS 线程和渲染线程是互斥的）。</li>
</ul>
<h1 id="重排（回流）Reflow-（引起DOM树重新计算的行为）"><a href="#重排（回流）Reflow-（引起DOM树重新计算的行为）" class="headerlink" title="重排（回流）Reflow （引起DOM树重新计算的行为）"></a>重排（回流）Reflow <strong>（引起DOM树重新计算的行为）</strong></h1><p>DOM结构中的各个元素都有自己的盒子，这些都需要浏览器根据各种样式来计算，并根据计算结果将元素放到它该出现的位置，这个过程称为reflow。<br>以下是触发reflow的几种方法：</p>
<ol>
<li>增加、删除、修改DOM节点的时候，会导致Reflow。</li>
<li>移动DOM的位置，或者生成动画的时候。</li>
<li>修改CSS样式的时候。</li>
<li>Resize窗口的时候（移动端没有这个问题），或者滚动的时候。</li>
<li>修改网页的默认字体时。</li>
<li>获取某些属性，包括offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle()，<strong>获取时应当做适当的缓存</strong>。</li>
</ol>
<p>PS: 针对以上的第六点，为什么会导致获取某些属性的时候会导致浏览器的重排？</p>
<p>现代浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是<strong>当你获取布局信息的操作的时候，为了获取更加准确的信息，会强制队列刷新，也刷新了缓冲区域</strong>，所以必要的时候，获取的时候需要做适当的缓存。</p>
<h1 id="重绘Repaint-（元素样式的改变触发浏览器的行为）"><a href="#重绘Repaint-（元素样式的改变触发浏览器的行为）" class="headerlink" title="重绘Repaint （元素样式的改变触发浏览器的行为）"></a>重绘Repaint <strong>（元素样式的改变触发浏览器的行为）</strong></h1><p>当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称为Repaint。</p>
<p>触发Repaint</p>
<ol>
<li>DOM改动</li>
<li>CSS改动</li>
</ol>
<p>重排一定会导致重绘（改变网页的位置），但是重绘不一定会导致重排（如颜色的改变）。</p>
<p>减少重排的几个方法：</p>
<ul>
<li>样式集中改变，减少对 DOM 的操作。</li>
<li>对于多次重排的元素，使用 absolute 或者 fixed 脱离文档流。</li>
<li>尽量减少使用 table 布局，因为一个小的改动会导致整个 table 的重新布局，通常要浪费同等元素的时间的3倍。</li>
<li>不要在布局信息改变的时候做 DOM 查询。</li>
<li>动画元素脱离文档流（浮动、绝对定位和固定定位），减少回流的 Render Tree 的规模。</li>
<li>使用 opacity 替代 visibility，因为 visibility 会触发重绘，而使用 opacity 不会。</li>
<li>使用 visibility 替换 display:none，因为前者只会引起重绘，后者会引起回流改变布局。</li>
<li>通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）。</li>
</ul>
<p>PS：为什么操作DOM非常昂贵？</p>
<p><strong>操作DOM会导致重排和重绘，重排会占用、消耗CPU; 重绘会占用、消耗GPU。操作频繁会使得电脑卡顿</strong></p>
<h1 id="回流与重绘相关的eventLoop"><a href="#回流与重绘相关的eventLoop" class="headerlink" title="回流与重绘相关的eventLoop"></a>回流与重绘相关的eventLoop</h1><ul>
<li>当 Event loop 执⾏完 Microtasks 后，会判断 document 是否需要更新。- 因为浏览 器是 60Hz 的刷新率，每 16ms 才会更新⼀次。 </li>
<li>然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是⾄少 16ms 才会触发⼀次，并且⾃带节流功能。 </li>
<li>判断是否触发了 media query 。</li>
<li>更新动画并且发送事件。</li>
<li>判断是否有全屏操作事件 执⾏ requestAnimationFrame 回调 执⾏ IntersectionObserver 回调，该⽅法⽤于判断元素是否可⻅，可以⽤于懒加载上，但是兼容性不好。</li>
<li>更新界⾯。</li>
</ul>
<p>以上就是⼀帧中可能会做的事情。如果在⼀帧中有空闲时间，就会去执⾏ requestIdleCallback 回调。</p>
<h1 id="输入URL到浏览器显示页面发生了什么"><a href="#输入URL到浏览器显示页面发生了什么" class="headerlink" title="输入URL到浏览器显示页面发生了什么"></a>输入URL到浏览器显示页面发生了什么</h1><ol>
<li>在浏览器地址栏输⼊ URL</li>
<li>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 </li>
</ol>
<ul>
<li>如果资源未缓存，发起新请求 </li>
<li>如果已缓存，检验是否⾜够新鲜，⾜够新鲜直接提供给客户端，否则与服务器进⾏验 证。 </li>
<li>检验新鲜通常有两个HTTP头进⾏控制 Expires 和 Cache-Control ： HTTP1.0提供Expires，值为⼀个绝对时间表示缓存新鲜⽇期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的Y⼤新鲜时间</li>
</ul>
<ol start="3">
<li>浏览器解析URL获取协议，主机，端⼝，path </li>
<li>浏览器组装⼀个HTTP（GET）请求报⽂ </li>
<li>浏览器获取主机ip地址，过程如下： </li>
</ol>
<ul>
<li>浏览器缓存 </li>
<li>本机缓存 </li>
<li>hosts⽂件 </li>
<li>路由器缓存 </li>
<li>ISP DNS缓存 </li>
<li>DNS递归查询（可能存在负载均衡导致每次IP不⼀样） </li>
</ul>
<p>DNS 的作用就是通过域名查询到具体的 IP。</p>
<p>因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。</p>
<ul>
<li>浏览器输入 <a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a> 时，请求发起后，游览器首先会解析这个域名，首先它会查看<strong>本地硬盘的 hosts 文件</strong>，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</li>
<li>如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS 请求到<strong>本地DNS(域名分布系统)服务器</strong>。本地 DNS 服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</li>
<li>查询你输入的网址的 DNS 请求到达本地 DNS 服务器之后，本地 DNS 服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地 DNS 服务器还要向<strong>DNS根服务器进行查询</strong>，DNS 根服务器找出负责 com 这个⼀级域名的服务器 </li>
<li>根 DNS 服务器没有记录具体的域名和 IP 地址的对应关系，而是告诉本地 DNS 服务器，你可以到<strong>域服务器</strong>上去继续查询，并给出域服务器的地址。这种过程是迭代的过程</li>
<li>本地 DNS 服务器继续向域服务器发出请求，在这个例子中，请求的对象是 .com 域服务器。.com 域服务器收到请求之后，<strong>也不会直接返回域名和IP地址的对应关系</strong>，而是告诉本地 DNS 服务器，你的<strong>域名的解析服务器的地址</strong></li>
<li>最后，本地 DNS 服务器向域名的解析服务器发出请求，这时就能收到一个域名和 IP 地址对应关系，本地 DNS 服务器不仅要把 IP 地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</li>
</ul>
<p>本地硬盘 host 文件=&gt;本地 DNS 服务器(中国移动，中国电信)=&gt;根 DNS 服务器=&gt;域服务器=&gt;域名的解析服务器的地址=&gt;返回给本地 DNS 服务器，并作缓存。</p>
<ol start="6">
<li>打开⼀个 socket 与⽬标 IP 地址，端⼝建⽴ TCP 链接，三次握⼿如下： </li>
</ol>
<ul>
<li>客户端发送⼀个 TCP 的 SYN=1，Seq=X 的包到服务器端⼝ </li>
<li>服务器发回 SYN=1， ACK=X+1， Seq=Y 的响应包 </li>
<li>客户端发送 ACK=Y+1， Seq=Z </li>
</ul>
<ol start="7">
<li>服务器检查 HTTP 请求头是否包含缓存验证信息如果验证缓存新鲜，返回 304 等对应状态码 </li>
<li>处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作 </li>
<li>服务器将响应报⽂通过 TCP 连接发送回浏览器，关闭 TCP 连接四次挥手</li>
<li>浏览器接收 HTTP 响应，然后根据情况选择关闭 TCP 连接或者保留重⽤，关闭 TCP 连接的四 次握⼿如下： </li>
</ol>
<ul>
<li>主动⽅发送 Fin=1， Ack = Z， Seq = X 报⽂ </li>
<li>被动⽅发送 ACK = X+1， Seq = Z 报⽂ </li>
<li>被动⽅发送 Fin = 1， ACK = X， Seq = Y报⽂ </li>
<li>主动⽅发送 ACK = Y， Seq = X 报⽂ </li>
</ul>
<ol start="11">
<li>浏览器检查响应状态吗：是否为 1XX，3XX，4XX，5XX 这些情况处理与 2XX 不同</li>
<li>如果资源可缓存，进⾏缓存 </li>
<li>对响应进⾏解码（例如 gzip 压缩） </li>
<li>根据资源类型决定如何处理（假设资源为 HTML ⽂档）</li>
<li>解析 HTML ⽂档，构件 DOM 树，下载资源，构造 CSSOM 树，执⾏ js 脚本，这些操作没有严格的先后顺序，以下分别解释 </li>
<li>构建 DOM 树： </li>
</ol>
<ul>
<li>Tokenizing：根据 HTML 规范将字符流解析为标记 。</li>
<li>Lexing：词法分析将标记转换为对象并定义属性和规则 。</li>
<li>DOM construction：根据 HTML 标记关系将对象组成 DOM 树 。</li>
</ul>
<ol start="17">
<li>解析过程中遇到图⽚、样式表、js ⽂件，启动下载 。</li>
<li>构建 CSSOM 树： </li>
</ol>
<ul>
<li>Tokenizing：字符流转换为标记流。</li>
<li>Node：根据标记创建节点 。</li>
<li>CSSOM：节点创建 CSSOM 树 。</li>
</ul>
<ol start="19">
<li>根据 DOM 树和 CSSOM 树构建渲染树: </li>
</ol>
<ul>
<li>从 DOM 树的根节点遍历所有可⻅节点，不可⻅节点包括：<ul>
<li>script , meta 这样本身 不可⻅的标签。</li>
<li>被 css 隐藏的节点，如 display: none 。</li>
</ul>
</li>
<li>对每⼀个可⻅节点，找到恰当的 CSSOM 规则并应⽤ 。</li>
<li>发布可视节点的内容和计算样式 。</li>
</ul>
<ol start="20">
<li>js 解析如下： </li>
</ol>
<ul>
<li>浏览器创建 Document 对象并解析 HTML，将解析到的元素和⽂本节点添加到⽂档中，此时 document.readystate 为 loading 。</li>
<li>HTML解析器遇到没有 async 和 defer 的 script 时，将他们添加到⽂档中，然后执⾏⾏内 或外部脚本。这些脚本会同步执⾏，并且在脚本下载和执⾏时解析器会暂停。这样就可以⽤ document.write() 把⽂本插⼊到输⼊流中。同步脚本经常简单定义函数和注册事件 处理程序，他们可以遍历和操作 script 和他们之前的⽂档内容 。</li>
<li>当解析器遇到设置了 async 属性的 script 时，开始下载脚本并继续解析⽂档。脚本会在它下载完成后尽快执⾏，但是解析器不会停下来等它下载。异步脚本禁⽌使⽤ document.write()，它们可以访问⾃⼰ script和之前的⽂档元素。</li>
<li>当⽂档完成解析，document.readState变成interactive。</li>
<li>所有 defer 脚本会按照在⽂档出现的顺序执⾏，延迟脚本能访问完整⽂档树，禁⽌使⽤ document.write() 。</li>
<li>浏览器在 Document 对象上触发 DOMContentLoaded 事件 。</li>
<li>此时⽂档完全解析完成，浏览器可能还在等待如图⽚等内容加载，等这些内容完成载⼊ 并且所有异步脚本完成载⼊和执⾏，document.readState 变为 complete，window 触发 load 事件。</li>
</ul>
<ol start="21">
<li>显示⻚⾯。（HTML解析过程中会逐步显示⻚⾯）</li>
</ol>
<h1 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h1><p>传统的 javascript 动画是通过定时器 setTimeout 或者 setInterval 实现的。但是定时器动画一直存在两个问题，第一个就是动画的循时间环间隔不好确定，设置长了动画显得不够平滑流畅，设置短了浏览器的重绘频率会达到瓶颈，推荐的最佳循环间隔是 17ms（大多数电脑的显示器刷新频率是 60Hz，1000ms/60）；第二个问题是定时器第二个时间参数只是指定了多久后将动画任务添加到浏览器的 UI 线程队列中，如果<strong>UI线程处于忙碌状态，那么动画不会立刻执行（UI线程和JS线程也是互斥的）。</strong>为了解决这些问题，H5 中加入了 requestAnimationFrame。</p>
<p><strong>优点：</strong></p>
<ol>
<li>requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。</li>
<li>在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量。</li>
<li>requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销。</li>
</ol>
<p>须注意的是，requestAnimationFrame 也属于宏任务。使用方法和 setTimeout 一样。</p>
<h1 id="浏览器的工作原理"><a href="#浏览器的工作原理" class="headerlink" title="浏览器的工作原理"></a>浏览器的工作原理</h1><h2 id="进程和线程的概念"><a href="#进程和线程的概念" class="headerlink" title="进程和线程的概念"></a>进程和线程的概念</h2><ul>
<li><p>进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。（进程是一个工厂，工厂有它的独立资源，并且工厂之间相互独立）</p>
</li>
<li><p>线程：是进程中的一部分，一个没有线程的进程也可以被看作是单线程的，是 CPU 调度的一个基本单位。（线程是工厂中的工人，多个工人协作完成任务，一个工厂可以有一个或者多个工人，工人之间共享空间）</p>
</li>
</ul>
<p>进程之间的通信方式：</p>
<ul>
<li>无名管道：半双工通信方式（即数据只能在一个方向上流动），数据只能单向流动并且只能在具有亲缘关系的进程间使用。</li>
<li>有名管道：也是半双工通信方式，但是允许没有亲缘进程之间的通信。</li>
<li>高级管道：将另一个程序当作一个新的程序在当前程序进程中启动，则这个进程算是当前程序的子进程。</li>
<li>信号：用于通知接受进程某个事件已经发生。</li>
<li>消息队列：是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列 ID）来标识。</li>
<li>共享内存：指两个或多个进程共享一个给定的存储区。</li>
</ul>
<h2 id="浏览器的进程"><a href="#浏览器的进程" class="headerlink" title="浏览器的进程"></a>浏览器的进程</h2><h3 id="浏览器的单进程时代"><a href="#浏览器的单进程时代" class="headerlink" title="浏览器的单进程时代"></a>浏览器的单进程时代</h3><p>在前端处于刀耕火种的年代，微软通过在它的电脑设备上绑定了 ie 浏览器，逐渐的打败了昔日强敌网景，独霸整个 pc 时代。以 ie6 为例，这款浏览器就是典型的单进程浏览器，而且还是单线程浏览器。所以你可以想象，这个浏览器是奇慢无比，一个网页挂了就会导致浏览器里所有的页面都挂了。于是乎在后面的 ie 浏览器，通过多线程技术来试图提升浏览器的速度，但其实单进程无论怎么魔改，都会涉及到这些问题：</p>
<ol>
<li>不稳定。毕竟只要一个线程挂了就整个浏览器挂了，所以整个浏览器很不稳定。</li>
<li>不流畅。比如在通过网络获取资源，到渲染流程，如果浏览器上还有插件则还要考虑插件的运行，如果有一个脚本是死循环的，则导致所有页面都要等待这个脚本执行完毕，会导致整个页面十分的不流畅。并且单进程浏览器关闭一个页面也会存在内存泄漏的问题，毕竟不是多进程。多进程关掉一个页面相当于关掉一个进程，系统会自动回收资源。所以这样子会导致浏览器开的越久就越占用内存。</li>
<li>不安全。上面说到线程是可以共享进程里的资源的，如果一个插件是恶意的，它可以影响到整个浏览器，甚至可以控制你的电脑，来盗取账号密码。除了插件外，还有一些脚本可以通过钻漏洞来获取权限，引发很多严重的后果。</li>
</ol>
<h3 id="浏览器的多进程时代"><a href="#浏览器的多进程时代" class="headerlink" title="浏览器的多进程时代"></a>浏览器的多进程时代</h3><p>现代浏览器以 chrome 浏览器为例，目前的浏览器的多进程架构大致上是这样的：</p>
<ol>
<li>浏览器进程。该进程主要是负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>
<li>网络进程。该进程主要负责页面的网络资源加载，比如在地址栏输入一个网页地址，网络进程会将请求后得到的资源交给渲染进程处理。</li>
<li>渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。（浏览器的渲染进程是多线程的）</li>
<li>GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>
<li>插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ol>
<p>Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p>
<h1 id="webWorker实现多线程"><a href="#webWorker实现多线程" class="headerlink" title="webWorker实现多线程"></a>webWorker实现多线程</h1><p>Web Worker 是 HTML5 标准的一部分，这一规范定义了一套 API，它允许一段 JavaScript 程序运行在主线程之外的另外一个线程中。工作线程允许开发人员编写能够长时间运行而不被用户所中断的后台程序， 去执行事务或者逻辑，并同时保证页面对用户的及时响应，可以将一些大量计算的代码交给 web worker 运行而不冻结用户界面，web worker 就是为了解决这种花费大量时间的复杂运算而诞生的！</p>
<ul>
<li><p>允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</p>
</li>
<li><p>JS引擎线程与 worker 线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</p>
</li>
</ul>
<p>所以，如果有非常耗时的工作，请单独开一个 Worker 线程，这样里面不管如何翻天覆地都不会影响 JS 引擎主线程，只待计算出结果后，将结果返回给主线程即可。</p>
<p>而且注意下，JS 引擎是单线程的，这一点的本质仍然未改变，Worker 可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p>
<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d765572e51d45621320318e">现代浏览器工作原理（一）——浏览器进程</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leslie choi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
