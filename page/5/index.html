<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yoursite.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta property="og:type" content="website">
<meta property="og:title" content="404 not found">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="404 not found">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="leslie choi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/5/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;5&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>404 not found</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">404 not found</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">leslie choi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/23/JavaScript/%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9CDOM%E8%8A%82%E7%82%B9Api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/23/JavaScript/%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9CDOM%E8%8A%82%E7%82%B9Api/" class="post-title-link" itemprop="url">JS常见API</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-23 18:06:21" itemprop="dateCreated datePublished" datetime="2019-02-23T18:06:21+08:00">2019-02-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="获取DOM节点"><a href="#获取DOM节点" class="headerlink" title="获取DOM节点"></a>获取DOM节点</h1><p>第一个返回选中id，其余则是返回一个数组。所以注意是elements,并且获取的时候要使用elements[0]的数组形式获取否则报错</p>
<ul>
<li>document.getElementById()</li>
<li>document.getElementsByName()</li>
<li>document.getElementsByClassName()</li>
<li>document.getElementsByTagName()</li>
</ul>
<h1 id="修改样式"><a href="#修改样式" class="headerlink" title="修改样式"></a>修改样式</h1><ul>
<li>element.style.height = ‘100px’;</li>
<li>element.setAttribute(‘height’, ‘100px’);</li>
<li>element.setAttribute(‘style’, ‘height: 100px !important;width: 200px;’)</li>
<li>element.style.setProperty(‘height’, ‘300px’, ‘important’)</li>
<li>element.style.cssText += ‘height: 100px !important’</li>
</ul>
<h1 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h1><ol>
<li>它们创建的节点只是一个孤立的节点，要通过appendChild添加到文档中</li>
<li>cloneNode要注意如果被复制的节点是否包含子节点以及事件绑定等问题</li>
<li>使用createDocumentFragment来解决添加大量节点时的性能问题</li>
</ol>
<ul>
<li>createElement</li>
<li>createTextNode</li>
<li>cloneNode</li>
<li>createDocumentFragment</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Tea<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;myFunction()&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> node = <span class="built_in">document</span>.createElement(<span class="string">&quot;button&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> textnode = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;Water&quot;</span>);</span></span><br><span class="line">        node.appendChild(textnode);</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;myList&quot;</span>).appendChild(node);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h1><ol>
<li>不管是新增还是替换节点，如果新增或替换的节点是原本存在页面上的，则其原来位置的节点将被移除，也就是说同一个节点不能存在于页面的多个位置</li>
<li>节点本身绑定的事件会不会消失，会一直保留着</li>
</ol>
<ul>
<li>appendChild</li>
<li>insertBefore</li>
<li>removeChild</li>
<li>replaceChild</li>
</ul>
<p><strong>例子：创建元素后修改样式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">document</span>.createElement(<span class="string">&quot;button&quot;</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(p)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;button&quot;</span>)[<span class="number">0</span>].setAttribute(<span class="string">&quot;style&quot;</span>,<span class="string">&quot;display:none&quot;</span>)</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/19/JavaScript/JavaScript%E8%BF%9B%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/19/JavaScript/JavaScript%E8%BF%9B%E9%98%B6/" class="post-title-link" itemprop="url">javaScript高级（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-19 14:16:24" itemprop="dateCreated datePublished" datetime="2019-02-19T14:16:24+08:00">2019-02-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JavaScript高级"><a href="#JavaScript高级" class="headerlink" title="JavaScript高级"></a>JavaScript高级</h1><p>先来重新再认识一下JavaScript吧。JavaScript，其实是一门脚本、弱类型、轻量级的解释性语言。<br>针对解释性语言，不同于编译性语言。编译性语言编写的程序，在执行之前需要有一个专门的编译过程，把程序编译成机器语言的文件，比如exe。然后exe文件运行的时候，直接使用编译的结果就可以了，运行的时候不用再继续编译，所以<strong>执行效率高。具有独立性。</strong><br>而对于解释性语言，比如JavaScript，是<strong>非独立的</strong>，运行需要依赖环境，对于客户端是浏览器，对于服务端是node。<br><strong>效率低</strong>，执行前不需要编译，执行的时候才编译，因此效率也低。</p>
<h2 id="JavaScript的执行过程"><a href="#JavaScript的执行过程" class="headerlink" title="JavaScript的执行过程"></a>JavaScript的执行过程</h2><p>JavaScript 运行分为两个阶段：</p>
<ul>
<li>预解析<ul>
<li>全局预解析（所有变量和函数声明都会提前；同名的函数和变量函数的优先级高）</li>
<li>函数内部预解析（所有的变量、函数和形参都会参与预解析）<ul>
<li>函数</li>
<li>形参</li>
<li>普通变量</li>
</ul>
</li>
</ul>
</li>
<li>执行</li>
</ul>
<p>先预解析全局作用域，然后执行全局作用域中的代码，<br>在执行全局代码的过程中遇到函数调用就会先进行函数预解析，然后再执行函数内代码。</p>
<h2 id="apply和call方法的使用"><a href="#apply和call方法的使用" class="headerlink" title="apply和call方法的使用"></a>apply和call方法的使用</h2><p>apply和call作用是都可以<strong>改变函数执行时的上下文</strong> ，也就是说可以改变当前this的指向。apply和call方法也是函数的调用的方式。<br><strong>apply的使用语法</strong><br>​    函数名字.apply(对象,[参数1,参数2,…]);<br>​    方法名字.apply(对象,[参数1,参数2,…]);<br><strong>call的使用语法</strong><br>​    函数名字.call(对象,参数1,参数2,…);<br>​    方法名字.call(对象,参数1,参数2,…);</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;结果是:&quot;</span> + (x + y) + <span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// return &quot;10000&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// apply和call都可以让函数或者方法来调用,传入参数和函数自己调用的写法不一样,但是效果是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = f1.apply(<span class="literal">null</span>, [<span class="number">10</span>, <span class="number">20</span>]);</span><br><span class="line"><span class="keyword">var</span> result2 = f1.call(<span class="literal">null</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result1);  <span class="comment">//30 object window</span></span><br><span class="line"><span class="built_in">console</span>.log(result2);  <span class="comment">//30 object window</span></span><br></pre></td></tr></table></figure>

<p>apply和call方法中如果没有传入参数,或者是传入的是null,那么调用该方法的函数对象中的<strong>this就是默认的window</strong><br>两个方法的区别在于apply需要传入的是一个数组，而call不是。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这个函数是window对象的一个方法:&quot;</span> + (x + y) + <span class="built_in">this</span>.sex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.f1(<span class="number">10</span>, <span class="number">20</span>);    <span class="comment">// 30 undefined</span></span><br><span class="line"><span class="comment">//obj是一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    age: <span class="number">10</span>,</span><br><span class="line">    sex: <span class="string">&quot;男&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.f1.apply(obj, [<span class="number">10</span>, <span class="number">20</span>]);  <span class="comment">//  30 男</span></span><br><span class="line"><span class="built_in">window</span>.f1.call(obj, <span class="number">10</span>, <span class="number">20</span>);    <span class="comment">//同上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过原型添加方法</span></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;您好啊:&quot;</span> + <span class="built_in">this</span>.sex);</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="number">10</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">per.sayHi();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, sex</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> r1 = per.sayHi.apply(stu, [<span class="number">10</span>, <span class="number">20</span>]);</span><br><span class="line"><span class="keyword">var</span> r2 = per.sayHi.call(stu, <span class="number">40</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(r1);  <span class="comment">//男  30</span></span><br><span class="line"><span class="built_in">console</span>.log(r2);  <span class="comment">//男   60</span></span><br></pre></td></tr></table></figure>

<p>这两个方法的作用是：改变了this 的指向，并且第一个参数为你要传入的对象，传入后函数的this就指向了这个对象,后面的参数为你为函数传递的参数值。上面的两个数字就是sayHi方法中的两个参数。</p>
<h2 id="bind方法"><a href="#bind方法" class="headerlink" title="bind方法"></a>bind方法</h2><p>bind，就是复制一份的意思。<br>使用的语法是：</p>
<ul>
<li>函数名字.bind(对象,参数1,参数2,…);—-&gt;返回值是复制之后的这个函数</li>
<li>方法名字.bind(对象,参数1,参数2,…);—-&gt;返回值是复制之后的这个方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.play = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> + <span class="string">&quot;====&gt;&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//将play方法复制了一份，然后传给stu，但是里面传进的参数还是使用的是stu的</span></span><br><span class="line"><span class="keyword">var</span> ff = per.play.bind(stu);</span><br><span class="line">ff();    <span class="comment">//输出object 20</span></span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/19/JavaScript/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/19/JavaScript/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/" class="post-title-link" itemprop="url">原型与原型链</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-19 14:16:24" itemprop="dateCreated datePublished" datetime="2019-02-19T14:16:24+08:00">2019-02-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><p>想要了解原型和原型链，那我们首先来了解一下构造函数。<br>JavaScript不像Java一样，可以定义一个class。那在JavaScript中，想要定义一个类，就只能通过构造函数的模式。构造函数中拥有了类和实例的概念。构造函数其实就是一个普通的函数，创建的方式和普通的函数没有区别，但是 <strong>首字母需要大写</strong> ，另外普通函数可以直接调用，但是构造函数需要通过 <strong>new关键字来调用。</strong> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">        <span class="built_in">this</span>.gender = gender</span><br><span class="line">        <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(per); <span class="comment">//当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用prototype实现数据共享,利用原型添加方法</span></span><br><span class="line">  Person.ptototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我喜欢吃榴莲粥加辣椒&quot;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，每创建一个Person构造函数，在Person构造函数中，为每一个对象添加了一个sayName的方法，所以就是说构造函数每调用一次就会创建一个新的方法，如果调用了1000次就会创建1000个新的方法，而着1000个方法却都是一样的。所以为了节省空间和性能，<strong>需要把这些方法单独放到一个地方，并且可以让每一个实例都可以访问到，目的就是为了共享数据</strong> 所以这个时候就需要 <strong>原型prototype</strong> </p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>在javaScript中，每当定义一个<strong>函数数据类型</strong>（普通函数、类）的时候，都会天生自带一个prototype属性，这个属性指向函数的原型对象，并且这个属性是一个 <strong>对象数据类型值</strong> </p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/prototype1.PNG" alt="markdown"></p>
<p>所以原型对象相当于一个公共区域，所有同一个类的实例都可以访问到这个原型对象，因此可以将对象中的所有共有的内容，统一设置到原型对象中。<br>在JavaScript中，继承是基于原型的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过原型来添加方法，解决数据共享节省空间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">sex,age</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.sex=sex;</span><br><span class="line">      <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过原型添加方法</span></span><br><span class="line">    Person.prototype.sayHi=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;打招呼,您好&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> per=<span class="keyword">new</span> Person(<span class="string">&quot;男&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(per.__proto__.constructor==Person.prototype.constructor);<span class="comment">//实例对象</span></span><br><span class="line">    <span class="built_in">console</span>.dir(Person);<span class="comment">//构造函数的名字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> per2=<span class="keyword">new</span> Person(<span class="string">&quot;女&quot;</span>,<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(per.sayHi==per2.sayHi);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过原型共享数据</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,sex</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name=name;</span><br><span class="line">      <span class="built_in">this</span>.age=age;</span><br><span class="line">      <span class="built_in">this</span>.sex=sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所有学生的身高都是188,所有人的体重都是55</span></span><br><span class="line">    <span class="comment">//所有学生都要每天写500行代码</span></span><br><span class="line">    <span class="comment">//所有学生每天都要吃一个10斤的西瓜</span></span><br><span class="line">    <span class="comment">//原型对象</span></span><br><span class="line">    Student.prototype.height=<span class="string">&quot;188&quot;</span>;</span><br><span class="line">    Student.prototype.weight=<span class="string">&quot;55kg&quot;</span>;</span><br><span class="line">    Student.prototype.study=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;学习,写500行代码,小菜一碟&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    Student.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;吃一个10斤的西瓜&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//实例化对象,并初始化</span></span><br><span class="line">    <span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="string">&quot;晨光&quot;</span>,<span class="number">57</span>,<span class="string">&quot;女&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.dir(Student);</span><br><span class="line">    <span class="built_in">console</span>.dir(stu);</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>任何函数都具有一个 <code>prototype</code> 属性，该属性是一个对象</li>
<li>构造函数的 <code>prototype</code> 对象默认都有一个 <code>constructor</code> 属性，指向 <code>prototype</code> 对象所在函数</li>
<li>通过构造函数得到的实例对象内部会包含一个指向构造函数的 <code>prototype</code> 对象的指针 <code>__proto__</code></li>
<li>所有实例都直接或间接继承了原型对象的成员</li>
<li>原型对象中的方法是可以相互访问的</li>
</ul>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型链：是一种关系，实例对象和原型对象之间的关系，关系是通过原型__proto__来联系的</p>
<ol>
<li>__proto__和constructor<br>在JavaScript中，每一个对象数据类型（普通对象、实例、prototype…）也天生自带一个属性_proto_，属性值是当前实例所属类的原型（prototype）。原型对象中有一个属性constructor，指向函数对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person) <span class="comment">//true</span></span><br><span class="line"><span class="comment">//顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/prototype2.PNG" alt="markdown"></p>
<p>在JavaScript中，<strong>万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链</strong>。</p>
<p>举个栗子：person → People → Object ，普通人继承人类，人类继承对象类</p>
<p>所以当我们访问对象的一个属性或者方法，首先在对象自身中寻找，如果有的话泽直接使用，没有的话再到原型对象中寻找，直到找到Object对象，如果在Object对象中依然没有找到，则返回undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.a = <span class="number">123</span>;</span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person.a) <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> person) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>person实例中没有a这个属性，从 person 对象中找不到 a 属性就会从 person 的原型也就是 <code>person.__proto__</code> ，也就是 Person.prototype中查找，很幸运地得到a的值为123。<br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/prototype3.PNG" alt="markdown"></p>
<h2 id="简单的原型语法"><a href="#简单的原型语法" class="headerlink" title="简单的原型语法"></a>简单的原型语法</h2><p><strong>为了保证构造器contructor的指向正确，需要手动指向正确的构造函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">Person</span>, // =&gt; 手动将 <span class="title">constructor</span> 指向正确的构造函数</span><br><span class="line">  <span class="title">type</span>: &#x27;<span class="title">human</span>&#x27;,</span><br><span class="line">  <span class="title">sayHello</span>: <span class="title">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我叫&#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;，我今年&#x27;</span> + <span class="built_in">this</span>.age + <span class="string">&#x27;岁了&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建对象的几种方法"><a href="#创建对象的几种方法" class="headerlink" title="创建对象的几种方法"></a>创建对象的几种方法</h1><ol>
<li>使用字面量形式创建对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">name</span>: <span class="string">&#x27;o1&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;o2&#x27;</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过构造函数创建对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> fun(<span class="string">&#x27;o3&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过Object.create创建对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">name</span>:<span class="string">&#x27;pick&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o4 = <span class="built_in">Object</span>.create(p)  <span class="comment">//事实是根据原型链的原理，需要一个中间对象。o4.__proto__指向p。继承p的属性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="instanceof的原理"><a href="#instanceof的原理" class="headerlink" title="instanceof的原理"></a>instanceof的原理</h1><p>首先看一下这一张图片：</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/instanceof.png" alt="markdown"></p>
<p>instanceof运算符用来测试一个对象在其原型链中是否存在一个构造函数的prototype 属性</p>
<p>所以instanceof的原理，可以理解为，实例对象的__proto__属性和构造函数的prototype属性指向的是不是同一个地址。</p>
<p>下面通过一段代码来举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;james&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person);    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.__proto__ === Person.prototype);     <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>因为结果都是返回true，那么我们要怎么判断p1是由Person创建的实例还是由Object创建的实例呢？所以在这里需要使用到constructor属性了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.__proto__.constructor === Person);   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.__proto__.constructor === <span class="built_in">Object</span>);   <span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以使用constructor相对严谨一点。</p>
<h1 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h1><p>在代码中，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;james&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用了new运算符，在这个过程中：</p>
<ol>
<li>实际上是先创建了一个空对象</li>
<li>设置新对象的__proto__属性指向构造函数的prototype对象</li>
<li>绑定this，使用新对象调用函数，函数中的this被指向新实例对象</li>
<li>如果构造函数返回了一个“对象”，那么这个对象就会取代刚才new出来的结果（说明刚才的操作都是无效的）。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象</li>
</ol>
<h1 id="JS防止对象被篡改"><a href="#JS防止对象被篡改" class="headerlink" title="JS防止对象被篡改"></a>JS防止对象被篡改</h1><p>JS共享的本质一直是开发人员的心头痛。因为任何对象都可以被同一环境中运行的代码所修改，开发人员很可能意外地修改别人的代码，ES5也增加了几个方法，通过它们可以指定对象的行为。</p>
<p><strong>不过请注意：一旦把对象定义为防篡改，就无法撤销了。</strong></p>
<ul>
<li>不可扩展</li>
<li>密封的对象</li>
<li>冻结的对象 </li>
</ul>
<h2 id="不可拓展对象-不可添加、可以删除、可以修改、可以查"><a href="#不可拓展对象-不可添加、可以删除、可以修改、可以查" class="headerlink" title="不可拓展对象(不可添加、可以删除、可以修改、可以查)"></a>不可拓展对象(不可添加、可以删除、可以修改、可以查)</h2><p>对应有两个方法</p>
<ol>
<li>Object.preventExtension(obj) 禁止扩展</li>
<li>Object.isExtensible(obj) 判断是否可以扩展</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>:<span class="string">&quot;Nicholas&quot;</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.preventExtension(person)</span><br><span class="line">person.age = <span class="number">29</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age) <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(person))  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>虽然不能给对象添加新成员，但是已有的成员则丝毫不受影响，仍然可以修改和删除已有的成员，但是在严格模式下，尝试给不可拓展的对象添加新成员则会导致抛出错误。</p>
<h2 id="密封的对象-不可添加、不可删除、可以修改、可以查"><a href="#密封的对象-不可添加、不可删除、可以修改、可以查" class="headerlink" title="密封的对象(不可添加、不可删除、可以修改、可以查)"></a>密封的对象(不可添加、不可删除、可以修改、可以查)</h2><ul>
<li>Object.seal() 密封对象</li>
<li>Object.isSealed() 对象是否密封</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>:<span class="string">&quot;Nicholas&quot;</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.seal(person)</span><br><span class="line">person.age = <span class="number">29</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(person))  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age) <span class="comment">//undefined，如果使用严格模式的话，则会抛出错误</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(person))  <span class="comment">//false，因为密封对象不可拓展，所以返回false</span></span><br></pre></td></tr></table></figure>

<h2 id="冻结的对象-不可添加、不可删除、不可修改、可以查"><a href="#冻结的对象-不可添加、不可删除、不可修改、可以查" class="headerlink" title="冻结的对象 (不可添加、不可删除、不可修改、可以查)"></a>冻结的对象 (不可添加、不可删除、不可修改、可以查)</h2><p>最严格的防篡改级别是冻结对象。冻结的对象既不可扩展，又是密封的，而且对象数据属性的 [[Writable]] 特性会被设置为 false 。如果定义 [[Set]] 函数，访问器属性仍然是可写的。</p>
<ul>
<li>Object.freeze()</li>
<li>Object.isFrozen()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>:<span class="string">&quot;Nicholas&quot;</span>&#125;</span><br><span class="line">person.age = <span class="number">29</span></span><br><span class="line"><span class="built_in">Object</span>.freeze(person)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(person))  <span class="comment">//true，因为冻结对象也是密封对象</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age) <span class="comment">//undefined，如果使用严格模式的话，则会抛出错误</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(person))  <span class="comment">//false，因为冻结对象不可拓展，所以返回false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(person))    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/%E7%BD%91%E7%BB%9C/Http%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/12/%E7%BD%91%E7%BB%9C/Http%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">HTTP和TCP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-12 22:06:14" itemprop="dateCreated datePublished" datetime="2019-02-12T22:06:14+08:00">2019-02-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-21 00:53:51" itemprop="dateModified" datetime="2021-04-21T00:53:51+08:00">2021-04-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/TCP.png" alt="markdown"></p>
<p>互联网由一整套协议构成。</p>
<p>图片说明：顶层协议是应用层协议 =&gt; TCP协议 =&gt; IP协议 =&gt; 以太网协议（应用层=&gt;传输层=&gt;网络层=&gt;链路层）</p>
<p>以太网协议：最底层的协议，可以解决子网内部的点对点通讯。</p>
<p>IP 协议：IP 协议，可以解决多个局域网之间互通，可以连接多个局域网，定义了一套自己的地址规则，实现了路由的功能，允许某个局域网的 A 主机，向另一个局域网的 B 主机发送消息。（PS：路由器就是基于 IP 协议。所以局域网之间要靠路由器连接）</p>
<p>题外话：路由原理就是路由器内部有一张路由表，规定 A 段 IP 地址走出口一，B 段 IP 地址走出口二。。。根据这样实现了数据包的转发。</p>
<p>TCP 协议：IP 协议只是一个地址协议，并不能保证数据的完整性。如果缓存满了，新进来的数据包就会丢失，所以这个时候需要发现丢了哪一个包，以及如何重新发送这个包，所以这个时候需要使用到 TCP 协议。以太网数据包的负载是 1500 字节，TCP 数据包的负载在 1400 字节左右。</p>
<h2 id="TCP建立连接（三次握手）"><a href="#TCP建立连接（三次握手）" class="headerlink" title="TCP建立连接（三次握手）"></a>TCP建立连接（三次握手）</h2><p>HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</p>
<ul>
<li>第一次握手：建立连接时，客户端发送 syn 包（syn=1,seq=x）到服务器，并进入 SYN_SENT 状态，<strong>服务端得到结论：客户端的发送能力、服务端的接收能力正常。</strong></li>
<li>第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=x+1,seq=y），同时自己也发送一个 ACK 包，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态，客户端接收到，<strong>于是客户端得到结论：服务端的接收和发送能力正常，客户端的接收发送能力正常，但是此时服务器并不能确认客户端的接收能力是否正常</strong></li>
<li>第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=y+1,seq=z），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP连接成功）状态，<strong>服务端得到结论：客户端和服务端的接收发送能力都正常，完成三次握手。</strong></li>
</ul>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/sanwo.png" alt="markdown"></p>
<h2 id="TCP关闭连接（四次挥手）"><a href="#TCP关闭连接（四次挥手）" class="headerlink" title="TCP关闭连接（四次挥手）"></a>TCP关闭连接（四次挥手）</h2><p>由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。</p>
<ul>
<li>客户端 A 发送一个 FIN，用来关闭客户 A 到服务器B的数据传送，但是仍然可以接收数据( Fin_wait_1 )</li>
<li>服务器 B 收到这个 FIN，它发回一个 ACK 应答，表明接收到请求但是还未准备关闭连接，然后确认序号为收到的序号加1。和 SYN 一样，一个 FIN 将占用一个序号(服务端 closed_wait，客户端 Fin_wait_2)</li>
<li>服务器 B 关闭与客户端 A 的连接，发送一个 FIN 给客户端 A(服务端 Last_ack,客户端 time_wait)</li>
<li>客户端 A 发回 ACK 报文确认，并将确认序号设置为收到序号加1 (服务端 closed，然后经过 2MSL后服务端进入 closed)</li>
</ul>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/sihui.png" alt="markdown"></p>
<h2 id="UDP和TCP（User-Datagram-Protocol，用户数据报协议）的区别"><a href="#UDP和TCP（User-Datagram-Protocol，用户数据报协议）的区别" class="headerlink" title="UDP和TCP（User Datagram Protocol，用户数据报协议）的区别"></a>UDP和TCP（User Datagram Protocol，用户数据报协议）的区别</h2><ol>
<li>都是位于传输层，TCP 是面向连接的，而<strong>udp 是无连接的</strong>，即发送数据前不需要先建立连接</li>
<li>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达；UDP 尽最大努力交付，即不保证可靠交付。并且 TCP 可靠，面向连接不会丢失数据适合大数据量的传输</li>
<li>TCP 面向字节流，UDP 面向报文，并且网络阻塞不会使得发送的速率降低，所以会出现丢包（适合视频会议或者直播）。　</li>
<li>TCP 只能是一对一的，而 UDP 可以一对多</li>
<li>TCP 首部较大为20字节，UDP 只有8字节</li>
</ol>
<h2 id="如何实现UDP的可靠传输"><a href="#如何实现UDP的可靠传输" class="headerlink" title="如何实现UDP的可靠传输"></a>如何实现UDP的可靠传输</h2><p>TCP 是通过确认机制和超时重传机制实现可靠传输</p>
<p>UDP 它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用 UDP 较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照 tcp 可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<p>关键在于两点，从应用层角度考虑：</p>
<ol>
<li><p>提供超时重传，能避免数据包丢失。</p>
</li>
<li><p>提供确认序列号，可以对数据报进行确认和排序。</p>
</li>
</ol>
<p><strong>RUDP</strong></p>
<p>RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。在不干扰协议的实时特性的同时，可靠 UDP 的拥塞控制机制允许 TCP 方式下的流控制行为。</p>
<h1 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h1><p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/http.jpg" alt="markdown"></p>
<p>HTTP 协议是<strong>Hyper Text Transfer Protocol（超文本传输协议）</strong>的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议，也就是说所有的 www 服务器都必须要遵循这个标准。</p>
<p>HTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>
<p>HTTP 协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p>HTTP 请求由三部分组成，分别是：<strong>请求行、请求头、请求正文</strong></p>
<h2 id="http-的两个重要特点"><a href="#http-的两个重要特点" class="headerlink" title="http 的两个重要特点"></a>http 的两个重要特点</h2><p><strong>无连接：</strong> 限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。（但是随着网络的发展，每次都要建立一次 TCP 连接就显得很低效，后来，Keep-Alive 被提出用来解决这效率低的问题。）</p>
<p><strong>无状态：</strong> 指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是发送完，不会记录任何信息，于是，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。（简单场景购物车）</p>
<h2 id="http-报文"><a href="#http-报文" class="headerlink" title="http 报文"></a>http 报文</h2><p>用于 HTTP 协议交互的信息被称为 http 报文。HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CE+LF）来划分。通常，并不一定要有报文主体。在 http1.1 中，报文是通信的基本单位，由8位组字节流组成，用于 HTTP 通信。（http2.0采用二进制分帧）</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/%E6%8A%A5%E6%96%872.png" alt="markdown"></p>
<h3 id="http请求报文"><a href="#http请求报文" class="headerlink" title="http请求报文"></a>http请求报文</h3><ul>
<li>请求行：包含用于请求的方法，请求 uri 和 http 版本   （GET/HTTP/1.1）</li>
<li>请求头</li>
<li>空行</li>
<li>请求体：根据实际请求需要可能包含一个消息实体</li>
</ul>
<h3 id="http响应报文"><a href="#http响应报文" class="headerlink" title="http响应报文"></a>http响应报文</h3><ul>
<li>状态行：包含表明响应结果的 http 版本和状态码，状态描述 （HTTP/1.1 200 OK）</li>
<li>响应头：包括通用头部、响应头部和实体头部</li>
<li>空行</li>
<li>响应体</li>
</ul>
<h2 id="get-和-post-的主要区别"><a href="#get-和-post-的主要区别" class="headerlink" title="get 和 post 的主要区别"></a>get 和 post 的主要区别</h2><p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/get%26post.jpeg" alt="markdown"></p>
<p><strong>1. get在浏览器回退时是无害的，而post会再次请求。</strong><br><strong>2. get产生的url地址可以被收藏（即书签），而post不会。</strong><br>3. get请求会被浏览器主动缓存，而post不会，除非手动设置。<br>4. get请求只能进行url编码，而post支持多种编码方式。<br><strong>5. get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。</strong><br><strong>6. get 请求在url中传送的参数有长度限制（一般限制在2kb~8kb之间，但是更加常见的是在1kb之内，这个⻓度限制是浏览器规定的），而post没有（实际大小根据服务器情况而定）</strong><br>7. 对参数的数据类型，get只接受ascll字符，而post没有限制。<br>8. post比get更安全，因为参数直接暴露在url上，所以不能用来传递敏感信息。<br><strong>9. get参数通过url传递，poet放在request body中。</strong><br>10. GET产生一个TCP数据包;POST产生两个TCP数据包。</p>
<p>对于GET方式的请求，浏览器会把<strong>http header和data一并发送出去</strong>，服务器响应200(返回数据)</p>
<p>而对于POST，浏览器先发送**header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)**，这也就是为什么GET请求产生一个TCP数据包，而POST请求产生两个数据包。<br>但是在网络环境较好的情况下，发送一次包的时间和发送两次包的时间差别几乎是可以无视的。而在网络环境较差的情况下，发送两次包的TCP在验证数据包的完整性上，有非常大的优点。（但是并不是所有的浏览器都会在POST请求中发送两次包，Firefox就只发送一次。）</p>
<p>HTTP缺点：</p>
<ol>
<li>通信使用明文（ 不加密） ， 内容可能会被窃听。</li>
<li>不验证通信方的身份， 因此有可能遭遇伪装。</li>
<li>无法证明报文的完整性， 所以有可能已遭篡改。</li>
</ol>
<h2 id="Http的版本"><a href="#Http的版本" class="headerlink" title="Http的版本"></a>Http的版本</h2><ol>
<li>HTTP 0.9作为HTTP协议的第一个版本。是非常弱的。请求(Request)只有一行,比如: GET <a target="_blank" rel="noopener" href="http://www.leautolink.com./">www.leautolink.com。</a></li>
<li>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上。</li>
<li>HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。</li>
</ol>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/httpVersion.png" alt="markdown"></p>
<h2 id="http管线化"><a href="#http管线化" class="headerlink" title="http管线化"></a>http管线化</h2><p>在使用持久连接（因此低于HTTP1.1版本无法开启管线化）的情况下，某个连接消息的传递类似于</p>
<p>请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 - &gt; 响应3</p>
<p>管线化：某个连接上的消息变成了类似这样 </p>
<p>请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3</p>
<ol>
<li>那么持久连接和管线化的区别在于：</li>
</ol>
<p>持久连接的一个缺点是请求和响应式是顺序执行的，只有在请求1的响应收到之后，才会发送请求2，而管线化不需要等待上一次请求得到响应就可以进行下一次请求。<strong>实现并行发送请求。</strong> </p>
<ol start="2">
<li><p>只有GET和HEAD要求可以进行管线化，而POST则有所限制。</p>
</li>
<li><p>初次创建连接时也不应启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议。</p>
</li>
<li><p>HTTP1.1要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败，并且开启管线化很可能不会带来大幅度的性能提升，而且现在很多服务器端和代理程序对管线化的支持并不好，现代浏览器Chrome和Firefox默认并未开启管线化支持。</p>
</li>
</ol>
<h2 id="http-1-1-做了哪些升级"><a href="#http-1-1-做了哪些升级" class="headerlink" title="http 1.1 做了哪些升级"></a>http 1.1 做了哪些升级</h2><p><strong>缓存处理：</strong> 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</p>
<p><strong>带宽优化及网络连接的使用：</strong> HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
<p><strong>错误通知的管理：</strong> 在 HTTP1.1 中新增了24个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<p><strong>Host头处理：</strong> 在HTTP1.0 中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</p>
<p><strong>长连接（持久连接）：</strong> HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection：keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。</p>
<h2 id="Http-1-1-中的八种方法"><a href="#Http-1-1-中的八种方法" class="headerlink" title="Http 1.1 中的八种方法"></a>Http 1.1 中的八种方法</h2><ul>
<li><p>OPTIONS:<br>这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用 ‘*’ 来代替资源名称,向 Web 服务器发送 OPTIONS 请求,可以测试服务器功能是否正常运作。</p>
</li>
<li><p>HEAD:<br>与 GET 方法一样,都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于,使用这个方法可以在不必传输全部内容的情况下,就可以获取其中“关于该资源的信息”(元信息或称元数据)。</p>
</li>
<li><p>GET:<br>向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据,而不应当被用于产生“副作用”的操作中,例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访问。参见安全方法</p>
</li>
<li><p>POST:<br>向指定资源提交数据,请求服务器进行处理(例如提交表单或者上传文件)。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源,或二者皆有。</p>
</li>
<li><p>PUT:<br>向指定资源位置上传其最新内容。</p>
</li>
<li><p>DELETE:<br>请求服务器删除 Request-URI 所标识的资源。</p>
</li>
<li><p>TRACE:<br>回显服务器收到的请求,主要用于测试或诊断。</p>
</li>
<li><p>CONNECT:<br>把请求连接转换到透明的 TCP/IP 通道。通常用于 SSL 加密服务器的链接(经由非加密的 HTTP 代理服务器)。</p>
</li>
</ul>
<h2 id="几个常见的Content-Type"><a href="#几个常见的Content-Type" class="headerlink" title="几个常见的Content-Type"></a>几个常见的Content-Type</h2><p><strong>第一类：raw 原始类型，可以上传任意格式的文本，比如 text、json、xml、html（中文不进行编码）</strong></p>
<ul>
<li><p>text/html  ：HTML格式</p>
</li>
<li><p>text/plain ：纯文本格式      </p>
</li>
<li><p>text/xml   ：XML格式</p>
</li>
<li><p>image/gif  ：gif图片格式    </p>
</li>
<li><p>image/jpeg ：jpg图片格式 </p>
</li>
<li><p>image/png  ：png图片格式</p>
</li>
<li><p>application/xml     ： XML数据格式</p>
</li>
<li><p>application/json    ： JSON数据格式</p>
</li>
<li><p>application/pdf     ： pdf格式  </p>
</li>
<li><p>application/msword  ： Word文档格式</p>
</li>
<li><p>application/octet-stream ： 二进制流数据（如文件下载）</p>
</li>
</ul>
<p><strong>第二类：application/x-www-form-urlencoded，会将表单内的数据转换拼接成 key-value 对</strong></p>
<ul>
<li>application/x-www-form-urlencoded ：</li>
</ul>
<p><code>&lt;form encType=&quot;&quot;&gt;</code>中默认的encType，<br>form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）。<br>服务器收到的raw body会是，name=aaa&amp;key=bbb。</p>
<p><strong>第三类：multipart/form-data，将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件</strong></p>
<ul>
<li>multipart/form-data ： 表单上传文件</li>
</ul>
<h2 id="常用的-HTTP-请求头与响应头"><a href="#常用的-HTTP-请求头与响应头" class="headerlink" title="常用的 HTTP 请求头与响应头"></a>常用的 HTTP 请求头与响应头</h2><p>请求头：</p>
<ul>
<li>Accept            可接受的响应内容类型（Content-Types）           Accept: text/plain</li>
<li>Accept-Language   可接受的响应内容语言列表                        Accept-Language: en-US</li>
<li>Cache-Control     用来指定当前的请求/回复中的，是否使用缓存机制     Cache-Control: no-cache</li>
<li>Host              表示服务器的域名以及服务器所监听的端口号          Host: <a target="_blank" rel="noopener" href="http://www.itbilu.com/">www.itbilu.com:80</a></li>
<li>Origin            发起一个针对跨域资源共享的请求                   Origin: <a target="_blank" rel="noopener" href="http://www.itbilu.com/">http://www.itbilu.com</a></li>
<li>If-Modified-Since 允许在对应的资源未被修改的情况下返回304未修改     If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT    </li>
</ul>
<p>响应头：</p>
<ul>
<li>Access-Control-Allow-Origin     指定哪些网站可以跨域源资源共享      Access-Control-Allow-Origin: *</li>
<li>ETag     对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列  ETag: “737060cd8c284d8af7ad3082f209582d”    </li>
<li>Last-Modified        所请求的对象的最后修改日期          Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT</li>
<li>Expires              指定一个日期/时间，超过该时间则认为此回应已经过期  Expires: Thu, 01 Dec 1994 16:00:00 GMT</li>
</ul>
<h1 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h1><p>Https协议其实是基于Http的，多了个s其实就是Secure，所以也就是<strong>Hypertext Transfer Protocol Secure（超文本传输安全协议）</strong><br>相对于HTTP协议，具有以下优点：</p>
<ol>
<li>内容加密：采用混合加密技术，中间者无法直接查看明文内容。</li>
<li>验证身份：通过证书认证客户端访问的是自己的服务器。</li>
<li>保护数据完整性：防止传输的内容被中间人冒充或者篡改。<br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/https.png" alt="markdown"></li>
</ol>
<h2 id="SSL和TLS"><a href="#SSL和TLS" class="headerlink" title="SSL和TLS"></a>SSL和TLS</h2><p>HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。TLS与SSL在传输层对网络连接进行加密，在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。</p>
<p><strong>对称加密（通信过程）：</strong></p>
<p>对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。<br>这种加密方式固然很好，但是问题就在于如何让双方知道秘钥。因为传输数据都是走的网络，如果将秘钥通过网络的方式传递的话，一旦秘钥被截获就没有加密的意义的。</p>
<p><strong>非对称加密（认证过程）：</strong></p>
<p>有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道（服务端）。<br>这种加密方式就可以完美解决对称加密存在的问题。假设现在两端需要使用对称加密，那么在这之前，可以先使用非对称加密交换秘钥。</p>
<p>简单流程如下：首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了。</p>
<h2 id="SSL-TLS-四次握手"><a href="#SSL-TLS-四次握手" class="headerlink" title="SSL/TLS 四次握手"></a>SSL/TLS 四次握手</h2><p>四次握手主要交换了3个信息：</p>
<ol>
<li>数字证书：该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是信赖的CA签发的，或者与本地的证书相比，来判断证书是否可信，防止身份被冒充。</li>
<li>三个随机数。</li>
<li>加密通信协议。</li>
</ol>
<p><strong>四次握手过程</strong></p>
<ul>
<li>客户端发送通信请求，和第一个随机数 N1。</li>
<li>服务器确定加密通信协议的版本，然后返回 CA 机构签发的数字证书和公钥以及第二个随机数 N2，确认加密方法。</li>
<li>客户端验证证书的合法性，使用证书中的公钥和 HASH 算法对消息进行加密，返回服务端第三个随机数 N3。</li>
<li>服务端使用私密对消息进行解密，验证 HASH，N1+N2+N3 生成对话密钥，进行对称通信。</li>
</ul>
<p>理论上只要服务端私钥不泄露就无法被破解。</p>
<p><strong>HTTPS优缺点:</strong></p>
<p><strong>优点：</strong></p>
<ul>
<li>内容加密：无法直接查看明文内容</li>
<li>验证身份：CA 签发证书判断是否访问自己的服务器</li>
<li>保证数据完整性：防止传输内容被窜改</li>
<li>在谷歌 搜索引擎中排名更高</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>成本高，证书费用大</li>
<li>握手耗时延长 50%，耗电增加 10%到20%</li>
<li>连接缓存不如 http 高效，会增加性能功耗</li>
<li>SSL 证书需要绑定 IP，不能在同一个 IP 上绑定多个域名</li>
</ul>
<h1 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h1><p>HTTP/2 相比于 HTTP/1，可以说是大幅度提高了网页的性能。</p>
<h2 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h2><p>HTTP/2 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP/2 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</p>
<p>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</p>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>在 HTTP/1 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p>
<p>多路复用允许同时通过单一的HTTP/2 连接发起多重的请求响应消息。有了新的分帧后。HTTP/2 不再依赖多个TCP连接去实现多流并行了，每个数据流拆分成很多互不依赖的帧，还可以分优先级。不必通过多个 TCP 连接去实现并行执行，避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p>
<h2 id="header压缩"><a href="#header压缩" class="headerlink" title="header压缩"></a>header压缩</h2><p>HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP/2 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。</p>
<h2 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h2><p>服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确地请求。</p>
<p>可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。</p>
<h1 id="http3-0"><a href="#http3-0" class="headerlink" title="http3.0"></a>http3.0</h1><p>虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，虽然这个问题并不是它本身造成的，而是底层支撑的 TCP 协议的问题。</p>
<p>因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。</p>
<p>因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。</p>
<p>那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。</p>
<p><strong>基于这个原因，Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。</strong></p>
<h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><p>UDP 这个协议虽然效率很高，但是并不是那么的可靠。QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。</p>
<h3 id="多路复用-1"><a href="#多路复用-1" class="headerlink" title="多路复用"></a>多路复用</h3><p>虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。</p>
<p>并且 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是<strong>基于 IP 和端口</strong>去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。</p>
<h3 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h3><p>通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。</p>
<h3 id="纠错机制"><a href="#纠错机制" class="headerlink" title="纠错机制"></a>纠错机制</h3><p>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。</p>
<p><strong>当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。</strong></p>
<p>当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="为什么连接的时候是三次握手，关闭的时候却是四次挥手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次挥手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次挥手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次挥手？</h2><p>ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当 Server 端收到FIN报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉 Client 端，”你发的 FIN 报文我收到了”。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四次挥手。</p>
<h2 id="为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？"><a href="#为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？" class="headerlink" title="为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？"></a>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h2><p>虽然按道理，四个报文都发送完毕，我们可以直接进入 CLOSE 状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。在 Client 发送出最后的ACK回复，但该 ACK 可能丢失。Server 如果没有收到 ACK，将不断重复发送FIN片段。所以 Client 不能立即关闭，它必须确认 Server 接收到了该 ACK。Client 会在发送出ACK之后进入到 TIME_WAIT 状态。Client会设置一个计时器，等待 2MSL 的时间。如果在该时间内再次收到 FIN，那么 Client 会重发 ACK 并再次等待 2MSL。所谓的 2MSL 是两倍的 MSL(Maximum Segment Lifetime)。MSL 指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到FIN，那么 Client 推断ACK已经被成功接收，则结束 TCP 连接。</p>
<h2 id="为什么不能用两次握手进行连接？"><a href="#为什么不能用两次握手进行连接？" class="headerlink" title="为什么不能用两次握手进行连接？"></a>为什么不能用两次握手进行连接？</h2><p>3 次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p>
<p><strong>现在把三次握手改成仅需要两次握手，死锁是可能发生的。</strong>作为例子，考虑计算机 S 和 C 之间的通信，假定 C 给 S 发送一个连接请求分组，S 收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C 在 S 的应答分组在传输中被丢失的情况下，将不知道 S 是否已准备好，不知道 S 建立什么样的序列号，C 甚至怀疑 S 是否收到自己的连接请求分组。在这种情况下，C 认为连接还未建立成功，将忽略 S 发来的任何数据分 组，只等待连接确认应答分组。而 S 在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>
<h2 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>TCP 还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若 2 小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75S 发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h2 id="HTTP-2的多路复用和HTTP1-1中的长连接复用有什么区别？"><a href="#HTTP-2的多路复用和HTTP1-1中的长连接复用有什么区别？" class="headerlink" title="HTTP/2的多路复用和HTTP1.1中的长连接复用有什么区别？"></a>HTTP/2的多路复用和HTTP1.1中的长连接复用有什么区别？</h2><p>HTTP/1.0 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；<br>HTTP/1.1 Pipeling 解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；<br>HTTP/2 多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行； </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/%E7%BD%91%E7%BB%9C/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/12/%E7%BD%91%E7%BB%9C/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">跨域问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-12 10:26:14" itemprop="dateCreated datePublished" datetime="2019-02-12T10:26:14+08:00">2019-02-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-21 00:51:40" itemprop="dateModified" datetime="2021-04-21T00:51:40+08:00">2021-04-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h1><p>跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。</p>
<p>客户端请求的时候，请求的服务器，不是同一个IP、端口、域名、主机名的时候，都称为跨域。</p>
<p>同源策略限制了以下行为：</p>
<p>Cookie、LocalStorage 和 IndexDB 无法读取<br>DOM 和 JS 对象无法获取<br>Ajax 请求发送后结果被浏览器拦截</p>
<p><strong>所谓的同源是指，域名、协议、端口均为相同，主要对XHR的一个主要约束。其实主要是用来防止 CSRF 攻击的。</strong></p>
<p><a target="_blank" rel="noopener" href="http://www.nealyang.cn/index.html">http://www.nealyang.cn/index.html</a> 调用   <a target="_blank" rel="noopener" href="http://www.nealyang.cn/server.php">http://www.nealyang.cn/server.php</a>  非跨域</p>
<p><a target="_blank" rel="noopener" href="http://www.nealyang.cn/index.html">http://www.nealyang.cn/index.html</a> 调用   <a target="_blank" rel="noopener" href="http://www.neal.cn/server.php">http://www.neal.cn/server.php</a>  跨域,主域不同</p>
<p><a target="_blank" rel="noopener" href="http://abc.nealyang.cn/index.html">http://abc.nealyang.cn/index.html</a> 调用   <a target="_blank" rel="noopener" href="http://def.neal.cn/server.php">http://def.neal.cn/server.php</a>  跨域,子域名不同</p>
<p><a target="_blank" rel="noopener" href="http://www.nealyang.cn:8080/index.html">http://www.nealyang.cn:8080/index.html</a> 调用   <a target="_blank" rel="noopener" href="http://www.nealyang.cn/server.php">http://www.nealyang.cn/server.php</a>  跨域,端口不同</p>
<p><a target="_blank" rel="noopener" href="https://www.nealyang.cn/index.html">https://www.nealyang.cn/index.html</a> 调用   <a target="_blank" rel="noopener" href="http://www.nealyang.cn/server.php">http://www.nealyang.cn/server.php</a>  跨域,协议不同</p>
<p>localhost   调用 127.0.0.1 则造成跨域</p>
<p><strong>同源策略对于 js 的限制有3点</strong></p>
<ul>
<li><p> 非同源的 Cookie、LocalStorage 和 IndexDB 无法读取。<br>为了防止恶意网站通过 js 获取用户其他网站的 cookie。</p>
</li>
<li><p>无法用 js 获取非同源的 DOM。<br>如果没有这一条，恶意网站可以通过 iframe 打开银行页面，可以获取 dom 就相当于可以获取整个银行页面的信息。</p>
</li>
<li><p>无法用 js 发送非同源的 AJAX 请求</p>
</li>
</ul>
<h1 id="为什么要有同源策略？"><a href="#为什么要有同源策略？" class="headerlink" title="为什么要有同源策略？"></a>为什么要有同源策略？</h1><ol>
<li>为什么要限制不同源发请求？假设用户登陆了 bank.com，同时打开了 evil.com，如果没有任何限制，evil.com 可以向 bank.com 请求到任何信息，进而就可以在 evil.com 向 bank.com 发转账请求等。</li>
</ol>
<p>如果这样，为什么不直接限制写，只限制读？因为如果连请求都发不出去了，那就不能做跨域资源共享了，无法读取返回结果，evil.com 就无法继续下一步的操作，如获取转账请求的一些必要的验证信息。</p>
<ol start="2">
<li>为什么限制跨域的 DOM 读取？</li>
</ol>
<p>如果不限制的话，那么很容易就可以伪装其它的网站，如套一个 iframe 或者通过 window.open 的方法，从而得到用户的操作和输入，如账户、密码。</p>
<p><strong>举两个例子。没有同源策略限制的两大危险场景（接口请求和DOM查询）</strong></p>
<h2 id="没有同源策略限制的接口请求"><a href="#没有同源策略限制的接口请求" class="headerlink" title="没有同源策略限制的接口请求"></a>没有同源策略限制的接口请求</h2><ol>
<li>你准备去清空你的购物车，于是打开了买买买网站 <code>www.maimaimai.com </code>，然后登录成功，一看，购物车东西这么少，不行，还得买多点。</li>
<li>你在看有什么东西买的过程中，你的好基友发给你一个链接 <code>www.nidongde.com</code>，一脸yin笑地跟你说：“你懂的”，你毫不犹豫打开了。</li>
<li>你饶有兴致地浏览着 <code>www.nidongde.com</code>，谁知这个网站暗地里做了些不可描述的事情！由于没有同源策略的限制，它向 <code>www.maimaimai.com</code>发起了请求！聪明的你一定想到上面的话“服务端验证通过后会在响应头加入 Set-Cookie 字段，然后下次再发请求的时候，浏览器会自动将 cookie 附加在HTTP 请求的头字段 Cookie 中”，这样一来，这个不法网站就相当于登录了你的账号，可以为所欲为了！如果这不是一个买买买账号，而是你的银行账号。。。这就造成了一个简单的 CSRF 攻击，CSRF 攻击是利用用户的登录态发起恶意请求。</li>
</ol>
<h2 id="没有同源策略的-DOM-查询"><a href="#没有同源策略的-DOM-查询" class="headerlink" title="没有同源策略的 DOM 查询"></a>没有同源策略的 DOM 查询</h2><ol>
<li>有一天你刚睡醒，收到一封邮件，说是你的银行账号有风险，赶紧点进 <code>www.yinghang.com</code>改密码。你吓尿了，赶紧点进去，还是熟悉的银行登录界面，你果断输入你的账号密码，登录进去看看钱有没有少了。</li>
</ol>
<p>​2. 睡眼朦胧的你没看清楚，平时访问的银行网站是 <code>www.yinhang.com</code>，而现在访问的是 <code>www.yinghang.com</code>，这个钓鱼网站做了什么呢？</p>
<p>其实就是把别人网站的 DOM 照搬过来进行伪造，获取用户的信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML</span></span><br><span class="line">&lt;iframe name=<span class="string">&quot;yinhang&quot;</span> src=<span class="string">&quot;www.yinhang.com&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line"><span class="comment">// JS</span></span><br><span class="line"><span class="comment">// 由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Dom</span></span><br><span class="line"><span class="keyword">const</span> iframe = <span class="built_in">window</span>.frames[<span class="string">&#x27;yinhang&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> node = iframe.document.getElementById(<span class="string">&#x27;你输入账号密码的Input&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`拿到了这个<span class="subst">$&#123;node&#125;</span>，我还拿不到你刚刚输入的账号密码吗`</span>)</span><br></pre></td></tr></table></figure>

<h1 id="前后端通信的几种方式"><a href="#前后端通信的几种方式" class="headerlink" title="前后端通信的几种方式"></a>前后端通信的几种方式</h1><ol>
<li>AJAX：同源下面的通信方式</li>
<li>WebSocket：不受同源策略的限制</li>
<li>CORS：支持跨域也支持同源策略（支持跨域的AJAX）</li>
</ol>
<h2 id="如何创建Ajax"><a href="#如何创建Ajax" class="headerlink" title="如何创建Ajax"></a>如何创建Ajax</h2><ol>
<li>实例化 XMLHttpRequest 对象</li>
<li>连接服务器</li>
<li>发送请求</li>
<li>接收响应数据</li>
</ol>
<h1 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h1><ol>
<li>jsonp 解决跨域</li>
</ol>
<p>jsonp 跨域其实也是 JavaScript 设计模式中的一种代理模式。由两个部分组成，<strong>回调函数和数据</strong>（数据指的是下面传入回调函数的res）</p>
<p>在html页面中通过相应的标签（img、script等）从不同域名下加载静态资源文件是被浏览器允许的，所以我们可以通过这个“犯罪漏洞”来进行跨域。一般，我们可以动态的创建script标签，再去请求一个带参网址来实现跨域通信</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原生的实现方式	</span></span><br><span class="line"><span class="keyword">let</span>  script  =  <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.src  =  <span class="string">&#x27;http://www.nealyang.cn/login?username=Nealyang&amp;callback=huidiao&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">huidiao</span>(<span class="params">res</span>)  </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Jquery实现方式</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">&#x27;http://www.nealyang.cn/login&#x27;</span>,</span><br><span class="line">    type:<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    dataType:<span class="string">&#x27;jsonp&#x27;</span>,<span class="comment">//请求方式为jsonp</span></span><br><span class="line">    jsonpCallback:<span class="string">&#x27;callback&#x27;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>:<span class="string">&quot;Nealyang&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>jsonp的最大缺点，就是只能实现get请求</p>
<p>另外使用script标签元素进行Ajax请求，这意味着允许Web页面<strong>可以执行远程服务器发送过来的任何JavaScript代码，因此对于不信任的服务器，不应该采用该技术</strong>。</p>
<ol start="2">
<li><strong>跨域资源共享 CORS—–目前主流的跨域解决方案</strong></li>
</ol>
<p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<strong>基本 的思想就是让HTTP头部让浏览器与服务器之间进行沟通，从而决定请求或者响应应该成功还是失败。</strong></p>
<p>只要浏览器检测到响应头带上了 CORS，并且允许的源包括了本网站，那么就不会拦截请求响应。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Metods:GET,PUT,POST,OPTIONS,DELETE,PATCH</span><br><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>

<p>栗子：浏览器发送一个简单请求的时候，在 http 请求头加个额外的 origin 头部，其中包含源信息（协议端口和域名），服务器根据这个头部信息决定是否响应。如origin：<code>http://www.nidongde.net</code>，服务器认为请求可以接收的话，就在 Access-Control-Allow-Origin 回发相同的源信息，如果是公共资源，则可以回发”<em>“。 *<em>（最好不要设置为</em>在移动端会出现 预检请求不通过的状况，切记切记切记！）*</em></p>
<p>它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。</p>
<p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。IE8+：IE8/9 需要使用 XDomainRequest 对象来支持CORS。整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。</p>
<p>使用方法很简单，在服务端设置：</p>
<p><strong>Header set Access-Control-Allow-Origin</strong><br>这种设置将接受所有域名的跨域请求，也可以指定具体网址，也可以对域名进行限定：<br>Header set Access-Control-Allow-Origin <code>http://www.test.com</code></p>
<p>然而，这种方式的局限性在于要求客户端支持，并且服务端进行相关设置。</p>
<p>在这两者满足的情况下，通过 CORS 进行跨域不仅支持所有类型的 HTTP 请求，而且开发者可以使用<br>普通的 XMLHttpRequest 发起请求和获得数据，比起 JSONP 有更好的错误处理。</p>
<p>PS:Access-Control-Allow-Origin 只能设置一个值，所以如果有多个域需要跨域访问的话，可以通过设置一个白名单，然后判断当前域的 Origin 值是否存在其中，存在的话则设置成当前的 Origin 值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断origin是否在域名白名单列表中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isOriginAllowed</span>(<span class="params">origin, allowedOrigin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_.isArray(allowedOrigin)) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; allowedOrigin.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isOriginAllowed(origin, allowedOrigin[i])) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_.isString(allowedOrigin)) &#123;</span><br><span class="line">    <span class="keyword">return</span> origin === allowedOrigin;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allowedOrigin <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> allowedOrigin.test(origin);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !!allowedOrigin;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ALLOW_ORIGIN = [ <span class="comment">// 域名白名单</span></span><br><span class="line"><span class="string">&#x27;*.233.666.com&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;hello.world.com&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;hello..*.com&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">&#x27;a/b&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> reqOrigin = req.headers.origin; <span class="comment">// request响应头的origin属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断请求是否在域名白名单内</span></span><br><span class="line"><span class="keyword">if</span>(isOriginAllowed(reqOrigin, ALLOW_ORIGIN)) &#123;</span><br><span class="line"><span class="comment">// 设置CORS为请求的Origin值</span></span><br><span class="line">res.header(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, reqOrigin);</span><br><span class="line">res.header(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="string">&#x27;true&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你的业务代码逻辑代码 ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  res.send(&#123; <span class="attr">code</span>: -<span class="number">2</span>, <span class="attr">msg</span>: <span class="string">&#x27;非法请求&#x27;</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>预检请求</strong></p>
<p>就是在发生 cors 请求时，浏览器检测到跨域请求，会自动发出一个 OPTIONS 请求来检测本次请求是否被服务器接受。一个 OPTIONS 请求一般会携带下面两个与  CORS 相关。</p>
<ul>
<li>Access-Control-Request-Method </li>
<li>Access-Control-Request-Headers</li>
</ul>
<p>这样，服务端收到该预检请求后，会返回与 CORS 相关的响应头。主要会包括下面几个，但可能还会有其他的有关 CORS 字段：</p>
<ul>
<li>Access-Control-Allow-Origin: 服务器允许的跨域请求源</li>
<li>Access-Control-Allow-Methods: 服务器允许的请求方法</li>
<li>Access-Control-Allow-Headers : 服务器允许的自定义的请求首部字段</li>
</ul>
<p>与简单请求（get、post、head）不同，“需预检的请求”要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。<br>当请求满足下述任一条件时，即应首先发送预检请求：</p>
<p>使用了下面任一 HTTP 方法：</p>
<ul>
<li>PUT</li>
<li>DELETE</li>
<li>CONNECT</li>
<li>OPTIONS</li>
<li>TRACE</li>
<li>PATCH</li>
</ul>
<p>或者人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type (需要注意额外的限制)<br>…</li>
</ul>
<p>服务器通过 CORS 跨域请求后，下面浏览器就会发出正式的数据请求。整个请求过程其实是发生了两次请求：一个预检请求，通过后的实际数据请求</p>
<p>也就是说 当你自定义了请求头，浏览器就会先发送预检请求，期望得到想要的 Access-Control-Allow-Headers 返回头</p>
<p>以下是一个带有自定义头部 NCZ 的使用 POST 方法发送的请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Origin: http:<span class="comment">//www.nczonline.com</span></span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">ACcess_Control-Request-Headers: NCZ</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 window.postMessage 进行跨域</li>
</ol>
<p>这是由 H5 提出来的的 API，IE8以上支持这个功能。window.postMessage() 方法可以安全地实现跨源通信。<strong>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息。</strong>通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机  (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。<strong>window.postMessage() 方法提供了一种受控机制来规避此限制，</strong>只要正确的使用，这种方法就很安全。能实现跨窗口的消息传递。这个功能是不受同源策略限制的。</p>
<ol start="4">
<li>nginx 代理跨域</li>
</ol>
<p>跨域原理： 同源策略是浏览器的安全策略，不是 HTTP 协议的一部分。服务器端调用 HTTP 接口只是使用 HTTP 协议，不会执行 JS 脚本，不需要同源策略，也就不存在跨越问题。</p>
<p>实现思路： 通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问<br>domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。</p>
<ol start="5">
<li>WebSocket</li>
</ol>
<p>WebSocket虽然不受同源策略的限制，但是WebSocket不会专门用来做跨域,而是作为消息推送或者聊天等</p>
<ol start="6">
<li>document.domain + iframe跨域</li>
</ol>
<p><strong>该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//⽗窗⼝：(http://www.domain.com/a.html)</span></span><br><span class="line">&lt;iframe id=<span class="string">&quot;iframe&quot;</span> src=<span class="string">&quot;http://child.domain.com/b.html&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">document</span>.domain = <span class="string">&#x27;domain.com&#x27;</span>;     <span class="keyword">var</span> user = <span class="string">&#x27;admin&#x27;</span>; </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//⼦窗⼝：(http://child.domain.com/b.html)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;domain.com&#x27;</span>; <span class="comment">// 获取⽗窗⼝中变量 alert(&#x27;get js data from parent ---&gt; &#x27; + window.parent.user);</span></span><br></pre></td></tr></table></figure>

<p>只需要给页面添加 document.domain = ‘test.com’ 表示二级域名都相同就可以实现跨域</p>
<p>最后，跨域分为两种，一种是跨域请求，另一种访问跨域的页面，跨域请求可以通过CORS/JSONP等方法进行访问，跨域的页面主要通过postMesssage的方式。由于跨域请求不但能发出去还能带上cookie，所以要规避跨站请求伪造攻击的风险，特别是涉及到钱的那种请求。</p>
<p>另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: key=value; domain=.example.com; path=/</span><br></pre></td></tr></table></figure>

<p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。</p>
<ol start="7">
<li>Vue项目开发过程中对跨域的处理</li>
</ol>
<p>在根目录的 vue.config.js 中配置 proxy 代理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    disableHostCheck: <span class="literal">true</span>,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">&#x27;/udm/&#x27;</span>: &#123;</span><br><span class="line">        target: <span class="string">&#x27;http://10.33.122.138:2001/v1/api/proxy/&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/08/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/08/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-title-link" itemprop="url">常见网络知识点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-08 11:26:24" itemprop="dateCreated datePublished" datetime="2019-02-08T11:26:24+08:00">2019-02-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="OSI七层协议模型"><a href="#OSI七层协议模型" class="headerlink" title="OSI七层协议模型"></a>OSI七层协议模型</h1><p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.gif" alt="markdown"></p>
<ul>
<li>应用层（Application）：各种应用程序协议，如http、ftp、SMTP等等</li>
<li>表示层（Presentation）：信息的语法语义以及它们的关联，如加密解密、压缩和解压缩等等</li>
<li>会话层（Session）：不同机器上的用户之间建立及管理会话</li>
<li>传输层（Transport）：接受上一层的数据，在必要的时候将数据进行分割，并将数据交给网络层（TCP/UDP）</li>
<li>网络层（Network）：控制子网的运行（IP）</li>
<li>数据链路层（Data Link）：物理寻址</li>
<li>物理层（Physical）机械、电子、定时接口通信信道上的原始比特流传输</li>
</ul>
<h1 id="5层模型"><a href="#5层模型" class="headerlink" title="5层模型"></a>5层模型</h1><p>应用层 =&gt; 传输层 =&gt; 网络层 =&gt; 数据链路层 =&gt; 物理层</p>
<p>5层只是OSI和TCP/IP的综合，是业界产生出来的非官方协议模型，但是很多具体的应用，实际应用还是TCP/IP的四层结构。</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/5%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt="markdown"></p>
<h1 id="4层模型-TCP-IP模型"><a href="#4层模型-TCP-IP模型" class="headerlink" title="4层模型 TCP/IP模型"></a>4层模型 TCP/IP模型</h1><p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/4and7.png" alt="markdown"></p>
<p>Transmission Control Protocol/Internet Protocol，翻译成人话就是 <strong>传输控制协议/互联网协议</strong>，基于TCP/IP的参考模型协议分成了四个层次，它们分别是链路层、网络层、传输层和应用层。</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/tcpip%E5%8D%8F%E8%AE%AE.png" alt="markdown"></p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>向用户提供应用服务时通信的活动。HTTP协议存在于该层。（FTP文件传输协议，DNS域名系统）</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>对上层应用层，提供处于连接中的两台计算机之间的数据传输。包含协议：TCP（传输控制协议）和UDP（用户数据报协议）。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>用于处理在网络上流动的数据包。数据包是网络传输的最小的数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传输给对方。（IP协议）</p>
<h2 id="物理链路层"><a href="#物理链路层" class="headerlink" title="物理链路层"></a>物理链路层</h2><p>用来处理连接网络的硬件部分，定义物理设备如何去传输数据。如：控制操作系统、硬件的设备驱动、NIC（网卡）、光纤等物理可见部分。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>扯了那么多，一张图说明原理。。。</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/TCPIP%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" alt="markdown"></p>
<p>TCP/IP协议通信的过程其实就对应着数据包入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。</p>
<h1 id="常见的http状态码"><a href="#常见的http状态码" class="headerlink" title="常见的http状态码"></a>常见的http状态码</h1><p>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：</p>
<p>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求  </p>
<p>200 OK 一切正常，对GET和POST请求的应答文档跟在后面。</p>
<p>201 Created服务器已经创建了文档，Location头给出了它的URL。</p>
<p>202 Accepted 已经接受请求，但处理尚未完成。</p>
<p>301 永久重定向。</p>
<p>302 临时重定向。</p>
<p><strong>304 Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</strong>(虽然是3开头，但是和重定向没有关系)</p>
<p>400 Bad Request 请求出现语法错误。</p>
<p>401 请求未授权。</p>
<p>403 服务器拒绝请求。</p>
<p>404 Not Found 无法找到指定位置的资源。这也是一个常用的应答。</p>
<p>405 Method Not Allowed 请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。（HTTP 1.1新）</p>
<p>500 Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求。</p>
<p>502 Bad Gateway 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。</p>
<p>503 服务器端暂时无法处理请求。</p>
<h1 id="URL和URI的区别"><a href="#URL和URI的区别" class="headerlink" title="URL和URI的区别"></a>URL和URI的区别</h1><p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/URL.png" alt="markdown"></p>
<p>URL是Uniform Resource Locator，表示是一个地址。<br>URI是Uniform Resource Identifier,表示是一个资源。<br>URL是URI的子集，所有的URL都是URI，但不是每个URI都是URL，还有可能是URN。<br>在这里举一个栗子：比如这个世界上的电音之王是加拿大炮王XXX。那这个头衔电音之王加拿大炮王就是一个URI，那如果我们想要找到这个人XXX，光知道头衔肯定是不够的，所以我们还需要知道他的住址，而这个住址就是URL。</p>
<p>同理，每个人的身份证号码就是一个URI，而每个人的家庭住址也是一个URL。<br>总结：<strong>URI强调的是给资源标记命名，URL强调的是给资源定位，</strong>但是你会发现，URL显然比URI包含信息更多，我通过URL也可以知道张三是总经理，并且我还知道了他的地址，<strong>所以大多数情况下大家觉得给一个网络资源分别命名和给出地址太麻烦，干脆就用地址既当地址用，又当标记名用</strong>，所以，URL也充当了WWW万维网里面URI的角色，但是他比URI多了一层意义，我不光知道你叫什么，我还知道你在哪里。我们在浏览器输入的都是URL，因为我们输入的目的是为了找到某一个资源，当然你输入的是URI也是没错的，因为URL也是URI。</p>
<h1 id="Cookie、session和localStorage、以及sessionStorage之间的区别"><a href="#Cookie、session和localStorage、以及sessionStorage之间的区别" class="headerlink" title="Cookie、session和localStorage、以及sessionStorage之间的区别"></a>Cookie、session和localStorage、以及sessionStorage之间的区别</h1><p>前景引入：http是一种无状态的协议，它的无状态可以用翻脸不认人（浏览器）来表示了；以至于服务器不会记得前一秒是哪个客户端向它发出了请求，这就会导致一种情况出现：小熊登录了淘宝；跳转一下页面，需要再登录；加入购物车，需要再登录；付款需要再登录影响用户体验。<br>在服务端的解决办法是：用session去管理cookie。</p>
<p>当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>内容主要包括<strong>名字、值、过期时间、路径和域</strong>。路径与域一起构成cookie的作用范围。若不设置时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就会消失。这种生命期为浏览器会话期的cookie被称为会话cookie。所以会话cookie是保存在内存中，如果设置了过期时间，那么cookie就会保存在磁盘里。Cookie技术通过在<strong>请求和响应报文</strong> 中写入Cookie信息来控制客户端的状态。</p>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。</p>
<h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>在HTML5中，新加入了一个localStorage特性，这个特性主要是用来作为本地存储来使用的，解决了cookie存储空间不足的问题(cookie中每条cookie的存储空间为4k)，<strong>localStorage中一般浏览器支持的是5M大小</strong>，这个在不同的浏览器中localStorage会有所不同。</p>
<h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。</p>
<h2 id="localforage实现-Web-离线存储"><a href="#localforage实现-Web-离线存储" class="headerlink" title="localforage实现 Web 离线存储"></a>localforage实现 Web 离线存储</h2><p>localStorage缺点：</p>
<ol>
<li>它是同步的，不管数据多大，我们需要等待数据从磁盘读取和解析，这会减慢我们的应用程序的响应速度，如果放到移动设备上，可想而之。</li>
<li>仅支持字符串，如果是存对象还需要将对象JSON.stringify({name:”houyuewei”,age:20})下，用的时候再次转换，真是麻烦。</li>
<li>不能加密存储到硬盘上，增加了很多危险性。</li>
<li>永久存储，并且存储容量限制在10M</li>
</ol>
<p>LocalForage就解决了上面的问题，localForage 是一个使用非常简单的 JavaScript 库的，提供了 get，set，remove，clear 和 length 等等 API（跟 localStorage 一样），还具有以下特点：</p>
<ul>
<li>支持回调的异步 API（localStorage是同步的）</li>
<li>支持 IndexedDB，WebSQL 和 localStorage 三种存储模式（自动为你加载最佳的驱动程序）</li>
<li>支持 BLOB 和任意类型的数据，让您可以存储图片，文件等等</li>
<li>支持 ES6 Promises</li>
</ul>
<p>对 IndexedDB 和 WebSQL 的支持使您可以为您的 Web 应用程序存储更多的数据，要比 localStorage 5M 存储的多很多。其 API 的无阻塞性质使得您的应用程序更快，不会因为 Get/Set 调用而挂起主线程。</p>
<p>localforage的逻辑是这样的：优先使用IndexedDB存储数据，如果浏览器不支持，使用WebSQL，浏览器再不支持，使用localStorage</p>
<h1 id="session和cookie的主要区别"><a href="#session和cookie的主要区别" class="headerlink" title="session和cookie的主要区别"></a>session和cookie的主要区别</h1><ul>
<li>  Cookie是把用户的数据写给用户的浏览器。</li>
<li>  Session技术把用户的数据写到用户独占的session中。</li>
<li>  Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象。</li>
<li>  cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session</li>
<li>  session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。</li>
<li>  单个cookie保存的数*据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>  session中保存的是对象，cookie中保存的是字符串</li>
</ul>
<h1 id="sessionStorage、localStorage和cookie的区别"><a href="#sessionStorage、localStorage和cookie的区别" class="headerlink" title="sessionStorage、localStorage和cookie的区别"></a><strong>sessionStorage、localStorage和cookie的区别</strong></h1><p>共同点：都是保存在浏览器端、且同源的<br>区别：</p>
<p>主要在于大小、是否参与通信、作用域、有效期四个方面。</p>
<ol>
<li>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 </li>
<li>存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 </li>
<li>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 </li>
<li>作用域不同，<strong>sessionStorage不在不同的浏览器窗口中共享</strong>，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的<br>（indexDB，除非被清理，否则一直存在，存储大小没有限制，不参与服务端通信）</li>
</ol>
<h1 id="UDP和TCP（User-Datagram-Protocol，用户数据报协议）的区别"><a href="#UDP和TCP（User-Datagram-Protocol，用户数据报协议）的区别" class="headerlink" title="UDP和TCP（User Datagram Protocol，用户数据报协议）的区别"></a>UDP和TCP（User Datagram Protocol，用户数据报协议）的区别</h1><ol>
<li>都是位于传输层，TCP是面向连接的，而<strong>udp是无连接的</strong>，即发送数据前不需要先建立连接</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达；UDP尽最大努力交付，即不保证可靠交付。并且TCP可靠，面向连接不会丢失数据适合大数据量的传输</li>
<li>TCP面向字节流，UDP面向报文，并且网络阻塞不会使得发送的速率降低，所以会出现丢包（适合视频会议或者直播）　</li>
<li>TCP只能是一对一的，而UDP可以一对多</li>
<li>TCP首部较大为20字节，UDP只有8字节。</li>
</ol>
<h1 id="如何实现UDP的可靠传输"><a href="#如何实现UDP的可靠传输" class="headerlink" title="如何实现UDP的可靠传输"></a>如何实现UDP的可靠传输</h1><p>TCP是通过确认机制和超时重传机制实现可靠传输</p>
<p>UDP它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<p>关键在于两点，从应用层角度考虑：</p>
<ol>
<li><p>提供超时重传，能避免数据包丢失。</p>
</li>
<li><p>提供确认序列号，可以对数据包进行确认和排序。</p>
</li>
</ol>
<p><strong>RUDP</strong></p>
<p>RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。在不干扰协议的实时特性的同时，可靠 UDP 的拥塞控制机制允许 TCP 方式下的流控制行为。</p>
<h1 id="websocket协议"><a href="#websocket协议" class="headerlink" title="websocket协议"></a>websocket协议</h1><p>WebSocket 是 HTML5 开始提供的一种基于单个 TCP 连接上进行全双工通讯(双向)的协议(WebSocket同HTTP一样也是应用层的协议，但是它是一种双向通信协议，是建立在TCP之上的，都是提供可靠的传输协议)。</p>
<p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<p>现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。<br>使用这个协议可以在客户端和服务端之间发送很少的数据，而不必担心像HTTP那样的字节级开销，由于移动网络带宽以及网络延迟的问题，所以非常适合应用在移动应用上</p>
<p>HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯，<strong>同时也允许跨域通讯。</strong><br>websocket的实现，在握手阶段与http是相同的，多了两个新属性<br>Upgrade:WebSocket<br>Connection:Upgrade</p>
<p>同样类似AJAX的是，WebSocket对象也有一个readyState属性，用来表示对象实例当前所处的链接状态，有四个值：</p>
<ul>
<li>0：表示正在连接中（CONNECTING）；</li>
<li>1：表示连接成功，可以通信（OPEN）；</li>
<li>2：表示连接正在关闭（CLOSING）；</li>
<li>3：表示连接已经关闭或打开连接失败（CLOSED）；</li>
</ul>
<p>优点：</p>
<ul>
<li>能够在客户端和服务器之间发送非常少量的数据，而不必担心像HTTP那样的字节级开销，数据格式轻量，性能开销小，通信高效（适用于移动通信）</li>
<li>服务器可以推送消息给客户端，实现双向对话平等</li>
<li>没有同源策略的限制，可以实现跨域通讯</li>
</ul>
<h1 id="cdn"><a href="#cdn" class="headerlink" title="cdn"></a>cdn</h1><p>CDN(Content Delivery Network)又称为内容分发网络，使内容传输的更快，更稳定。<br>也就是说，<strong>把静态资源文件和动态网页分集群部署</strong>，静态资源会被部署到CDN节点上，网页中引用的资源也会变成对应的部署路径。静态资源尽量使⽤ CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使⽤多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要 与主站不同，否则每次请求都会带上主站的 Cookie。</p>
<p>CDN 的核心点有两个: 一个是缓存，一个是回源。</p>
<ul>
<li><p>缓存<br>将从根服务器请求来的资源按要求缓存。</p>
</li>
<li><p>回源<br>当有用户访问某个资源的时候，如果被解析到的那个 CDN 节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。没有人访问，CDN 节点不会主动去源站请求资源。</p>
</li>
</ul>
<p>原理：不同地区的用户会访问到离自己最近的相同网络线路上的CDN节点，当请求达到CDN节点后，节点会判断自己的内容缓存是否有效，如果有效，则立即响应缓存内容给用户，从而加快响应速度。如果CDN节点的缓存失效，它会根据服务配置去我们的内容源服务器获取最新的资源响应给用户，并将内容缓存下来以便响应给后续访问的用户。因此，一个地区内只要有一个用户先加载资源，在CDN中建立了缓存，该地区的其他后续用户都能因此而受益。</p>
<p>不同地区的用户访问同一个域名却能得到不同CDN节点的IP地址，这要依赖于<strong>CDN服务商提供的智能域名解析服务</strong>，浏览器发起域名查询时，这种智能DNS服务会根据用户IP计算并返回离它最近的同网络CDN节点IP，引导浏览器与此节点建立连接以获取资源。</p>
<p>优点：</p>
<ul>
<li>CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低</li>
<li>大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源站的负载</li>
<li>提高网络访问的稳定性</li>
</ul>
<h1 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h1><p>从缓存位置上来说分为四种，并且各⾃有优先级，当依次查找缓存且都没有命 中的时候，才会去请求⽹络</p>
<ul>
<li>Service Worker </li>
<li>Memory Cache </li>
<li>Disk Cache </li>
<li>Push Cache</li>
<li>如果都没有缓存只能发起网络请求</li>
</ul>
<ol>
<li>Service Worker</li>
</ol>
<ul>
<li>service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们⾃由控制缓存 哪些⽂件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 </li>
<li>当 Service Worker 没有命中缓存的时候，我们需要去调⽤ fetch 函数获取数据。也 就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查 找数据。但是不管我们是从 Memory Cache 中还是从⽹络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</li>
</ul>
<ol start="2">
<li>Memory Cache</li>
</ol>
<ul>
<li><p>Memory Cache 也就是内存中的缓存，读取内存中的数据肯定⽐磁盘快。但是内存缓存虽 然读取⾼效，可是缓存持续性很短，会随着进程的释放⽽释放。 ⼀旦我们关闭 Tab ⻚⾯，内存中的缓存也就被释放了。</p>
</li>
<li><p>当我们访问过⻚⾯以后，再次刷新⻚⾯，可以发现很多数据都来⾃于内存缓存</p>
</li>
</ul>
<p>PS:那么既然内存缓存这么⾼效，我们是不是能让数据都存放在内存中呢？</p>
<p>先说结论，这是不可能的。</p>
<ul>
<li>⾸先计算机中的内存⼀定⽐硬盘容量⼩得多，操作系统需要精 打细算内存的使⽤，所以能让我们使⽤的内存必然不多。</li>
<li>内存中其实可以存储⼤部分的⽂件，⽐如说 JS 、 HTML 、 CSS 、图⽚等等 当然，我通过⼀些实践和猜测也得出了⼀些结论</li>
<li>对于⼤⽂件来说，⼤概率是不存储在内存中的，反之优先当前系统内存使⽤率⾼的话，⽂件优先存储进硬盘</li>
</ul>
<ol start="3">
<li>Disk Cache</li>
</ol>
<p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中， ⽐之 Memory Cache 胜在容量和存储时效性上。</p>
<p>在所有浏览器缓存中，Disk Cache 覆盖⾯基本是 Y ⼤的。它会根据 ·HTTP Herder· 中的 字段判断哪些资源需要缓存，哪些资源可以不请求直接使⽤，哪些资源已经过期需要重新 请求。并且即使在跨站点的情况下，相同地址的资源⼀旦被硬盘缓存下来，就不会再次去请求数据。</p>
<ol start="4">
<li>push Cache</li>
</ol>
<p>Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使⽤。并且缓存时间也很短暂，只在会话（ Session ）中存在，⼀旦会话结束就被释放。 Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及，但是 HTTP/2 将会是⽇后的⼀个趋势</p>
<ol start="5">
<li> ⽹络请求</li>
</ol>
<p>如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。 那么为了性能上的考虑，⼤部分的接⼝都应该选择好缓存策略，接下来我们就来学习缓存策略这部分的内容</p>
<h1 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h1><ol>
<li>缓存的分类</li>
</ol>
<ul>
<li>强缓存发现本地有请求文件的副本，直接使用，也就是说如果我们在服务端更新了文件，并不会被浏览器所得知，就无法替换失效的缓存</li>
<li>协商缓存则需要和服务器进行交流，通过确认之后才可以使用</li>
</ul>
<p>a 强缓存：不会向服务器发送请求，直接从缓存中读取资源，返回状态码200</p>
<ul>
<li>Expires Wed, 22 Oct 2018 08:41:00 GMT</li>
</ul>
<p><strong>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点，如果过期则会再次请求</strong></p>
<p>缺点是，失效时间是一个绝对时间，如果服务器时间与客户端时间偏差较大时，就会导致缓存混乱。<br>而服务器的时间跟用户的实际时间是不一样是很正常的，所以 Expires 在实际使用中会带来一些麻烦。（由于时差问题大多使用cache-control）</p>
<ul>
<li>Cache—Control:max-age=300</li>
</ul>
<p><strong>代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</strong><br>在实际使用中常常遇到设置了 max-age 之后，在 max-age 时间内重新访问资源却会返回 304 not modified ，这是由于服务器的时间与本地的时间不同造成的。</p>
<p>但是如果服务器同时下发了两个，则以相对时间为准。</p>
<p>b 协商缓存：会去服务器比对，若没改变才直接读取本地缓存，返回的状态码是 304。<br>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p>
<p><strong>Last-Modified 和 If-Modified-Since</strong></p>
<p>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；<br>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，<strong>值就是Last-Modified中的值</strong> 。<br>服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。 </p>
<p>格式类似：Last-Modified: Fri, 12 May 2006 18:53:33 GMT</p>
<p>存在的弊端：</p>
<ul>
<li><p>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源。</p>
</li>
<li><p>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源。</p>
</li>
<li><p>某些服务器不能精确的得到文件的最后修改时间。</p>
</li>
</ul>
<p><strong>Etag 和 If-None-Match</strong></p>
<p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成，类似一个哈希值)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。<br>如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p>
<p><strong>PS：强缓存的优先级会比协商缓存优先级高，cache-control优先级 &gt; expire，Etag优先级 &gt; Last-modified</strong></p>
<p><strong>那有了Etag是不是可以放弃last-Modified了呢？</strong></p>
<ul>
<li><p>对那些一秒内修改特别频繁的文件，使用etag强验证的话，Etag扫描全部文件可能会耗费大量性能,就需要占用服务器cpu资源频繁进行etag的计算，这样可能就不好用了。(该场景适合使用last-modified)</p>
</li>
<li><p>只是给代码加上注释，但是服务器实质的内容并没有一点改变，如果使用Etag扫描全部文件可能会耗费大量性能，而使用last-modified只要返回最后修改时间即可，所以要根据情况选择方案。</p>
</li>
<li><p>另外必须要考虑到服务器的时区问题。</p>
</li>
</ul>
<h2 id="设置页面不使用缓存的几种方法"><a href="#设置页面不使用缓存的几种方法" class="headerlink" title="设置页面不使用缓存的几种方法"></a>设置页面不使用缓存的几种方法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;pragma&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Cache-Control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache, must-revalidate&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;expires&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="选择合适的缓存策略"><a href="#选择合适的缓存策略" class="headerlink" title="选择合适的缓存策略"></a>选择合适的缓存策略</h2><p>对于⼤部分的场景都可以使⽤强缓存配合协商缓存解决，但是在⼀些特殊的地⽅可能需要选择特殊的缓存策略</p>
<ul>
<li>对于某些不需要缓存的资源，可以使⽤ Cache-control: no-store ，表示该资源不需要 缓存 </li>
<li>对于频繁变动的资源，可以使⽤ Cache-Control: no-cache 并配合 ETag 使⽤，表示 该资源已被缓存，但是每次都会发送请求询问资源是否更新。 </li>
<li>对于代码⽂件来说，通常使⽤ Cache-Control: max-age=31536000 并配合策略缓存使 ⽤，然后对⽂件进⾏etag指纹处理，⼀旦⽂件名变动就会⽴刻下载新的⽂件</li>
</ul>
<h1 id="PWA-使用缓存"><a href="#PWA-使用缓存" class="headerlink" title="PWA 使用缓存"></a>PWA 使用缓存</h1><p>PWA(Progressive web apps, 渐进式Web应用)</p>
<ul>
<li>可以生成桌面小图标，不需要打开浏览器，方便用户访问</li>
<li>通过网络缓存提升页面访问速度，达到渐进式的页面甚至离线访问，提升用户体验</li>
<li>实现类似 app 的推送功能，生成系统通知推送给用户</li>
</ul>
<p>service worker 是实现 PWA 的核心，service worker 是一个独立的浏览器线程，不会对当前程序的执行线程造成阻塞，通过 service worker 可以实现页面离线访问、用户消息推送等功能。</p>
<p>Service Worker实际上是浏览器和服务器之间的代理服务器，它最大的特点是在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。目的在于离线缓存，转发请求和网络代理。</p>
<p>使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p>
<p>Service Worker 实现缓存功能一般分为三个步骤：</p>
<ul>
<li>首先需要先注册 Service Worker。</li>
<li>然后监听到 install 事件以后就可以缓存需要的文件。</li>
<li>下次用户访问的时候就可以通过<strong>拦截请求的方式</strong>查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</li>
</ul>
<p>PWA 确实是当下很热门的技术，因为它提升了 web 应用的体验，甚至达到可以和原生 app 体验相提并论，但是它的问题就是兼容性问题，相信如果兼容性问题得到解决，这种技术一定会被大面积推广到实际应用。iOS11.3 之前都不支持，因此 vue cli3 脚手架在集成时默认在 ios 下是关闭的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/26/JavaScript/javaScript%E9%9A%8F%E6%89%8B%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/26/JavaScript/javaScript%E9%9A%8F%E6%89%8B%E8%AE%B0/" class="post-title-link" itemprop="url">JavaScript随手记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-26 16:16:24" itemprop="dateCreated datePublished" datetime="2019-01-26T16:16:24+08:00">2019-01-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="作用域概念"><a href="#作用域概念" class="headerlink" title="作用域概念"></a>作用域概念</h2><p>作用域：变量可以起作用的范围</p>
<p>全局变量：使用var声明的，在任何地方都可以访问到的变量就是全局变量，对应全局作用域，如果页面不关闭，则内存不会释放，一直占用空间。</p>
<p>局部变量：只在固定的代码片段内可访问到的变量，最常见的例如函数内部。对应局部作用域(函数作用域)。</p>
<p>隐式全局变量：声明的变量没有var,就叫隐式全局变量。</p>
<p>不使用var声明的变量是全局变量，不推荐使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  number=<span class="number">1000</span>;<span class="comment">//是隐式全局变量</span></span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line"><span class="built_in">console</span>.log(number);</span><br></pre></td></tr></table></figure>

<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。在es5之前没有块级作用域的的概念,只有函数作用域。</p>
<h2 id="js-中词法作用域规则"><a href="#js-中词法作用域规则" class="headerlink" title="js 中词法作用域规则:"></a>js 中词法作用域规则:</h2><p>函数允许访问函数外的数据.</p>
<p>整个代码结构中只有函数可以限定作用域.</p>
<p>作用域规则首先使用提升规则分析</p>
<p>如果当前作用规则中有名字了, 就不考虑外面的名字</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>只有函数可以制造作用域结构， 那么只要是代码，就至少有一个作用域, 即全局作用域。凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。</p>
<p>将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h1><p>JavaScript代码的执行是由浏览器中的<strong>JavaScript解析器</strong>来执行的。JavaScript解析器执行JavaScript代码的时候，分为两个过程：<strong>预解析过程和代码执行</strong>过程。预解析就是在全局中寻找var关键字声明的变量和通过function关键字声明的函数。<br>预解析过程：</p>
<ol>
<li>把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值。</li>
<li>把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用。</li>
<li>先提升函数，然后再提升变量。</li>
<li>只有变量和函数才会发生声明提升，并且变量在提升声明的时候不会赋值，默认值是undefined，函数声明也不会将函数调用。</li>
<li>通过声明提升，函数可以在声明的函数体之上进行调用，变量也可以在赋值之前进行输出，而且不会报错，如果说直接输出一个没有声明的变量就会报错。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f1(); <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// 此时预解析函数 f1 声明提升, 所以上面的调用控制台中调用不会报错</span></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// undefined  此时预解析变量 num 声明提升（没有赋值）</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">5</span>; <span class="comment">//  所以上面在控制台中调用不会报错，只是显示 undefined</span></span><br></pre></td></tr></table></figure>

<h1 id="三-this指向"><a href="#三-this指向" class="headerlink" title="三 this指向"></a>三 this指向</h1><h2 id="形式-test"><a href="#形式-test" class="headerlink" title="形式 test()"></a>形式 test()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line">test()  <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>直接不带任何引用形式去调用函数，则this会指向全局对象，因为没有其他影响去改变this，this默认就是指向全局对象（浏览器是window，Node中是global）的。这个结论是在非严格模式的情况下，严格模式下这个this其实是undefined的。</p>
<h2 id="形式-xxx-text"><a href="#形式-xxx-text" class="headerlink" title="形式 xxx.text()"></a>形式 xxx.text()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line">obj.test()      <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>这种形式相对于第一中，this指向已经很明显，谁去调用这个函数的，这个函数中的this就绑定到谁身上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj0 = &#123;</span><br><span class="line">    a: <span class="number">3</span>,</span><br><span class="line">    obj </span><br><span class="line">&#125;</span><br><span class="line">obj0.obj.test()     <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>虽然比上面复杂了一点，但是结果依然和上面的一样，this指向obj，指向直接调用的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> testCopy = obj.test</span><br><span class="line">testCopy()      <span class="comment">//testCopy()是由window调用的，所以this指向window</span></span><br></pre></td></tr></table></figure>

<p>道理同上，虽然说换了一个名字，但是只认定函数调用的时候，是由哪个对象进行调用的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(obj.test)  <span class="comment">//输出1</span></span><br></pre></td></tr></table></figure>

<h2 id="形式-test-call-xxx-test-apply-xxx-test-bind"><a href="#形式-test-call-xxx-test-apply-xxx-test-bind" class="headerlink" title="形式 test.call(xxx) / test.apply(xxx) / test.bind()"></a>形式 test.call(xxx) / test.apply(xxx) / test.bind()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;</span><br><span class="line">    a: <span class="number">3</span>,</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> testCopy = obj.test</span><br><span class="line">testCopy.call(obj)<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>可以看到，我们通过 call（apply 跟 call 的区别只是传参，作用是一样的，bind 有点区别，bind 能让我们的函数延迟执行，apply 与 call 调用就执行，所以 bind 这样的形式我们也称为函数柯里化，这些就不是我们这里要说的啦）来调用 testCopy，并且传入了你想要 this 指向的上下文，那么 this 指向你要的对象。看到这里，我们也可以想象第一、二种形式其实可以转化成 call/apply 的形式。</p>
<h2 id="new-test-形式"><a href="#new-test-形式" class="headerlink" title="new test() 形式"></a>new test() 形式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> test(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(b.a)        <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>new这个操作符其实是new了一个新对象出来，而被new的test我们称为构造函数，我们可以在这个构造函数里定义一下将要到来的新对象的一些属性。所以构造函数里的this指的就是将要被new出来的新对象。</p>
<p>最后的最后，其实还有一个，就是箭头函数中的this指向。</p>
<p><strong>箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定</strong>所谓的定义时候绑定，就是this是继承自父执行上下文中的this！！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line">obj.test()</span><br></pre></td></tr></table></figure>
<p><strong>它this指向的是它的外层作用域this的指向。</strong>。外层作用域是整个window，所以输出的是1.</p>
<h1 id="typeof和instanceof的区别"><a href="#typeof和instanceof的区别" class="headerlink" title="typeof和instanceof的区别"></a>typeof和instanceof的区别</h1><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>typeof 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。<strong>它返回值是一个字符串，该字符串说明运算数的类型。</strong></p>
<p>typeof 一般只能返回如下几个结果：<br>“number”、”string”、”boolean”、”object”、”function” 和 “undefined”以及”symbol”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">运算数为数字 <span class="keyword">typeof</span>(x) = <span class="string">&quot;number&quot;</span> </span><br><span class="line"></span><br><span class="line">字符串 <span class="keyword">typeof</span>(x) = <span class="string">&quot;string&quot;</span> </span><br><span class="line"></span><br><span class="line">布尔值 <span class="keyword">typeof</span>(x) = <span class="string">&quot;boolean&quot;</span> </span><br><span class="line"></span><br><span class="line">对象,数组和<span class="literal">null</span> <span class="keyword">typeof</span>(x) = <span class="string">&quot;object&quot;</span> </span><br><span class="line"></span><br><span class="line">函数 <span class="keyword">typeof</span>(x) = <span class="string">&quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">alert(a <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同时 alert(a instanceof Object) //也会返回 true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是因为 Array 是 object 的子类。</span></span><br></pre></td></tr></table></figure>

<p>另外，更重的一点是 instanceof 可以在继承关系中用来判断一个实例是否属于它的父类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125; </span><br><span class="line">Foo.prototype = <span class="keyword">new</span> Aoo();<span class="comment">//JavaScript 原型继承 </span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(); </span><br><span class="line"><span class="built_in">console</span>.log(foo <span class="keyword">instanceof</span> Foo)<span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(foo <span class="keyword">instanceof</span> Aoo)<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h1 id="null-和-undefined-区别"><a href="#null-和-undefined-区别" class="headerlink" title="null 和 undefined 区别"></a>null 和 undefined 区别</h1><p>null：Null 类型，代表“空值”，代表一个<strong>空对象指针</strong>，使用 typeof 运算得到 <strong>“object”</strong>，所以可以认为它是一个特殊的对象值。</p>
<p>undefined：Undefined 类型，声明但是未初始化变量时，得到的就是 undefined。</p>
<p>null 是 javascript 的关键字，可以认为是对象类型，它是一个空对象指针，和其它语言一样都是代表“空值”，不过 undefined 却是 javascript 才有的。undefined 是在 ECMAScript 第三版引入的，为了区分空指针对象和未初始化的变量，它是一个预定义的全局变量。没有返回值的函数返回为 undefined，没有实参的形参也是 undefined。</p>
<p>也可以认为 undefined 是表示系统级的、出乎意料的或类似错误的值的空缺，而 null 是表示程序级的、正常的或在意料之中的值的空缺。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/26/JavaScript/JavaScript%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/26/JavaScript/JavaScript%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">JavaScript入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-26 16:16:24" itemprop="dateCreated datePublished" datetime="2019-01-26T16:16:24+08:00">2019-01-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JavaScript入门（一）"><a href="#JavaScript入门（一）" class="headerlink" title="JavaScript入门（一）"></a>JavaScript入门（一）</h1><h2 id="js中的数据类型"><a href="#js中的数据类型" class="headerlink" title="js中的数据类型"></a>js中的数据类型</h2><p>js中的原始数据类型:number , string , boolean , null , undefined , object</p>
<p>number:数字类型(整数和小数)</p>
<p>string:字符串类型(的值一般都是用单引号或者是双引号括起来)  “34”</p>
<p>boolean:布尔类型(值只有两个,true(真1),false(假0))<br>null:空类型,值只有一个:null,一个对象指向为空了,此时可以赋值为null<br>undefined:未定义,值只有一个:undefined<br>什么情况下的结果是undefined：变量声明了,没有赋值,结果是undefined<br>函数没有明确返回值,如果接收了,结果也是undefined<br>如果一个变量的结果是undefined和一个数字进行计算,结果:NaN不是一个数字,也没有意义</p>
<p>如果想要获取一个变量的数据类型，可以使用typeof获取</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;小白&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> nll = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> undef;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">//是使用typeof 获取变量的类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);<span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str);<span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> flag);<span class="comment">//boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(nll));<span class="comment">//是null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> nll);<span class="comment">//不是null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> undef);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num));</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>其他类型转数字类型有三种方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parseInt();//转整数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>));<span class="comment">//10</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;10afrswfdsf&quot;</span>));<span class="comment">//10</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;g10&quot;</span>));<span class="comment">//NaN</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;1fds0&quot;</span>));<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;10.98&quot;</span>));<span class="comment">//10</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;10.98fdsfd&quot;</span>));<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.parseFloat()//转小数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&quot;10&quot;</span>));<span class="comment">//10</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&quot;10afrswfdsf&quot;</span>));<span class="comment">//10</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&quot;g10&quot;</span>));<span class="comment">//NaN</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&quot;1fds0&quot;</span>));<span class="comment">//1    </span></span><br><span class="line">	  <span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&quot;10.98&quot;</span>));<span class="comment">//10.98</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&quot;10.98fdsfd&quot;</span>));<span class="comment">//10.98</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.Number();//转数字</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;10&quot;</span>));<span class="comment">//10</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;10afrswfdsf&quot;</span>));<span class="comment">//NaN</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;g10&quot;</span>));<span class="comment">//NaN    </span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;1fds0&quot;</span>));<span class="comment">//NaN</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;10.98&quot;</span>));<span class="comment">//10.98</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;10.98fdsfd&quot;</span>));<span class="comment">//NaN</span></span><br><span class="line"><span class="comment">//总结:想要转整数用parseInt(),想要转小数用parseFloat()</span></span><br><span class="line"><span class="comment">//想要转数字:Number();要比上面的两种方式严格</span></span><br></pre></td></tr></table></figure>

<h2 id="其他类型转字符串类型"><a href="#其他类型转字符串类型" class="headerlink" title="其他类型转字符串类型"></a>其他类型转字符串类型</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1    .toString()</span></span><br><span class="line">    <span class="keyword">var</span> num=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(num.toString());<span class="comment">//字符串类型</span></span><br><span class="line"><span class="comment">//2  String();</span></span><br><span class="line">    <span class="keyword">var</span> num1=<span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">String</span>(num1));</span><br><span class="line"><span class="comment">//如果变量有意义调用.toString()使用转换</span></span><br><span class="line"><span class="comment">//如果变量没有意义使用String()转换</span></span><br></pre></td></tr></table></figure>

<h2 id="其他类型转Boolean"><a href="#其他类型转Boolean" class="headerlink" title="其他类型转Boolean"></a>其他类型转Boolean</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//1  Boolean(值);</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">1</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">11</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>算数运算符:  +  -  * / %<br>  算数运算表达式:由算数运算符连接起来的表达式<br>  一元运算符: 这个操作符只需要一个操作数就可以运算的符号  ++  –<br>  二元运算符: 这个操作符需要两个操作数就可以运算,<br>  三元运算符: a &gt; b ? a : b<br>  复合运算符: +=  -=  *= /= %=<br>  复合运算表达式:由复合运算符连接起来的表达式<br>  var num=10;<br>  num+=10;——&gt;就是:num=num+10;<br>  console.log(num);20</p>
<p>关系运算符: &gt;  &lt;  &gt;=  &lt;=  ==不严格的 ===严格的 !=不严格的不等 !==严格的不等<br>  关系运算表达式:由关系运算符连接起来的表达式<br>  关系运算表达式的结果是布尔类型<br>  逻辑运算符:<br>  &amp;&amp;—逻辑与–并且<br>  ||—逻辑或—或者<br>  !—逻辑非—取反–取非<br>  逻辑运算表达式:由逻辑运算符连接起来的表达式<br>  表达式1&amp;&amp;表达式2<br>  如果有一个为false,整个的结果就是false<br>  表达式1||表达式2<br>  如果有一个为true,整个的结果为true<br>  !表达式1<br>  表达式1的结果是true,整个结果为false<br>  表达式1的结果是false,整个结果为true</p>
<p>  赋值运算符:  =</p>
<h1 id="JavaScript入门（二）"><a href="#JavaScript入门（二）" class="headerlink" title="JavaScript入门（二）"></a>JavaScript入门（二）</h1><h2 id="流程控制的三种方式"><a href="#流程控制的三种方式" class="headerlink" title="流程控制的三种方式"></a>流程控制的三种方式</h2><ol>
<li><p>顺序结构:从上到下,从左到右执行的顺序,就叫做顺序结构（但是不严谨）</p>
</li>
<li><p>分支结构:if语句,if-else语句,if-else if-else if…语句,switch-case语句,三元表达式语句</p>
</li>
<li><p>循环结构:while循环,do-while循环,for循环,for-in循环</p>
</li>
</ol>
<p>while循环特点:先判断,后循环,有可能一次循环体都不执行</p>
<p>do-while循环特点:先循环,后判断,至少执行一次循环体</p>
<h2 id="break关键字"><a href="#break关键字" class="headerlink" title="break关键字"></a>break关键字</h2><p>如果在循环中使用,遇到了break,则立刻跳出当前所在的循环</p>
<h2 id="continue关键字"><a href="#continue关键字" class="headerlink" title="continue关键字"></a>continue关键字</h2><p>在循环中如果遇到continue关键字,直接开始下一次循环</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数:把一坨重复的代码封装,在需要的时候直接调用即可<br>函数的作用:代码的重用<br>函数的定义：</p>
<p>语法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名字(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">​	函数体-----一坨重复的代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的调用:</p>
<p>函数名();</p>
<p>函数的命名要遵循驼峰命名法</p>
<p>JS中创建函数的三种方法</p>
<ol>
<li>函数声明</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>函数表达式，又叫函数字面量</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>两者的区别：</strong>解析器会先读取函数声明，并使其在执行任何代码之前可以访问；而函数表达式则必须等到解析器执行到它所在的代码行才会真正被解释执行。</p>
<ol start="3">
<li>自执行函数（严格意义上也是属于函数表达式）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;(<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>自执行函数相当于一个沙箱，它主要用于创建一个新的作用域，在此作用域内声明的变量，不会和其它作用域内的变量冲突或混淆，大多是以匿名函数方式存在，且立即自动执行。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li>通过构造函数创建数组</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array=<span class="keyword">new</span> <span class="built_in">Array</span>();<span class="comment">//定义了一个数组</span></span><br></pre></td></tr></table></figure>

<p>数组的名字如果直接输出,那么直接就可以把数组中的数据显示出来,如果没有数据,就看不到数据</p>
<ol start="2">
<li>通过字面量的方式创建数组</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名=[];<span class="comment">//空数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array=[<span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<h2 id="arguments伪数组"><a href="#arguments伪数组" class="headerlink" title="arguments伪数组"></a>arguments伪数组</h2><ol>
<li>什么是伪数组?</li>
</ol>
<ul>
<li>伪数组是一个对象</li>
<li>伪数组具有Length属性，值必须为number 类型，如果这个对象的length不为0，那么必须要有按照下标存储的数据</li>
<li>伪数组没有数组的pop、push等方法</li>
</ul>
<ol start="2">
<li>如何判断是否为伪数组</li>
</ol>
<ul>
<li>是否为对象</li>
<li>是否具有Length属性</li>
<li>Length属性的值是否存在，并且必须是number 类型</li>
</ul>
<ol start="3">
<li>伪数组转化为真数组</li>
</ol>
<ul>
<li>Array.prototype.slice.call()</li>
<li>[].prototype.slice.call()</li>
<li>Array.from()</li>
<li>扩展运算符[…()]</li>
</ul>
<ol start="4">
<li>arguments</li>
</ol>
<p>arguments就是一个经典的伪数组。他是所有（非箭头）函数中可用的局部变量</p>
<p>对arguments使用typeof返回‘object’</p>
<ul>
<li>arguments.callee指向当前执行的函数</li>
<li>arguments.callee.caller指向当前函数的上一级函数</li>
<li>arguments.callee.caller.arguments 父函数的实参</li>
<li>arguments.length指向传递给当前函数的参数数量 (返回函数实参的个数)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">fn(<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">fn(<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b,c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(fn.length);         <span class="comment">//获取形参的个数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);  <span class="comment">//获取实参的个数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">  Arguments(<span class="number">2</span>) [<span class="number">2</span>, <span class="number">4</span>, <span class="attr">callee</span>: ƒ, <span class="built_in">Symbol</span>(<span class="built_in">Symbol</span>.iterator): ƒ]</span><br><span class="line">  <span class="number">3</span></span><br><span class="line">  <span class="number">2</span></span><br><span class="line">  ----------------</span><br><span class="line">  Arguments(<span class="number">3</span>) [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="attr">callee</span>: ƒ, <span class="built_in">Symbol</span>(<span class="built_in">Symbol</span>.iterator): ƒ]</span><br><span class="line">  <span class="number">3</span></span><br><span class="line">  <span class="number">3</span></span><br><span class="line">  ----------------</span><br><span class="line">  Arguments(<span class="number">4</span>) [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="attr">callee</span>: ƒ, <span class="built_in">Symbol</span>(<span class="built_in">Symbol</span>.iterator): ƒ]</span><br><span class="line">  <span class="number">3</span></span><br><span class="line">  <span class="number">4</span></span><br><span class="line">  ----------------</span><br></pre></td></tr></table></figure>

<h1 id="JavaScript入门（三）"><a href="#JavaScript入门（三）" class="headerlink" title="JavaScript入门（三）"></a>JavaScript入门（三）</h1><h2 id="一、创建对象的三种方式"><a href="#一、创建对象的三种方式" class="headerlink" title="一、创建对象的三种方式"></a>一、创建对象的三种方式</h2><ol>
<li>调用系统的构造函数创建对象</li>
</ol>
<p>var 变量名= new Object(); Object 是系统的构造函数  Array</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂模式创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();<span class="comment">//创建对象</span></span><br><span class="line">  <span class="comment">//添加属性</span></span><br><span class="line">  obj.name = name;</span><br><span class="line">  obj.age = age;</span><br><span class="line">  <span class="comment">//添加方法</span></span><br><span class="line">  obj.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;阿涅哈斯诶呦,我叫:&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;我今年:&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建人的对象</span></span><br><span class="line"><span class="keyword">var</span> per1 = createObject(<span class="string">&quot;小芳&quot;</span>,<span class="number">20</span>);</span><br><span class="line">per1.sayHi();</span><br><span class="line"><span class="comment">//创建一个人的对象</span></span><br><span class="line"><span class="keyword">var</span> per2 = createObject(<span class="string">&quot;小红&quot;</span>,<span class="number">30</span>);</span><br><span class="line">per2.sayHi();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>自定义构造函数创建对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义构造函数创建对象,我要自己定义一个构造函数,自定义构造函数,创建对象</span></span><br><span class="line"><span class="comment">//函数和构造函数的区别；名字是不是大写(首字母是大写)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name=name;</span><br><span class="line">  <span class="built_in">this</span>.age=age;</span><br><span class="line">  <span class="built_in">this</span>.sayHi=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我叫:&quot;</span>+<span class="built_in">this</span>.name+<span class="string">&quot;,年龄是:&quot;</span>+<span class="built_in">this</span>.age);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义构造函数创建对象:先自定义一个构造函数,创建对象</span></span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Person(<span class="string">&quot;小明&quot;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);</span><br><span class="line"><span class="built_in">console</span>.log(obj.age);</span><br><span class="line">obj.sayHi();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>字面量的方式创建对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;&#125;;</span><br><span class="line">obj.name=<span class="string">&quot;小白&quot;</span>;</span><br><span class="line">obj.age=<span class="number">10</span>;</span><br><span class="line">obj.sayHi=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;我是:&quot;</span>+<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line">obj.sayHi();</span><br><span class="line"><span class="keyword">var</span> obj2=&#123;</span><br><span class="line">  name:<span class="string">&quot;小明&quot;</span>,</span><br><span class="line">  age:<span class="number">20</span>,</span><br><span class="line">  sayHi:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我是:&quot;</span>+<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  eat:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;吃了&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj2.sayHi();</span><br><span class="line">obj2.eat();</span><br></pre></td></tr></table></figure>

<p>总结：工厂模式和自定义构造函数的异同</p>
<p>共同点:都是函数,都可以创建对象,都可以传入参数</p>
<p>工厂模式:</p>
<ul>
<li><p>函数名是小写</p>
</li>
<li><p>有new,</p>
</li>
<li><p>有返回值</p>
</li>
<li><p>new之后的对象是当前的对象</p>
</li>
<li><p>直接调用函数就可以创建对象</p>
</li>
</ul>
<p>自定义构造函数:</p>
<ul>
<li><p>函数名是大写(首字母)</p>
</li>
<li><p>没有new</p>
</li>
<li><p>没有返回值</p>
</li>
<li><p>this是当前的对象</p>
</li>
<li><p>通过new的方式来创建对象</p>
</li>
</ul>
<h2 id="二、json数据格式"><a href="#二、json数据格式" class="headerlink" title="二、json数据格式"></a>二、json数据格式</h2><p>JSON格式的数据:一般都是成对的,是键值对,</p>
<p>json也是一个对象,数据都是成对的,一般json格式的数据无论是键还是值都是用双引号括起来的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="string">&quot;10&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sex&quot;</span>: <span class="string">&quot;男&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//遍历对象,是不能通过for循环遍历,无序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//key是一个变量,这个变量中存储的是该对象的所有的属性的名字</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> json) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot;===========&quot;</span> + json[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、简单数据类型和复杂数据类型"><a href="#三、简单数据类型和复杂数据类型" class="headerlink" title="三、简单数据类型和复杂数据类型"></a>三、简单数据类型和复杂数据类型</h2><p>原始数据类型: number,string,boolean,undefined, null,object<br>基本类型(简单类型),值类型: number,string,boolean<br>复杂类型(引用类型):object<br>空类型:undefined,null</p>
<p>值类型的值在哪一块空间中存储? 栈中存储<br>引用类型的值在哪一块空间中存储?对象在堆上存储,地址在栈上存储</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">10</span>;<span class="comment">//值类型,值在栈上</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;&#125;;<span class="comment">//复杂类型,对象在堆,地址(引用)在栈</span></span><br></pre></td></tr></table></figure>

<p>值类型之间传递,传递的是值<br>引用类型之间传递,传递的是地址(引用)</p>
<p>值类型作为函数的参数,传递的是值<br>引用类型作为函数的参数,传递的是</p>
<h2 id="四、内置对象"><a href="#四、内置对象" class="headerlink" title="四、内置对象"></a>四、内置对象</h2><h1 id="JavaScript入门（四）"><a href="#JavaScript入门（四）" class="headerlink" title="JavaScript入门（四）"></a>JavaScript入门（四）</h1><h2 id="BOM内容"><a href="#BOM内容" class="headerlink" title="BOM内容"></a>BOM内容</h2><p>BOM:Browser Object Model:浏览器对象模型</p>
<p>BOM中的顶级对象就是window</p>
<p>DOM中页面中有一个顶级对象:Document</p>
<p>window—-皇上。页面中所有的内容都是window,变量是属于window的,函数也是属于window,对象都是window的（但是实际开发过程为了方便和维护，可以将window省略）<br>document–总管太监</p>
<h2 id="BOM中的三个对话框"><a href="#BOM中的三个对话框" class="headerlink" title="BOM中的三个对话框"></a>BOM中的三个对话框</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alert(<span class="string">&quot;哈哈,我又变帅了&quot;</span>);</span><br><span class="line"><span class="built_in">window</span>.alert(<span class="string">&quot;哦也&quot;</span>);</span><br><span class="line"><span class="built_in">window</span>.prompt(<span class="string">&quot;请输入内容&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PS：alert对话框是浏览器自带的，所以无法修改其样式。建议使用其他ui自带的对话框。比如element-ui的dialog</p>
<h2 id="页面的加载事件"><a href="#页面的加载事件" class="headerlink" title="页面的加载事件"></a>页面的加载事件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//页面的加载事件,页面中所有的内容加载完毕后才执行，这个onload 其实可以自定义名称，比如myonload</span></span><br><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//通过id获取元素</span></span><br><span class="line">  <span class="keyword">var</span> btnObj=<span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(btnObj.value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//js中设置定时器的第一种方法</span></span><br><span class="line">	<span class="comment">//参数1:函数</span></span><br><span class="line">    <span class="comment">//参数2:时间---1000毫秒---1秒</span></span><br><span class="line">    <span class="comment">//返回值:该定时器的id</span></span><br><span class="line">    <span class="comment">//执行过程:页面加载后,过了1秒才执行函数中的代码,函数中的代码执行完毕后,又过了一秒再执行函数中的代码,只要定时器不清理,就是执行方式</span></span><br><span class="line">   <span class="keyword">var</span> timeId = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     alert(<span class="string">&quot;你瞅啥?瞅你咋地?&quot;</span>);</span><br><span class="line">   &#125;,<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//清理定时器的方法</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(timeId);</span><br><span class="line"><span class="comment">//js中设置定时器的第二种方法</span></span><br><span class="line"><span class="comment">//定时器 异步运行</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用方法名字执行方法</span></span><br><span class="line">    <span class="keyword">var</span> t1 = <span class="built_in">window</span>.setTimeout(hello,<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">var</span> t2 = <span class="built_in">window</span>.setTimeout(<span class="string">&quot;hello()&quot;</span>,<span class="number">3000</span>);<span class="comment">//使用字符串执行方法</span></span><br><span class="line">    <span class="built_in">window</span>.clearTimeout(t1);<span class="comment">//去掉定时器</span></span><br></pre></td></tr></table></figure>

<p>两种方法根据不同的场景和业务需求择而取之，</p>
<p>一般情况下setTimeout用于延迟执行某方法或功能，是一次性的</p>
<p>setInterval则一般用于刷新表单，对于一些表单的假实时指定时间刷新同步</p>
<p><strong>setTimeout()使用注意点：</strong></p>
<p>setTimeout函数调用写法有:</p>
<ol>
<li><p>setTimeout(fn, timeout)</p>
</li>
<li><p>setTimeout(‘fn()’, timeout)</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//没加引号就直接执行函数showTime了……造成递归死循环，导致内存的溢出</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;233&#x27;</span>)</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="string">&#x27;show()&#x27;</span>,<span class="number">1000</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="JavaScript的location对象"><a href="#JavaScript的location对象" class="headerlink" title="JavaScript的location对象"></a>JavaScript的location对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//地址栏上#及后面的内容</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.location.hash);</span><br><span class="line"><span class="comment">//主机名字和端口号</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.location.host);</span><br><span class="line"><span class="comment">//主机名字</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.location.hostname);</span><br><span class="line"><span class="comment">//文件的相对路径</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.location.pathname);</span><br><span class="line"><span class="comment">//端口</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.location.port);</span><br><span class="line"><span class="comment">//协议</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.location.protocol);</span><br><span class="line"><span class="comment">//搜索的内容:获取的是?及后面的内容</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.location.search);</span><br><span class="line"><span class="comment">//和location.href属性是一样的操作,</span></span><br><span class="line">location.assign(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"><span class="comment">//替换的地址的,没有历史记录</span></span><br><span class="line">location.replace(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">location.reload();<span class="comment">//刷新</span></span><br></pre></td></tr></table></figure>

<h2 id="javaScript的history对象"><a href="#javaScript的history对象" class="headerlink" title="javaScript的history对象"></a>javaScript的history对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;跳一下&quot;</span> id=<span class="string">&quot;btn1&quot;</span>/&gt;</span><br><span class="line">第一个页面</span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;去吧&quot;</span> id=<span class="string">&quot;btn2&quot;</span>/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn1&quot;</span>).onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      location.href=<span class="string">&quot;11test.html&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn2&quot;</span>).onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//前进</span></span><br><span class="line">    history.forward();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//想要前进和后退,必须要有历史记录</span></span><br><span class="line">  history.forward();<span class="comment">//前进</span></span><br><span class="line">  history.back();<span class="comment">//后退</span></span><br><span class="line">  history.go();<span class="comment">//如果是正数就是前进,负数就是后退</span></span><br></pre></td></tr></table></figure>

<h2 id="DOM内容"><a href="#DOM内容" class="headerlink" title="DOM内容"></a>DOM内容</h2><h2 id="变量提升和函数提升"><a href="#变量提升和函数提升" class="headerlink" title="变量提升和函数提升"></a>变量提升和函数提升</h2><p>变量提升:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;233&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以上例子相当于</span></span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a) </span><br><span class="line">a = <span class="string">&quot;233&quot;</span></span><br></pre></td></tr></table></figure>

<p>变量提升会导致一个问题就是变量覆盖：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">a = <span class="string">&quot;233&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a; <span class="comment">// 全局变量会被局部作用域中的同名变量覆盖</span></span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">    a = <span class="string">&quot;a1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>函数提升：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo1); <span class="comment">// [Function: foo1]</span></span><br><span class="line"></span><br><span class="line">foo1() <span class="comment">// foo1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo2) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">foo2() <span class="comment">// TypeError: foo2 is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo2&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getName()   <span class="comment">//  由于函数声明的提升，所以输出2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于转化为下面的代码</span></span><br><span class="line"><span class="keyword">var</span> getName</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getName()   <span class="comment">//输出2</span></span><br></pre></td></tr></table></figure>

<p>即函数提升只会提升函数声明，而不会提升函数表达式。</p>
<h2 id="for-in-循环、-for-of-循环和foreach"><a href="#for-in-循环、-for-of-循环和foreach" class="headerlink" title="for-in 循环、 for-of 循环和foreach"></a>for-in 循环、 for-of 循环和foreach</h2><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">console</span>.log(item))  <span class="comment">//1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)        <span class="comment">//  输出的是key,即对应的索引0,1,2,3,4</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> [i] <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)        <span class="comment">//  输出的是value,即对应的值1,2,3,4,5</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> [k,v] <span class="keyword">of</span> arr.entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k,v)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  0 1</span></span><br><span class="line"><span class="comment">//  1 2</span></span><br><span class="line"><span class="comment">//  2 3</span></span><br><span class="line"><span class="comment">//  3 4</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//str.forEach(item =&gt; console.log(item))    //  报错，foreach是用于遍历数组的api</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> str)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)        <span class="comment">//  输出的是key,即对应的索引0,1,2,3,4</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> str)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)        <span class="comment">//  输出的是value,即对应的值h,e,l,l,o</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name : <span class="string">&quot;james&quot;</span>,</span><br><span class="line">    age: <span class="number">15</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//1. 使用for in遍历</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> obj)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;item&#125;</span> : <span class="subst">$&#123;obj[item]&#125;</span>`</span>)     <span class="comment">//name : james  age : 15</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 使用Object.keys()和Object.values()</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj))&#123;         <span class="comment">//  也可以使用Object.values()取值</span></span><br><span class="line">  <span class="built_in">console</span>.log(item)                       <span class="comment">//name    age</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.使用getOwnPropertyNames</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key+ <span class="string">&#x27;---&#x27;</span>+obj[key])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="遍历Map-和Set"><a href="#遍历Map-和Set" class="headerlink" title="遍历Map 和Set"></a>遍历Map 和Set</h3><p>遍历Set；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> arr)&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(item)     <span class="comment">//  无输出，因为Set结构没有键名，只有键值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(item)   <span class="comment">//  1，2，3，4，5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历Map：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&#x27;name&#x27;</span> ,<span class="string">&quot;james&quot;</span>],</span><br><span class="line">    [<span class="string">&#x27;age&#x27;</span> ,<span class="number">28</span>],</span><br><span class="line">  ])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key,value] <span class="keyword">of</span> map)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key,value)       <span class="comment">//  name james   age 28</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> map)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)       <span class="comment">//  name age</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> map)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(map[item])    <span class="comment">// james  28</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>foreach 方法没办法使用 break 语句跳出循环，或者使用return从函数体内返回</p>
</li>
<li><p>for…of</p>
</li>
</ol>
<ul>
<li>可以避免所有 for-in 循环的陷阱</li>
<li>不同于 forEach()，可以使用 break, continue 和 return</li>
<li>for-of 循环不仅仅支持数组的遍历。同样适用于很多类似数组的对象</li>
<li>它也支持字符串的遍历</li>
<li>for-of 并不适用于处理原有的原生对象</li>
</ul>
<p>能够被for…of正常遍历的，都需要实现一个遍历器Iterator。<br>而数组、字符串、Set、Map结构，早就内置好了Iterator（迭代器），它们的原型中都有一个Symbol.iterator方法，而Object对象并没有实现这个接口，使得它无法被for…of遍历。</p>
<h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><ul>
<li>运算中其中⼀⽅为字符串，那么就会把另⼀⽅也转换为字符串 </li>
<li>如果⼀⽅不是字符串或者数字，那么会将它转换为数字或者字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;1&#x27;</span> <span class="comment">// &#x27;11&#x27; </span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span> <span class="comment">// 2 </span></span><br><span class="line"><span class="number">4</span> + [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// &quot;41,2,3&quot;</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> + + <span class="string">&#x27;b&#x27;</span> <span class="comment">// -&gt; &quot;aNaN&quot; </span></span><br></pre></td></tr></table></figure>

<p>对于第⼀⾏代码来说，触发特点⼀，所以将数字 1 转换为字符串，得到结果 ‘11’<br>对于第⼆⾏代码来说，触发特点⼆，所以将 true 转为数字 1<br>对于第三⾏代码来说，触发特点⼆，所以将数组通过 toString 转为字符串 1,2,3 ，得 到结果 41,2,3<br>对于第四行代码来说，因为 + ‘b’ 等于 NaN ，所以结果为 “aNaN” ，你可能也会在⼀些代码中看到过 + ‘1’ 的形式来快速获取 number 类型。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> * <span class="string">&#x27;3&#x27;</span> <span class="comment">// 12 </span></span><br><span class="line"><span class="number">4</span> * [] <span class="comment">// 0 </span></span><br><span class="line"><span class="number">4</span> * [<span class="number">1</span>, <span class="number">2</span>] <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p><strong>那么对于除了加法的运算符来说，只要其中⼀⽅是数字，那么另⼀⽅就会被转为数字</strong></p>
<h2 id="和-有什么区别"><a href="#和-有什么区别" class="headerlink" title="== 和 === 有什么区别"></a>== 和 === 有什么区别</h2><p><strong>对于 == 来说，如果对⽐双⽅的类型不⼀样的话，就会进⾏类型转换</strong></p>
<p>假如我们需要对⽐ x 和 y 是否相同，就会进⾏如下判断流程</p>
<ol>
<li>⾸先会判断两者类型是否相同。相同的话就是⽐⼤⼩了 </li>
<li>类型不相同的话，那么就会进⾏类型转换 </li>
<li>会先判断是否在对⽐ null 和 undefined ，是的话就会返回 true </li>
<li>判断两者类型是否为 string 和 number ，是的话就会将字符串转换为 number</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">&#x27;1&#x27;</span>      <span class="comment">//转换为</span></span><br><span class="line"><span class="number">1</span> ==  <span class="number">1</span> </span><br></pre></td></tr></table></figure>

<ol start="5">
<li>判断其中⼀⽅是否为 boolean ，是的话就会把 boolean 转为 number 再进⾏判断</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span> == <span class="literal">true</span> </span><br><span class="line"><span class="string">&#x27;1&#x27;</span> ==  <span class="number">1</span> </span><br><span class="line"> <span class="number">1</span>  ==  <span class="number">1</span> </span><br></pre></td></tr></table></figure>

<p><strong>对于 === 来说就简单多了，就是判断两者类型和值是否相同</strong></p>
<p>Object.is相对于 === 的改进，就是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(-<span class="number">0</span>,+<span class="number">0</span>)  <span class="comment">//  false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>)  <span class="comment">//  true</span></span><br></pre></td></tr></table></figure>

<h2 id="深浅拷⻉"><a href="#深浅拷⻉" class="headerlink" title="深浅拷⻉"></a>深浅拷⻉</h2><p><strong>浅拷⻉</strong></p>
<ol>
<li>⾸先可以通过 Object.assign 来解决这个问题，很多⼈认为这个函数是⽤来 深拷⻉的。其实并不是， Object.assign 只会拷⻉所有的属性值到新的对象中，如果属性值是对象的话，拷⻉的是地址，所以并不是深拷⻉。但是要注意的是：<strong>当object只有一层的时候，是深拷贝。</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;   </span><br><span class="line">  age: <span class="number">1</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a) </span><br><span class="line">a.age = <span class="number">2</span> </span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// age: 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// age: 2</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>另外我们还可以通过展开运算符 … 来实现浅拷⻉</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;   </span><br><span class="line">  age: <span class="number">1</span>,   </span><br><span class="line">  jobs: &#123;     </span><br><span class="line">    first: <span class="string">&#x27;FE&#x27;</span>   </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> b = &#123; ...a &#125; </span><br><span class="line">a.jobs.first = <span class="string">&#x27;native&#x27;</span> </span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// native</span></span><br></pre></td></tr></table></figure>

<p>浅拷⻉只解决了第⼀层的问题，如果接下去的值中还有对象的话，那么就⼜回到Y开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使⽤深拷⻉了。</p>
<p>深拷⻉</p>
<p>这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;   </span><br><span class="line">  age: <span class="number">1</span>,   </span><br><span class="line">  jobs: &#123;     </span><br><span class="line">    first: <span class="string">&#x27;FE&#x27;</span>   </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a)) </span><br><span class="line">a.jobs.first = <span class="string">&#x27;native&#x27;</span> </span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// FE</span></span><br></pre></td></tr></table></figure>

<p>但是该⽅法也是有局限性的：</p>
<ul>
<li>会忽略 undefined </li>
<li>会忽略 symbol </li>
<li>不能序列化函数 </li>
<li>不能解决循环引⽤</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/25/vue/13%20%E7%BB%84%E4%BB%B6%E4%B8%ADcss%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E6%8A%BD%E7%A6%BB%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/25/vue/13%20%E7%BB%84%E4%BB%B6%E4%B8%ADcss%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E6%8A%BD%E7%A6%BB%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">十三、组件中css的作用域、抽离路由模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-25 15:16:54" itemprop="dateCreated datePublished" datetime="2019-01-25T15:16:54+08:00">2019-01-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="组件中css的作用域、抽离路由模块"><a href="#组件中css的作用域、抽离路由模块" class="headerlink" title="组件中css的作用域、抽离路由模块"></a>组件中css的作用域、抽离路由模块</h1><p>1、为了使组件中的css样式不影响全局，可以在style标签内多加一个scoped属性</p>
<p>2、抽离路由模块</p>
<p>新建一个router.js</p>
<p>a、导入组件</p>
<p>b、创建路由对象</p>
<p>c、设置子路由，并设置路径</p>
<p>d、将该路由暴露出去</p>
<p>document.cookie=”track_id=1545690009|eddde566ae9aa2b35a454e91ee2342a127b11148a8eaec390b|a73c8c1097ae7b5ef779f762abacfb1b; domain=ele.me; path=/“;document.cookie=”USERID=3692924746; domain=ele.me; path=/“;document.cookie=”SID=zkGQB2wu1nCjmOXtiHZmkOMpabWHwiPZgVVg; domain=ele.me; path=/“;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">// 导入 Account 组件</span></span><br><span class="line"><span class="keyword">import</span> account <span class="keyword">from</span> <span class="string">&#x27;./main/Account.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> goodslist <span class="keyword">from</span> <span class="string">&#x27;./main/GoodsList.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入Account的两个子组件</span></span><br><span class="line"><span class="keyword">import</span> login <span class="keyword">from</span> <span class="string">&#x27;./subcom/login.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> register <span class="keyword">from</span> <span class="string">&#x27;./subcom/register.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  创建路由对象</span></span><br><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// account  goodslist</span></span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/account&#x27;</span>,</span><br><span class="line">      component: account,</span><br><span class="line">      children: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;login&#x27;</span>, <span class="attr">component</span>: login &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;register&#x27;</span>, <span class="attr">component</span>: register &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/goodslist&#x27;</span>, <span class="attr">component</span>: goodslist &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把路由对象暴露出去</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/25/vue/12%20webpack%E7%BB%93%E5%90%88%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/25/vue/12%20webpack%E7%BB%93%E5%90%88%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">十二、webpack结合路由的使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-25 13:46:52" itemprop="dateCreated datePublished" datetime="2019-01-25T13:46:52+08:00">2019-01-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="webpack结合路由的使用"><a href="#webpack结合路由的使用" class="headerlink" title="webpack结合路由的使用"></a>webpack结合路由的使用</h1><p>1、在main.js中导入vue-router包</p>
<p>2、手动安装VueRouter</p>
<p>3、导入组件 </p>
<p>4、创建路由对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 1. 导入 vue-router 包</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">// 2. 手动安装 VueRouter </span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入 app 组件</span></span><br><span class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="comment">// 导入 Account 组件</span></span><br><span class="line"><span class="keyword">import</span> account <span class="keyword">from</span> <span class="string">&#x27;./main/Account.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> goodslist <span class="keyword">from</span> <span class="string">&#x27;./main/GoodsList.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建路由对象</span></span><br><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// account  goodslist</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/account&#x27;</span>, <span class="attr">component</span>: account &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/goodslist&#x27;</span>, <span class="attr">component</span>: goodslist &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  render: <span class="function"><span class="params">c</span> =&gt;</span> c(app), <span class="comment">// render 会把 el 指定的容器中，所有的内容都清空覆盖，所以 不要 把 路由的 router-view 和 router-link 直接写到 el 所控制的元素中</span></span><br><span class="line">  router <span class="comment">// 4. 将路由对象挂载到 vm 上</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意： App 这个组件，是通过 VM 实例的 render 函数，渲染出来的， render 函数如果要渲染 组件， 渲染出来的组件，只能放到 el: &#x27;#app&#x27; 所指定的 元素中；</span></span><br><span class="line"><span class="comment">// Account 和 GoodsList 组件， 是通过 路由匹配监听到的，所以， 这两个组件，只能展示到 属于 路由的 &lt;router-view&gt;&lt;/router-view&gt; 中去；</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leslie choi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
