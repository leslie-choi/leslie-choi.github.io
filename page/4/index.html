<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yoursite.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta property="og:type" content="website">
<meta property="og:title" content="404 not found">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="404 not found">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="leslie choi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/4/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;4&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>404 not found</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">404 not found</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">leslie choi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/08/ES6/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%92%8C%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/08/ES6/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%92%8C%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">前端模块化开发和打包工具</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-08 15:30:25" itemprop="dateCreated datePublished" datetime="2019-05-08T15:30:25+08:00">2019-05-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-14 22:59:06" itemprop="dateModified" datetime="2021-04-14T22:59:06+08:00">2021-04-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前端模块化开发"><a href="#前端模块化开发" class="headerlink" title="前端模块化开发"></a>前端模块化开发</h1><p>前言：历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。而现在的前端开发，不仅仅是完成浏览的基本需求，并且通常是一个单页面应用，每一个视图通过异步的方式加载，这导致页面初始化和使用过程中会加载越来越多的 JavaScript 代码. 如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统。</p>
<h2 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h2><p>所谓的模块化开发就是封装细节，提供使用接口，彼此之间互不影响，每个模块都是实现某一特定的功能。模块化开发的基础就是函数，这种模块化类似于 java中的包 直接引入，即插即用，不会产生变量冲突，就是如此便捷。<br>存在问题：</p>
<ul>
<li>全局变量和函数变量冲突：使用自执行函数</li>
<li>依赖顺序问题以及重复引入的问题：将所有的文件按依赖顺序合并或者检查head标签，确保依赖的顺序</li>
<li>按需加载的问题，只需要使用某个库中的一个功能，却不得不将整个库引入：手动分离所需的代码</li>
</ul>
<h2 id="目前前端模块化的解决方案"><a href="#目前前端模块化的解决方案" class="headerlink" title="目前前端模块化的解决方案"></a>目前前端模块化的解决方案</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p><strong>服务器端</strong>的 Node.js 遵循 CommonJS规范，该规范的核心思想是允许模块通过 require 方法来<strong>同步加载</strong>所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;module&quot;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;../file.js&quot;</span>);</span><br><span class="line"><span class="built_in">exports</span>.doStuff = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = someValue;</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>服务器端模块便于重用</li>
<li>NPM 中已经有将近20万个可以使用模块包</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
</ul>
<p>缺点：</p>
<ul>
<li>只能在服务端(Node.js)使用, 不能在浏览器直接使用</li>
<li>模块是同步加载的, 如果加载过慢会阻塞进程</li>
</ul>
<h3 id="AMD规范（Asyncchronous-Module-Definition-异步模块定义）"><a href="#AMD规范（Asyncchronous-Module-Definition-异步模块定义）" class="headerlink" title="AMD规范（Asyncchronous Module Definition 异步模块定义）"></a>AMD规范（Asyncchronous Module Definition 异步模块定义）</h3><p>由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，<br>所以CommonJS规范比较适用服务器。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。</p>
<p>define(id?, dependencies?, factory)，它要在声明模块的时候指定所有的依赖 dependencies，并且还要当做形参传到 factory 中，对于依赖的模块提前执行，依赖前置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个名为 myModule 的模块，它依赖 jQuery 模块</span></span><br><span class="line">define(<span class="string">&#x27;myModule&#x27;</span>, [<span class="string">&#x27;jquery&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// $ 是 jquery 模块的输出</span></span><br><span class="line">    $(<span class="string">&#x27;body&#x27;</span>).text(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">define([<span class="string">&#x27;myModule&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myModule</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>requirejs遵循这个规范</strong></p>
<p>优点：</p>
<ul>
<li>可以在浏览器环境中异步加载模块</li>
<li>能够并行加载多个模块</li>
<li>体验好，没有延迟，依赖的模块被提前执行了</li>
</ul>
<p>缺点：</p>
<ul>
<li>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块</li>
<li>预下载, 预解释, 带来额外性能消耗</li>
</ul>
<h3 id="CMD规范-Common-Module-Definition-通用模块定义"><a href="#CMD规范-Common-Module-Definition-通用模块定义" class="headerlink" title="CMD规范(Common Module Definition 通用模块定义)"></a>CMD规范(Common Module Definition 通用模块定义)</h3><p>CMD是SeaJS 在推广过程中对模块定义的规范化产出。</p>
<p>CMD和AMD的比较：</p>
<ul>
<li>AMD推崇(但不强制)依赖前置，在定义模块的时候就要用require声明其依赖的</li>
<li><strong>CMD推崇(但不强制)就近依赖，只有在用到某个模块的时候再去require</strong></li>
<li>CMD不需要AMD那样的回调写法, 可以像CommonJS一样的同步写法(但加载其实还是异步的)</li>
<li>AMD模块是提前执行的, 而CMD模块默认是延迟执行的（性能更好）</li>
</ul>
<h3 id="ES6-Module-面向未来的标准"><a href="#ES6-Module-面向未来的标准" class="headerlink" title="ES6 Module(面向未来的标准)"></a>ES6 Module(面向未来的标准)</h3><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。<br>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>定义模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量, module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> bar = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数, module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一导出&amp;重命名, module.js</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; bar <span class="keyword">as</span> myBar, foo &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出, module.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo</span><br></pre></td></tr></table></figure>

<p>引用模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从模块中导入指定对象, 支持重命名, main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar <span class="keyword">as</span> myBar &#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从模块中导入默认对象(名称可跟原名称不一样)</span></span><br><span class="line"><span class="keyword">import</span> myFoo <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行模块, 但不导入任何值</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体导入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myModule <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="对于-CommonJS-和-ES6-中的模块化的两者区别是："><a href="#对于-CommonJS-和-ES6-中的模块化的两者区别是：" class="headerlink" title="对于 CommonJS 和 ES6 中的模块化的两者区别是："></a>对于 CommonJS 和 ES6 中的模块化的两者区别是：</h3><ul>
<li>前者⽀持动态导⼊，也就是 require(${path}/xx.js) ，后者⽬前不⽀持，但是已有提案,前者是同步导⼊，因为⽤于服务端，⽂件都在本地，同步导⼊即使卡住主线程影响也不⼤。</li>
<li>⽽后者是异步导⼊，因为⽤于浏览器，需要下载⽂件，如果也采⽤同步导⼊会对渲染有很<br>⼤影响</li>
<li>前者在导出时都是值拷⻉，就算导出的值变了，导⼊的值也不会改变，所以如果想更新值，必须重新导⼊⼀次。</li>
<li>但是后者采⽤实时绑定的⽅式，导⼊导出的值都指向同⼀个内存地址，所以导⼊值会跟随导出值变化</li>
<li>后者会编译成 require/exports 来执⾏的</li>
</ul>
<h1 id="模块化打包工具"><a href="#模块化打包工具" class="headerlink" title="模块化打包工具"></a>模块化打包工具</h1><p>由于模块化方案多样, 且浏览器支持不一, 再加上上述模块化方案仅仅支持JavaScript本身, 对 于复杂的前端应用来说远远不够用, 因此出现了各种打包工具来解决这些问题。</p>
<ul>
<li>早期打包工具</li>
</ul>
<ol>
<li>r.js – RequireJS提供的打包工具,仅仅支持RequireJS</li>
<li>SPM – SeaJS提供的打包工具,仅仅支持SeaJS</li>
<li>browserify – 让浏览器使用Node.js的NPM模块</li>
<li>gulp/grunt/fis – 前端自动化构建, 用来测试,压缩,检错,合并前端代码, 不支持模块化(类似Maven/Gradle)</li>
</ol>
<ul>
<li>现代打包工具</li>
</ul>
<ol>
<li>webpack – 高度可配置的静态资源打包器, 有着强大的插件和生态</li>
<li>rollup – 小巧高效的前端资源打包器, 适合用来编写库或框架</li>
<li>parcel – 后起之秀, 极速零配置Web应用打包工具</li>
</ol>
<p>webpack和gulp的区别：</p>
<p>gulp是<strong>基于流的构建工具</strong>：all in one的打包模式，输出一个js文件和一个css文件，优点是减少http请求，万金油方案。<br>webpack是<strong>模块化管理工具</strong>，使用webpack可以对模块进行压缩、预处理、打包、按需加载等。</p>
<p><strong>总结：</strong><br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/zongjie.png" alt="markdown"></p>
<h1 id="webpack概念"><a href="#webpack概念" class="headerlink" title="webpack概念"></a>webpack概念</h1><p>webpack是收把项目当作一个整体，通过一个给定的的主文件，webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包成一个或多个浏览器可识别的js文件。我们可以把webpack理解为一个工厂，进入相当于把各种各样的原料放进我们的工厂了，然后工厂进行一系列的打包操作把打包好的东西，向外输出，然后就可以去出售了(上线)。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/9/27/2395e1d01728fbb0d740d53c4530ed5b?imageView2/0/w/1280/h/960&ynotemdtimestamp=1558167915965" alt="markdown"></p>
<p>要使用webpack，则首先添加我们即将使用的包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure>

<p>webpack是我们需要的模块打包机，webpack-dev-server用来创建本地服务器，监听你的代码修改，并自动刷新修改后的结果。这些是有关devServer的配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./app/entry&quot;</span>, <span class="comment">// string | object | array</span></span><br><span class="line">  <span class="comment">// Webpack打包的入口</span></span><br><span class="line">  output: &#123;  <span class="comment">// 定义webpack如何输出的选项</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>), <span class="comment">// string</span></span><br><span class="line">    <span class="comment">// 所有输出文件的目标路径</span></span><br><span class="line">    filename: <span class="string">&quot;[chunkhash].js&quot;</span>, <span class="comment">// string</span></span><br><span class="line">    <span class="comment">// 「入口(entry chunk)」文件命名模版</span></span><br><span class="line">    publicPath: <span class="string">&quot;/assets/&quot;</span>, <span class="comment">// string</span></span><br><span class="line">    <span class="comment">// 构建文件的输出目录</span></span><br><span class="line">    <span class="comment">/* 其它高级配置 */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;  <span class="comment">// 模块相关配置</span></span><br><span class="line">    rules: [ <span class="comment">// 配置模块loaders，解析规则</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,  <span class="comment">// RegExp | string</span></span><br><span class="line">        include: [ <span class="comment">// 和test一样，必须匹配选项</span></span><br><span class="line">          path.resolve(__dirname, <span class="string">&quot;app&quot;</span>)</span><br><span class="line">        ],</span><br><span class="line">        exclude: [ <span class="comment">// 必不匹配选项（优先级高于test和include）</span></span><br><span class="line">          path.resolve(__dirname, <span class="string">&quot;app/demo-files&quot;</span>)</span><br><span class="line">        ],</span><br><span class="line">        loader: <span class="string">&quot;babel-loader&quot;</span>, <span class="comment">// 模块上下文解析</span></span><br><span class="line">        options: &#123; <span class="comment">// loader的可选项</span></span><br><span class="line">          presets: [<span class="string">&quot;es2015&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123; <span class="comment">//  解析模块的可选项</span></span><br><span class="line">    modules: [ <span class="comment">// 模块的查找目录</span></span><br><span class="line">      <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">      path.resolve(__dirname, <span class="string">&quot;app&quot;</span>)</span><br><span class="line">    ],</span><br><span class="line">    extensions: [<span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.json&quot;</span>, <span class="string">&quot;.jsx&quot;</span>, <span class="string">&quot;.css&quot;</span>], <span class="comment">// 用到的文件的扩展</span></span><br><span class="line">    alias: &#123; <span class="comment">// 模块别名列表</span></span><br><span class="line">      <span class="string">&quot;module&quot;</span>: <span class="string">&quot;new-module&quot;</span></span><br><span class="line">	  &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">&quot;source-map&quot;</span>, <span class="comment">// enum</span></span><br><span class="line">  <span class="comment">// 为浏览器开发者工具添加元数据增强调试</span></span><br><span class="line">  plugins: [ <span class="comment">// 附加插件列表</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>首先我们需要了解webpack的几个核心概念：</strong></p>
<ul>
<li><p>entry: 用来写入口文件，它将是整个依赖关系的根,当我们需要多个入口文件的时候，可以把entry写成一个对象.</p>
</li>
<li><p>output: 告诉webpack如何命名输出的文件以及输出的目录，即使入口文件有多个，但是只有一个输出配置</p>
</li>
<li><p>Loader：由于webpack只能处理javascript，所以我们需要对一些非js文件处理成webpack能够处理的模块，比如sass文件</p>
</li>
</ul>
<p>loader的作用： </p>
<ol>
<li><p>实现对不同格式的文件的处理，比如说将scss转换为css，或者typescript转化为js</p>
</li>
<li><p>转换这些文件，从而使其能够被添加到依赖图中 loader是webpack最重要的部分之一，通过使用不同的Loader，我们能够调用外部的脚本或者工具，实现对不同格式文件的处理，loader需要在webpack.config.js里边单独用module进行配置</p>
</li>
</ol>
<ul>
<li>Plugins：Loaders将各类型的文件处理成webpack能够处理的模块，plugins有着很强的能力。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。但也是最复杂的一个。</li>
</ul>
<p>plugins和loader很容易搞混，说都是外部引用有什么区别呢？ 事实上他们是两个完全不同的东西。这么说loaders负责的是处理源文件的如scss、jsx，一次处理一个文件。而plugins并不是直接操作单个文件，它直接对整个构建过程起作用。下面列举了一些我们常用的plugins和他的用法</p>
<ul>
<li>Chunk：我们可以对一些代码打包成一个单独的chunk，比如某些公共模块，去重，更好的利用缓存。或者按需加载某些功能模块，优化加载时间。在webpack3及以前我们都利用CommonsChunkPlugin将一些公共代码分割成一个chunk，实现单独加载。在webpack4 中CommonsChunkPlugin被废弃，使用SplitChunksPlugin</li>
</ul>
<h2 id="webpack的打包流程"><a href="#webpack的打包流程" class="headerlink" title="webpack的打包流程"></a>webpack的打包流程</h2><p><strong>初始化配置参数 -&gt; 绑定事件钩子回调 -&gt; 确定Entry逐一遍历 -&gt; 使用loader编译文件 -&gt; 输出文件</strong></p>
<ol>
<li>webpack首先会扫描整个项目，找到默认的配置文件。webpack.config.js</li>
<li>然后根据配置文件的entry入口，找到需要当前需要打包的文件（一个项目可能有多个入口）</li>
<li>在module中配置对应的规则，通过正则表达式匹配对应的文件类型，然后安装对应的loader，让loader执行对应的打包操作</li>
<li>最后配置一个output出口，可以设置output输出的文件名，也可以设置输出的文件位置（即使入口文件有多个，但是只有一个输出配置）</li>
</ol>
<h2 id="webpack事件流"><a href="#webpack事件流" class="headerlink" title="webpack事件流"></a>webpack事件流</h2><p>Webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。</p>
<p>Webpack 通过 Tapable(webpack自带的模块) 来组织这条复杂的生产线。 Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 Webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。 </p>
<p>webpack本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是Tapable，webpack中最核心的负责编译的Compiler和负责创建bundles的Compilation都是Tapable的实例。</p>
<p><strong>Tapable的原理其实就是通过发布者-订阅者模式实现</strong>，通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会收到通知。在现实生活中，也有很多类似场景，比如我需要在购物网站上购买一个产品，但是发现该产品目前处于缺货状态，这时候我可以点击有货通知的按钮，让网站在产品有货的时候通过短信通知我。</p>
<h2 id="webpack运行流程详解"><a href="#webpack运行流程详解" class="headerlink" title="webpack运行流程详解"></a>webpack运行流程详解</h2><p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/webpackJizhi.PNG" alt="markdown"></p>
<ol>
<li>首先读取webpack的入口文件</li>
</ol>
<p>webpack会读取你在命令行传入的配置以及项目里的 webpack.config.js 文件，初始化本次构建的配置参数，并且执行配置文件中的插件实例化语句，webpack 的入口文件其实就实例了Compiler并调用了run方法开启了编译，webpack的编译都按照下面的钩子调用顺序执行</p>
<ul>
<li>before-run 清除缓存</li>
<li>run 注册缓存数据钩子</li>
<li>before-compile</li>
<li>compile 开始编译</li>
<li>make 从入口分析依赖以及间接依赖模块，创建模块对象</li>
<li>build-module 模块构建</li>
<li>seal 构建结果封装， 不可再更改</li>
<li>after-compile 完成构建，缓存数据</li>
<li>emit 输出到dist目录</li>
</ul>
<ol start="2">
<li><p>接下来到了entryOption(入口选项)阶段，webpack开始读取配置的Entries，递归遍历所有的入口文件</p>
</li>
<li><p>编译&amp;构建流程</p>
</li>
</ol>
<p>Webpack接下来就开始了compilation过程</p>
<p>会依次进入其中每一个入口文件(entry)，先使用用户配置好的loader对文件内容进行编译，我们可以从传入事件回调的compilation上拿到module的resource（资源路径）、loaders（经过的loaders）等信息；</p>
<p>之后，再将编译好的文件内容使用acorn解析生成AST静态语法树（normalModuleLoader），分析文件的依赖关系逐个拉取依赖模块并重复上述过程，最后将所有模块中的require语法替换成__webpack_require__来模拟模块化操作</p>
<ol start="4">
<li>emit阶段，所有文件的编译及转化都已经完成，包含了最终输出的资源，我们可以在传入事件回调的compilation.assets 上拿到所需数据，其中包括即将输出的资源、代码块Chunk等等信息，将文件输出到指定的path</li>
</ol>
<p><strong>什么是AST？</strong></p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/AST.png" alt="markdown"></p>
<p>抽象语法树，简称语法树，是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p>
<p>转换成AST的目的就是将我们书写的字符串文件转换成计算机更容易识别的数据结构，这样更容易提取其中的关键信息，而这棵树在计算机上的表现形式，其实就是一个单纯的Object。</p>
<h2 id="介绍好用的loader和plugin"><a href="#介绍好用的loader和plugin" class="headerlink" title="介绍好用的loader和plugin"></a>介绍好用的loader和plugin</h2><ul>
<li>postcss-loader：可以给一些样式（如css3中的transform）加前缀，提高兼容性</li>
<li>file-loader: 生成的文件名就是文件内容的MD5哈希值并会保留所引用资源的原始扩展名</li>
<li>url-loader：可以将图片打包成为base64的形式放在JS文件中，但是不适合大图片的打包，会导致整个js文件很庞大，可以使用limit配置项来设置对应需要打包图片的大小</li>
<li>babel-loader： 让下一代的js文件转换成现代浏览器能够支持的JS文件。babel有些复杂，所以大多数都会新建一个.babelrc进行配置</li>
<li>css-loader,style-loader:两个建议配合使用，用来解析css文件，能够解释@import,url()如果需要解析less就在后面加一个less-loader</li>
<li>px2rem-loader：转换px和rem单位</li>
<li>htmlWebpackPlugin：会在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中，可以配置html文件的模板</li>
<li>cleanWebpackPlugin（第三方）：打包之后可以把先前打包的文件删除</li>
</ul>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h2><p>纵观webpack构建流程，我们可以发现整个构建过程主要花费时间的部分也就是递归遍历各个entry然后寻找依赖逐个编译的过程，每次递归都需要经历 String-&gt;AST-&gt;String 的流程，经过loader还需要处理一些字符串或者执行一些JS脚本，由于JS单线程的缘故，webpack构建慢一直成为它饱受诟病的原因。</p>
<h1 id="webpack打包优化"><a href="#webpack打包优化" class="headerlink" title="webpack打包优化"></a>webpack打包优化</h1><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低<br>Webpack在启动后会根据Entry配置的入口出发，递归地解析所依赖的文件。这个过程分为搜索文件和把匹配的文件进行分析、转化的两个过程，因此可以从这两个角度来进行优化配置</p>
<h2 id="devServer提高开发效率"><a href="#devServer提高开发效率" class="headerlink" title="devServer提高开发效率"></a>devServer提高开发效率</h2><ul>
<li>在package.json中配置命令 “webpack –watch” 可以监听到打包文件的变化，实现自动打包</li>
<li>在package.json中配置命令 “webpack-dev-server” ,再去webpack.config.js配置devServer，可以实现开启服务器打开页面（如果在本地打开文件则无法发送AJAX请求），设置open选项为true则会自动打开浏览器</li>
</ul>
<h2 id="优化构建速度"><a href="#优化构建速度" class="headerlink" title="优化构建速度"></a>优化构建速度</h2><h3 id="缩小文件的搜索范围"><a href="#缩小文件的搜索范围" class="headerlink" title="缩小文件的搜索范围"></a>缩小文件的搜索范围</h3><ol>
<li>resolve字段告诉webpack怎么去搜索文件，所以首先要重视resolve字段的配置</li>
</ol>
<ul>
<li><p>设置resolve.modules:[path.resolve(__dirname, ‘node_modules’)]避免层层查找<br>resolve.modules告诉webpack去哪些目录下寻找第三方模块，默认值为[‘node_modules’]，会依次查找./node_modules、../node_modules、../../node_modules</p>
</li>
<li><p>设置resolve.mainFields:[‘main’]，设置尽量少的值可以减少入口文件的搜索步骤</p>
</li>
</ul>
<p>第三方模块为了适应不同的使用环境，会定义多个入口文件，mainFields定义使用第三方模块的哪个入口文件，由于大多数第三方模块都使用main字段描述入口文件的位置，所以可以设置单独一个main值，减少搜索</p>
<ul>
<li>对庞大的第三方模块设置resolve.alias, 使webpack直接使用库的min文件，避免库内解析</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如对于react：</span></span><br><span class="line">    resolve.alias:&#123;</span><br><span class="line">        <span class="string">&#x27;react&#x27;</span>:patch.resolve(__dirname, <span class="string">&#x27;./node_modules/react/dist/react.min.js&#x27;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样会影响Tree-Shaking，适合对整体性比较强的库使用，如果是像lodash这类工具类的比较分散的库，比较适合Tree-Shaking，避免使用这种方式</p>
<ul>
<li>合理配置resolve.extensions，减少文件查找</li>
</ul>
<p>默认值：extensions:[‘.js’, ‘.json’],当导入语句没带文件后缀时，Webpack会根据extensions定义的后缀列表进行文件查找，所以：</p>
<p>a.列表值尽量少<br>b.频率高的文件类型的后缀写在前面<br>c.源码中的导入语句尽可能的写上文件后缀，如require(./data)要写成require(./data.json)</p>
<ol start="2">
<li>module.noParse字段告诉Webpack不必解析哪些文件，可以用来排除对非模块化库文件的解析</li>
</ol>
<p>如jQuery、ChartJS，另外如果使用resolve.alias配置了react.min.js，则也应该排除解析，因为react.min.js经过构建，已经是可以直接运行在浏览器的、非模块化的文件了。noParse值可以是RegExp、[RegExp]、function</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123; <span class="attr">noParse</span>:[<span class="regexp">/jquery|chartjs/</span>, <span class="regexp">/react\.min\.js$/</span>] &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置loader时，通过test、exclude、include缩小搜索范围</li>
</ol>
<h3 id="使用DllPlugin减少基础模块编译次数"><a href="#使用DllPlugin减少基础模块编译次数" class="headerlink" title="使用DllPlugin减少基础模块编译次数"></a>使用DllPlugin减少基础模块编译次数</h3><p>DllPlugin动态链接库插件，其原理是把网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取。<strong>为什么会提升构建速度呢？</strong>原因在于dll中大多包含的是常用的第三方模块，如react、react-dom，所以只要这些模块版本不升级，就只需被编译一次。这样做和配置resolve.alias和module.noParse的效果有异曲同工的效果</p>
<h3 id="使用HappyPack开启多进程Loader转换"><a href="#使用HappyPack开启多进程Loader转换" class="headerlink" title="使用HappyPack开启多进程Loader转换"></a>使用HappyPack开启多进程Loader转换</h3><p>在整个构建流程中，最耗时的就是Loader对文件的转换操作了，而运行在Node.js之上的Webpack是单线程模型的，也就是只能一个一个文件进行处理，不能并行处理。HappyPack可以将任务分解给多个子进程，多个子进程去并发的执行，最后将结果发给主进程。JS是单线程模型，只能通过这种多进程的方式提高性能</p>
<h3 id="使用ParallelUglifyPlugin开启多进程压缩JS文件"><a href="#使用ParallelUglifyPlugin开启多进程压缩JS文件" class="headerlink" title="使用ParallelUglifyPlugin开启多进程压缩JS文件"></a>使用ParallelUglifyPlugin开启多进程压缩JS文件</h3><p>使用UglifyJS插件压缩JS代码时，需要先将代码解析成Object表示的AST（抽象语法树），再去应用各种规则去分析和处理AST，所以这个过程计算量大耗时较多。ParallelUglifyPlugin可以开启多个子进程，每个子进程使用UglifyJS压缩代码，可以并行执行，能显著缩短压缩时间</p>
<p>在 Webpack4 中，我们就不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 console.log 这类代码的功能</p>
<h2 id="优化输出质量-压缩文件体积"><a href="#优化输出质量-压缩文件体积" class="headerlink" title="优化输出质量-压缩文件体积"></a>优化输出质量-压缩文件体积</h2><h3 id="区分环境–减小生产环境代码体积"><a href="#区分环境–减小生产环境代码体积" class="headerlink" title="区分环境–减小生产环境代码体积"></a>区分环境–减小生产环境代码体积</h3><p>代码运行环境分为开发环境和生产环境，代码需要根据不同环境做不同的操作，许多第三方库中也有大量的根据开发环境判断的if else代码，构建也需要根据不同环境输出不同的代码，所以需要一套机制可以在源码中区分环境，区分环境之后可以使输出的生产环境的代码体积减小。Webpack中使用DefinePlugin插件来定义配置文件适用的环境</p>
<h3 id="压缩代码-JS、ES、CSS"><a href="#压缩代码-JS、ES、CSS" class="headerlink" title="压缩代码-JS、ES、CSS"></a>压缩代码-JS、ES、CSS</h3><ol>
<li>Webpack内置UglifyJS插件、ParallelUglifyPlugin</li>
</ol>
<p>会分析JS代码语法树，理解代码的含义，从而做到去掉无效代码、去掉日志输入代码、缩短变量名等优化。</p>
<ol start="2">
<li><p>压缩ES6：第三方UglifyJS插件<br>随着越来越多的浏览器支持直接执行ES6代码，应尽可能的运行原生ES6，这样比起转换后的ES5代码，代码量更少，且ES6代码性能更好。直接运行ES6代码时，也需要代码压缩，第三方的uglify-webpack-plugin提供了压缩ES6代码的功能</p>
</li>
<li><p>压缩CSS：css-loader?minimize、PurifyCSSPlugin</p>
</li>
</ol>
<p>cssnano基于PostCSS，不仅是删掉空格，还能理解代码含义，例如把color:#ff0000 转换成 color:red，css-loader内置了cssnano，只需要使用 css-loader?minimize 就可以开启cssnano压缩</p>
<p>另外一种压缩CSS的方式是使用PurifyCSSPlugin，需要配合 extract-text-webpack-plugin 使用，它主要的作用是可以去除没有用到的CSS代码，类似JS的Tree Shaking</p>
<h3 id="使用Tree-Shaking剔除JS死代码"><a href="#使用Tree-Shaking剔除JS死代码" class="headerlink" title="使用Tree Shaking剔除JS死代码"></a>使用Tree Shaking剔除JS死代码</h3><p>Tree Shaking可以剔除用不上的死代码，<strong>它依赖ES6的import、export的模块化语法，最先在Rollup中出现，</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// test.js </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">2</span> <span class="comment">// index.js </span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./test.js&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="优化输出质量–加速网络请求"><a href="#优化输出质量–加速网络请求" class="headerlink" title="优化输出质量–加速网络请求"></a>优化输出质量–加速网络请求</h2><h3 id="使用CDN加速静态资源加载"><a href="#使用CDN加速静态资源加载" class="headerlink" title="使用CDN加速静态资源加载"></a>使用CDN加速静态资源加载</h3><p>CDN又称为内容分发网络，使内容传输的更快，更稳定。<br>也就是说，<strong>把静态资源文件和动态网页分集群部署</strong>，静态资源会被部署到CDN节点上，网页中引用的资源也会变成对应的部署路径。</p>
<p>由于CDN会为资源开启长时间的缓存，例如用户从CDN上获取了index.html，即使之后替换了CDN上的index.html，用户那边仍会在使用之前的版本直到缓存时间过期。业界做法：</p>
<ul>
<li>HTML文件：放在自己的服务器上且关闭缓存，不接入CDN</li>
<li>静态的JS、CSS、图片等资源：开启CDN和缓存，同时文件名带上由内容计算出的Hash值，这样只要内容变化hash就会变化，文件名就会变化，就会被重新下载而不论缓存时间多长。</li>
</ul>
<p>另外，HTTP1.x版本的协议下，浏览器会对于向同一域名并行发起的请求数限制在4~8个。那么把所有静态资源放在同一域名下的CDN服务上就会遇到这种限制，所以可以把他们分散放在不同的CDN服务上，例如JS文件放在js.cdn.com下，将CSS文件放在css.cdn.com下等。这样又会带来一个新的问题：增加了域名解析时间，这个可以通过dns-prefetch来解决 <code>&lt;link rel=&#39;dns-prefetch&#39; href=&#39;//js.cdn.com&#39;&gt;</code> 来缩减域名解析的时间。形如**//xx.com 这样的URL省略了协议**，这样做的好处是，浏览器在访问资源时会自动根据当前URL采用的模式来决定使用HTTP还是HTTPS协议。</p>
<h3 id="多页面应用提取页面间公共代码，以利用缓存"><a href="#多页面应用提取页面间公共代码，以利用缓存" class="headerlink" title="多页面应用提取页面间公共代码，以利用缓存"></a>多页面应用提取页面间公共代码，以利用缓存</h3><p>大型网站通常由多个页面组成，每个页面都是一个独立的单页应用，多个页面间肯定会依赖同样的样式文件、技术栈等。如果不把这些公共文件提取出来，那么每个单页打包出来的chunk中都会包含公共代码，相当于要传输n份重复代码。如果把公共文件提取出一个文件，那么当用户访问了一个网页，加载了这个公共文件，再访问其他依赖公共文件的网页时，就直接使用文件在浏览器的缓存，这样公共文件就只用被传输一次</p>
<h3 id="分割代码以按需加载"><a href="#分割代码以按需加载" class="headerlink" title="分割代码以按需加载"></a>分割代码以按需加载</h3><ul>
<li>将网站功能按照相关程度划分成几类</li>
<li>每一类合并成一个Chunk，按需加载对应的Chunk</li>
<li>例如，只把首屏相关的功能放入执行入口所在的Chunk，这样首次加载少量的代码，其他代码要用到的时候再去加载。最好提前预估用户接下来的操作，提前加载对应代码，让用户感知不到网络加载</li>
</ul>
<h2 id="优化的plugin"><a href="#优化的plugin" class="headerlink" title="优化的plugin"></a>优化的plugin</h2><p><strong>构建优化</strong></p>
<ul>
<li>减少编译体积 ContextReplacementPugin 、 IgnorePlugin 、 babel-pluginimport 、 babel-plugin-transform-runtime</li>
<li>并⾏编译 happypack 、 thread-loader 、 uglifyjsWebpackPlugin 开启并⾏ </li>
<li>缓存 cache-loader 、 hard-source-webpack-plugin 、 uglifyjsWebpackPlugin 开 启缓存、 babel-loader 开启缓存 </li>
<li>预编译 dllWebpackPlugin &amp;&amp; DllReferencePlugin 、 auto-dll-webapck-plugin</li>
</ul>
<p><strong>性能优化</strong></p>
<ul>
<li>减少编译体积 Tree-shaking 、 Scope Hositing hash </li>
<li>缓存 webpack-md5-plugin </li>
<li>拆包 splitChunksPlugin 、 import() 、 require.ensure</li>
</ul>
<h1 id="webpack-实现热更新的原理"><a href="#webpack-实现热更新的原理" class="headerlink" title="webpack 实现热更新的原理"></a>webpack 实现热更新的原理</h1><p>Webpack 热更新（ Hot Module Replacement，简称 HMR，后续均以 HMR 替代），无需完全刷新整个页面的同时，更新所有类型的模块。</p>
<ol>
<li><p>Webpack编译期，为需要热更新的 entry 注入热更新代码(EventSource通信，核心是Webpack-hot-middleware 插件的作用，就是提供浏览器和 Webpack 服务器之间的通信机制、且在浏览器端接收 Webpack 服务器端的更新变化。)</p>
</li>
<li><p>页面首次打开后，服务端与客户端通过 EventSource 建立通信渠道，把下一次的 hash 返回客户端</p>
</li>
<li><p>客户端获取到hash，这个hash将作为下一次请求服务端 hot-update.js 和 hot-update.json的hash</p>
</li>
<li><p>修改页面代码后，Webpack 的Complier 类会调用 Watch 方法监听文件变更，当监听到文件修改后，开始编译，编译完成后，发送 build 消息给客户端</p>
</li>
<li><p>客户端获取到hash，成功后客户端构造hot-update.js script链接，然后插入主文档</p>
</li>
<li><p>hot-update.js 插入成功后，执行hotAPI 的 createRecord 和 reload方法，获取到 Vue 组件的 render方法，重新 render 组件， 继而实现 UI 无刷新更新。</p>
</li>
</ol>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5aa3d2056fb9a028c36868aa#heading-7">webpack详解</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5badd0c5e51d450e4437f07a#heading-7">Webpack揭秘——走向高阶前端的必经之路</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5b652b036fb9a04fa01d616b">三十分钟掌握Webpack性能优化</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5b4609f5e51d4519596b66a7">手写一个webpack4.0配置</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/29/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/Promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/29/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/Promise/" class="post-title-link" itemprop="url">Promise</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-29 10:12:25" itemprop="dateCreated datePublished" datetime="2019-04-29T10:12:25+08:00">2019-04-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Ajax/" itemprop="url" rel="index"><span itemprop="name">Ajax</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="promise对象"><a href="#promise对象" class="headerlink" title="promise对象"></a>promise对象</h1><p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/promise.png" alt="markdown"></p>
<p>概念：Promise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合合理、强大。所谓Promise，简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说<strong>Promise是一个对象，从它可以获取异步操作的消息</strong>。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。将异步操作以同步操作的流程表达出来，<strong>避免了层层嵌套的回调函数</strong>，解决了JQuery的回调地狱问题。</p>
<p>它有三种状态，分别是<strong>pending-进行中、resolved-已完成、rejected-已失败。</strong><br>另外， fulfilled 与 rejected ⼀起合称 settled。</p>
<p>可以把 Promise 看成一个状态机。初始是 pending 状态，可以通过函数 resolve 和reject，将状态转变为 resolved 或者 rejected 状态，状态一旦改变就不能再次变化<br>then 函数会返回一个 Promise 实例，并且该返回值是一个<strong>新的实例</strong>而不是之前的实例。因为Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 then调用就失去意义了</p>
<p>但是Promise也存在以下缺点：</p>
<ul>
<li>Promise一旦创建就会立即执行，无法中途取消</li>
<li>当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</li>
<li>如果不设置回调函数，Promise内部抛出的错误不会反应到外部</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> success = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(</span><br><span class="line">    (data) =&gt; &#123; <span class="built_in">console</span>.log(data)&#125;,</span><br><span class="line">    (data) =&gt; &#123; <span class="built_in">console</span>.log(data)&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>分析<strong>promise的执行过程</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> success = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            resolve(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">2000</span>);</span><br><span class="line">&#125;).then(</span><br><span class="line">    (data) =&gt; &#123; <span class="built_in">console</span>.log(data)&#125;,</span><br><span class="line">    (data) =&gt; &#123; <span class="built_in">console</span>.log(data)&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise);	<span class="comment">//&lt;pending&gt; 进行中</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(promise);	<span class="comment">//&lt;resolved&gt; 已完成</span></span><br><span class="line">&#125;,<span class="number">2500</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//1  </span></span><br><span class="line"><span class="comment">//Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//成功</span></span><br><span class="line"><span class="comment">//Promise &#123;&lt;resolved&gt;: undefined&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="promise原理"><a href="#promise原理" class="headerlink" title="promise原理"></a>promise原理</h1><p>promise就是三个状态。利用观察者模式的编程思想,通过特定书写方式注册对应状态的事件处理函数，然后更新状态，调用注册过的处理函数即可。<br>这个特定方式就是then，done，fail，always…等方法，更新状态就是resolve、reject方法。 </p>
<p>Promise的实现过程，通过Promise.prototype.then和Promise.prototype.catch方法将观察者方法注册到被观察者Promise对象中，同时返回一个新的Promise对象，以便可以链式调用。</p>
<p>被观察者管理内部pending、fulfilled和rejected的状态转变，同时通过构造函数中传递的resolve和reject方法以主动触发状态转变和通知观察者。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise类实现原理</span></span><br><span class="line"><span class="comment"> * 构造函数传入一个function，有两个参数，resolve：成功回调; reject：失败回调</span></span><br><span class="line"><span class="comment"> * state: 状态存储 [PENDING-进行中 RESOLVED-成功 REJECTED-失败]</span></span><br><span class="line"><span class="comment"> * doneList: 成功处理函数列表</span></span><br><span class="line"><span class="comment"> * failList: 失败处理函数列表</span></span><br><span class="line"><span class="comment"> * done: 注册成功处理函数</span></span><br><span class="line"><span class="comment"> * fail: 注册失败处理函数</span></span><br><span class="line"><span class="comment"> * then: 同时注册成功和失败处理函数</span></span><br><span class="line"><span class="comment"> * always: 一个处理函数注册到成功和失败</span></span><br><span class="line"><span class="comment"> * resolve: 更新state为：RESOLVED，并且执行成功处理队列</span></span><br><span class="line"><span class="comment"> * reject: 更新state为：REJECTED，并且执行失败处理队列</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PromiseNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&#x27;PENDING&#x27;</span>;</span><br><span class="line">        <span class="built_in">this</span>.doneList = [];</span><br><span class="line">        <span class="built_in">this</span>.failList = [];</span><br><span class="line">        fn(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册成功处理函数</span></span><br><span class="line">    <span class="function"><span class="title">done</span>(<span class="params">handle</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> handle === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.doneList.push(handle);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;缺少回调函数&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册失败处理函数</span></span><br><span class="line">    <span class="function"><span class="title">fail</span>(<span class="params">handle</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> handle === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.failList.push(handle);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;缺少回调函数&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同时注册成功和失败处理函数</span></span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">success, fail</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.done(success || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;).fail(fail || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个处理函数注册到成功和失败</span></span><br><span class="line">    <span class="function"><span class="title">always</span>(<span class="params">handle</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.done(handle || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;).fail(handle || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新state为：RESOLVED，并且执行成功处理队列</span></span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&#x27;RESOLVED&#x27;</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.doneList.forEach(<span class="function">(<span class="params">item, key, arr</span>) =&gt;</span> &#123;</span><br><span class="line">            item.apply(<span class="literal">null</span>, args);</span><br><span class="line">            arr.shift();</span><br><span class="line">        &#125;);</span><br><span class="line">        &#125;.bind(<span class="built_in">this</span>), <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新state为：REJECTED，并且执行失败处理队列</span></span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&#x27;REJECTED&#x27;</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>); <span class="comment">//arrayObject.slice(start,end)slice() 方法可从已有的数组中返回选定的元素。</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.failList.forEach(<span class="function">(<span class="params">item, key, arr</span>) =&gt;</span> &#123;</span><br><span class="line">            item.apply(<span class="literal">null</span>, args);</span><br><span class="line">            arr.shift(); <span class="comment">// shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。</span></span><br><span class="line">        &#125;);</span><br><span class="line">        &#125;.bind(<span class="built_in">this</span>), <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面一波骚操作</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">    <span class="comment">// reject(&#x27;you are err&#x27;);</span></span><br><span class="line">    &#125;).done(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;).fail(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="promise常用API"><a href="#promise常用API" class="headerlink" title="promise常用API"></a>promise常用API</h1><ol>
<li>Promise.resolve(value)</li>
</ol>
<p>类方法，该方法返回一个以 value 值解析后的 Promise 对象</p>
<ul>
<li>如果这个值是个 thenable（即带有 then 方法），返回的 Promise 对象会“跟随”这个 thenable 的对象，采用它的最终状态（指 resolved/rejected/pending/settled）</li>
<li>如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回</li>
<li>其他情况以该值为成功状态返回一个 Promise 对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="number">123</span>);</span><br><span class="line">    &#125;,<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p0 = <span class="keyword">new</span> <span class="built_in">Promise</span>(fn);</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(p0);</span><br><span class="line"><span class="comment">// 返回为true，返回的 Promise 即是 入参的 Promise 对象。</span></span><br><span class="line"><span class="built_in">console</span>.log(p0 === p1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Promise.reject</li>
</ol>
<p>类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected</p>
<ol start="3">
<li>Promise.prototype.then</li>
</ol>
<p>实例方法，为 Promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的then 回调接收</p>
<ol start="4">
<li>Promise.prototype.catch</li>
</ol>
<p>实例方法，捕获异常，函数形式：fn(err){}, err 是 catch 注册 之前的回调抛出的异常信息。</p>
<ol start="5">
<li>Promise.race</li>
</ol>
<p>类方法，多个 Promise 任务同时执行，返回最先执行结束的 Promise 任务的结果，不管这个 Promise 结果是成功还是失败</p>
<ol start="6">
<li>Promise.all</li>
</ol>
<p>类方法，多个 Promise 任务同时执行。<br>如果全部成功执行，则以数组的方式返回所有 Promise 任务的执行结果。 如果有一个 Promise 任务 rejected，则只返回 rejected 任务的结果</p>
<h1 id="promise的基本使用"><a href="#promise的基本使用" class="headerlink" title="promise的基本使用"></a>promise的基本使用</h1><p>有以下场景，需要有3个异步操作，分别是buy、cook和send，三个步骤都是需要消耗时间的，可以理解为三个异步任务,有另外一个同步任务就是call</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buy</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line"> resolve()</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;买菜&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cook</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line"> resolve()</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;做饭&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line"> resolve()</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;送饭&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;通知完成&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(buy)</span><br><span class="line">.then(<span class="function">(<span class="params">结果<span class="number">1</span></span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(cook)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">结果<span class="number">2</span></span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(send)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">结果<span class="number">3</span></span>)=&gt;</span>&#123;</span><br><span class="line">    call()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果我们的后续任务是异步任务的话，必须return 一个 新的 promise 对象<br>如果后续任务是同步任务，只需 return 一个结果即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面例子改写为</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> success = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span>(success)&#123;</span><br><span class="line">      resolve()</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;买菜&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      reject()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  promise</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;做饭&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;送饭&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;完成&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h1><p>谈及异步回调函数的嵌套，总会让人感到烦躁，特别是当业务逻辑复杂，往往需要调用几次 ajax 才能拿到所有需要的数据。</p>
<p>从最早的回调函数，到 Promise 对象，再到 Generator 函数，每次都有所改进，但又让人觉得不彻底。它们都有额外的复杂性，都需要理解抽象的底层运行机制。所以，我们需要一种方法，更优雅地解决异步操作。于是，async函数出现了。</p>
<p>一句话解释：async 函数，就是 Generator 函数的语法糖。</p>
<p>async函数具有以下特点：</p>
<ul>
<li>建立在promise之上。所以，不能把它和回调函数搭配使用。但它会声明一个异步函数，并隐式地返回一个Promise。因此可以直接return变量，无需使用Promise.resolve进行转换。</li>
<li>和promise一样，是非阻塞的。但不用写 then 及其回调函数，这减少代码行数，也避免了代码嵌套。而且，所有异步调用，可以写在同一个代码块中，无需定义多余的中间变量。</li>
<li>它的最大价值在于，可以使异步代码，在形式上，更接近于同步代码。<br>它总是与await一起使用的。并且，await 只能在 async 函数体内。</li>
<li>await 是个运算符，用于组成表达式，它会阻塞后面的代码。如果等到的是 Promise 对象，则得到其 resolve值。否则，会得到一个表达式的运算结果。</li>
</ul>
<h2 id="async函数的优点"><a href="#async函数的优点" class="headerlink" title="async函数的优点"></a>async函数的优点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Promise方法实现三个步骤的处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(<span class="function"><span class="params">time2</span> =&gt;</span> step2(time2))</span><br><span class="line">        .then(<span class="function"><span class="params">time3</span> =&gt;</span> step3(time3))</span><br><span class="line">        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br><span class="line"><span class="comment">// step1 with 300</span></span><br><span class="line"><span class="comment">// step2 with 500</span></span><br><span class="line"><span class="comment">// step3 with 700</span></span><br><span class="line"><span class="comment">// result is 900</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用async处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time2);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> step3(time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure>

<p>async相比promise优点：</p>
<ol>
<li>使用Async/Await明显节约了不少代码。</li>
</ol>
<p>我们不需要写.then，不需要写匿名函数处理Promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码。这些小的优点会迅速累计起来，这在之后的代码示例中会更加明显。</p>
<ol start="2">
<li>相比于 Promise 更易于调试。</li>
</ol>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/async1.png" alt="markdown"><br>因为没有代码块，所以不能在一个返回的箭头函数中设置断点。如果你在一个 .then 代码块中使用调试器的步进(step-over)功能，调试器并不会进入后续的 .then 代码块，因为调试器只能跟踪同步代码的每一步。</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/async2.png" alt="markdown"><br>现在，如果使用 async/await，你就不必再使用箭头函数。你可以对 await 语句执行步进操作，就好像他们都是普通的同步语句一样。</p>
<ol start="3">
<li>更好的中间值处理</li>
</ol>
<p>你很可能遇到过这样的场景，调用promise1，使用promise1返回的结果去调用promise2，然后使用两者的结果去调用promise3。你的代码很可能是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> makeRequest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> promise1().then(<span class="function"><span class="params">value1</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2(value1).then(<span class="function"><span class="params">value2</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> promise3(value1, value2)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果promise3不需要value1，可以很简单地将promise嵌套铺平。如果你忍受不了嵌套，你可以将value 1 &amp; 2 放进Promise.all来避免深层嵌套：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> makeRequest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> promise1().then(<span class="function"><span class="params">value1</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.all([value1, promise2(value1)])</span><br><span class="line">        &#125;).then(<span class="function">(<span class="params">[value1, value2]</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> promise3(value1, value2)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种方法为了可读性牺牲了语义。除了避免嵌套，并没有其他理由将value1和value2放在一个数组中。</p>
<p>使用async/await的话，代码会变得异常简单和直观。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> makeRequest = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> value1 = <span class="keyword">await</span> promise1()</span><br><span class="line">    <span class="keyword">const</span> value2 = <span class="keyword">await</span> promise2(value1)</span><br><span class="line">    <span class="keyword">return</span> promise3(value1, value2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是缺点在于滥⽤ await 可能会导致性能问 题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然 需要等待前者完成，导致代码失去了并发性。</p>
<h1 id="async的基本使用"><a href="#async的基本使用" class="headerlink" title="async的基本使用"></a>async的基本使用</h1><p>基本使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span>&#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(resolve,ms)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">value,ms</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">await</span> timeout(ms)</span><br><span class="line">	<span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;hello&#x27;</span>,<span class="number">1000</span>)</span><br><span class="line">print(<span class="string">&#x27;world&#x27;</span>,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>实现链式调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">		    resolve ()</span><br><span class="line">		&#125;,<span class="built_in">Math</span>.random()*<span class="number">3000</span>);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fg</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> delay().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(name)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f1 = fg(<span class="string">&#x27;f1&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> f2 = fg(<span class="string">&#x27;f2&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> f3 = fg(<span class="string">&#x27;f3&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> f4 = fg(<span class="string">&#x27;f4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">await</span> f1()</span><br><span class="line">	<span class="keyword">await</span> f2()</span><br><span class="line">	<span class="keyword">await</span> f3()</span><br><span class="line">	<span class="keyword">await</span> f4()</span><br><span class="line">&#125;</span><br><span class="line">print()</span><br></pre></td></tr></table></figure>

<h1 id="用Promise对象实现的-Ajax"><a href="#用Promise对象实现的-Ajax" class="headerlink" title="用Promise对象实现的 Ajax"></a>用Promise对象实现的 Ajax</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    xhr.open(<span class="string">&quot;GET&quot;</span>, url)</span><br><span class="line">    xhr.onreadystatechange = handler</span><br><span class="line">    xhr.responseType = <span class="string">&quot;json&quot;</span></span><br><span class="line">    xhr.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    xhr.send()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="built_in">this</span>.response)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">&quot;/posts.json&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Contents: &#x27;</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;出错了&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Promise结合定时器实现动画效果"><a href="#Promise结合定时器实现动画效果" class="headerlink" title="Promise结合定时器实现动画效果"></a>Promise结合定时器实现动画效果</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   .aaa&#123;</span><br><span class="line">       background: red;</span><br><span class="line">       height: 100px;</span><br><span class="line">       width: 100px;</span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aaa&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="comment">// 写法一：</span></span></span><br><span class="line"><span class="javascript">       <span class="keyword">var</span> changeColor = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;aaa&#x27;</span>)</span></span><br><span class="line"><span class="javascript">	<span class="keyword">const</span> change = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">		resolve(<span class="string">&quot;312312&quot;</span>)</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	change</span><br><span class="line"><span class="javascript">       .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">			changeColor[<span class="number">0</span>].setAttribute(<span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;background: yellow !important;height:200px;&#x27;</span>);</span></span><br><span class="line">		&#125;,1000)</span><br><span class="line">	&#125;)</span><br><span class="line"><span class="javascript">	.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">			changeColor[<span class="number">0</span>].setAttribute(<span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;background: black;height:200px;&#x27;</span>);</span></span><br><span class="line">		&#125;,1000)</span><br><span class="line">	&#125;)</span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/juse__we/article/details/88900685">Promise原理和问题集锦</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/26/vue/Vuex%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/26/vue/Vuex%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Vuex的基本使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-26 14:53:20" itemprop="dateCreated datePublished" datetime="2019-04-26T14:53:20+08:00">2019-04-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-14 23:01:55" itemprop="dateModified" datetime="2021-04-14T23:01:55+08:00">2021-04-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Vuex的基本使用。"><a href="#Vuex的基本使用。" class="headerlink" title="Vuex的基本使用。"></a>Vuex的基本使用。</h1><p>问题的引入：在Vue中，涉及到父子组件之间的传值，我们可以使用 <strong>props</strong> 和 <strong>emit</strong>方法进行传值，但是兄弟组件之间传值要怎么办呢？所以这个时候就要引入Vuex进行状态管理了，Vuex 是适用于Vue.js应用的状态管理库，为 Vue.js为应用中的所有组件提供集中式的状态存储与操作，保证了所有状态以可预测的方式进行修改。 </p>
<h2 id="主要的几种状态"><a href="#主要的几种状态" class="headerlink" title="主要的几种状态"></a>主要的几种状态</h2><ul>
<li><p>dispatch：操作行为触发方法，是唯一能执行action的方法。</p>
</li>
<li><p>actions：操作行为处理模块。负责处理 Vue Components 接收到的所有<strong>交互行为</strong>。包含<strong>同步/异步</strong>操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</p>
</li>
<li><p>commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</p>
</li>
<li><p>mutations：状态改变操作方法。是<strong>Vuex修改state的唯一推荐方法</strong>，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</p>
</li>
<li><p>state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。 </p>
</li>
<li><p>getters：state对象读取方法。直接通过这个获取数据</p>
</li>
</ul>
<p>第一步：在main.js中安装（如果项目大的话，需要全局共享处理的数据比较多，则最好对应的每个状态都建立一个js文件，至少不会把所有的代码糅合在一起，看着舒服一点。。）</p>
<p>第二步：导入 vuex</p>
<p>第三步：注册 vuex 到 vue 中。</p>
<p>第四步：新建一个 store 实例，然后可以在这个 state 里面写对应的状态方法。</p>
<p>第五步：<strong>将vuex创建的store挂载到vm实例上，才能全局都访问到这个store数据</strong>。（敲黑板划重点，第一次忘记挂载结果找了好久的错误）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口文件</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 配置vuex的步骤</span></span><br><span class="line"><span class="comment">// 1. 运行 cnpm i vuex -S </span></span><br><span class="line"><span class="comment">// 2. 导入包</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">// 3. 注册vuex到vue中</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="comment">// 4. new Vuex.Store() 实例，得到一个 数据仓储对象</span></span><br><span class="line"><span class="keyword">var</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    <span class="comment">// 大家可以把 state 想象成 组件中的 data ,专门用来存储数据的</span></span><br><span class="line">    <span class="comment">// 如果在 组件中，想要访问，store 中的数据，只能通过 this.$store.state.*** 来访问</span></span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 注意： 如果要操作 store 中的 state 值，只能通过 调用 mutations 提供的方法，才能操作对应的数据，不推荐直接操作 state 中的数据，因为 万一导致了数据的紊乱，不能快速定位到错误的原因，因为，每个组件都可能有操作数据的方法；</span></span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 注意： 如果组件想要调用 mutations 中的方法，只能使用 this.$store.commit(&#x27;方法名&#x27;)</span></span><br><span class="line">    <span class="comment">// 这种 调用 mutations 方法的格式，和 this.$emit(&#x27;父组件中方法名&#x27;)</span></span><br><span class="line">    <span class="function"><span class="title">subtract</span>(<span class="params">state, obj</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 注意： mutations 的 函数参数列表中，最多支持两个参数，其中，参数1： 是 state 状态； 参数2： 通过 commit 提交过来的参数；</span></span><br><span class="line">      <span class="built_in">console</span>.log(obj)</span><br><span class="line">      state.count -= (obj.c + obj.d)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="comment">// 注意：这里的 getters， 只负责 对外提供数据，不负责 修改数据，如果想要修改 state 中的数据，请 去找 mutations</span></span><br><span class="line">    optCount: <span class="function"><span class="keyword">function</span> (<span class="params">state</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;当前最新的count值是：&#x27;</span> + state.count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 经过对比，发现 getters 中的方法， 和组件中的过滤器比较类似，因为 过滤器和 getters 都没有修改原数据， 都是把原数据做了一层包装，提供给了 调用者；</span></span><br><span class="line">    <span class="comment">// 其次， getters 也和 computed 比较像， 只要 state 中的数据发生变化了，那么，如果 getters 正好也引用了这个数据，那么 就会立即触发 getters 的重新求值；</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  render: <span class="function"><span class="params">c</span> =&gt;</span> c(App),</span><br><span class="line">  store <span class="comment">// 5. 将 vuex 创建的 store 挂载到 VM 实例上， 只要挂载到了 vm 上，任何组件都能使用 store 来存取数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>state中的数据，不能直接修改，如果想要修改，必须通过 mutations</li>
<li>如果组件想要直接 从 state 上获取数据： 需要 this.$store.state.</li>
<li>如果组件，想要修改数据，必须使用 mutations 提供的方法，需要通过 this.$store.commit(‘方法的称’， 唯一的一个参数)</li>
<li>如果 store 中 state 上的数据， 在对外提供的时候，需要做一层包装，那么 ，推荐使用 getters, 如果需要使用 getters ,则用 this.$store.getters.</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/24/css/CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/24/css/CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/" class="post-title-link" itemprop="url">CSS预处理器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-24 14:19:35" itemprop="dateCreated datePublished" datetime="2019-04-24T14:19:35+08:00">2019-04-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h1><p>CSS预处理器主要有以下三个比较流行。sass、less和stylus。在vue项目中的使用方法，就是安装对应处理器的对应loader就可以了。<br>接下来讲一讲预处理器的几大特性。由于本人习惯于sass,至于less的语法其实和sass差不多，stylus那个复杂的写法第一次看到后直接劝退，所以下文主要是针对sass而言的。</p>
<h2 id="1、节点可以嵌套，对父子级元素一目了然"><a href="#1、节点可以嵌套，对父子级元素一目了然" class="headerlink" title="1、节点可以嵌套，对父子级元素一目了然"></a>1、节点可以嵌套，对父子级元素一目了然</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//传统写法</span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line">//sass</span><br><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>-<span class="number">10px</span>;</span><br><span class="line">        <span class="selector-class">.child</span>&#123;</span><br><span class="line">            <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">            <span class="selector-tag">a</span>&#123;</span><br><span class="line">                <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、可以声明变量"><a href="#2、可以声明变量" class="headerlink" title="2、可以声明变量"></a>2、可以声明变量</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//通常可以给网站的基础变量（基础字体、主题色调等）赋值一个变量，然后样式中调用这个变量就可以了。</span><br><span class="line">//sass中变量的声明必须是一$号开头的</span><br><span class="line">    $mainColor: #233233;</span><br><span class="line">    $mainFont: 12px red;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.header</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>: $mainColor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、使用Mixin，提高可重用性"><a href="#3、使用Mixin，提高可重用性" class="headerlink" title="3、使用Mixin，提高可重用性"></a>3、使用Mixin，提高可重用性</h2><p>通过@mixin加名称的方式就可以定义一个Mixins模块，在模块内你可以添加任何你想重复使用的样式。(比如清除浮动)</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> button &#123;  </span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1em</span>;  </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">1.0em</span>;  </span><br><span class="line">    <span class="attribute">text-decoration</span>: none;  </span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用<span class="keyword">@include</span>引入</span><br><span class="line">.button-green &#123;  </span><br><span class="line">    <span class="keyword">@include</span> button;  </span><br><span class="line">    <span class="attribute">background-color</span>: green;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//解析之后的样式</span><br><span class="line"><span class="selector-class">.button-green</span> &#123;  </span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1em</span>;  </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">1.0em</span>;  </span><br><span class="line">    <span class="attribute">text-decoration</span>: none;  </span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;  </span><br><span class="line">    <span class="attribute">background-color</span>: green;  </span><br><span class="line">&#125;</span><br><span class="line">//mixin另一个强大的地方是还可以接收参数！！无敌，定义一个全局的变量之后，就不必每次都去赋值了~~~</span><br><span class="line"></span><br><span class="line">$background: red;</span><br><span class="line"><span class="keyword">@mixin</span> button($background) &#123;  </span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1em</span>;  </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">1.0em</span>;  </span><br><span class="line">    <span class="attribute">text-decoration</span>: none;  </span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;  </span><br><span class="line">    <span class="attribute">background</span>: $background;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4、-extend继承选择器"><a href="#4、-extend继承选择器" class="headerlink" title="4、 @extend继承选择器"></a>4、 @extend继承选择器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　.a1 &#123;</span><br><span class="line">　　　　color: blue;</span><br><span class="line">　　&#125;</span><br><span class="line">　　.a2 &#123;</span><br><span class="line">　　　　@extend .a1;</span><br><span class="line">　　　　font-size: 12px;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、-function函数的功能"><a href="#5、-function函数的功能" class="headerlink" title="5、@function函数的功能"></a>5、@function函数的功能</h2><p>使用 @function+函数名称，每个函数都需要有返回值的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　@function du($r) &#123;</span><br><span class="line">　　　　@return $r*2</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　.a8 &#123;</span><br><span class="line">　　　　border: solid #&#123;du(2)&#125;px red;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、引用父元素-amp-：在编译时，-amp-将被替换成父选择符"><a href="#6、引用父元素-amp-：在编译时，-amp-将被替换成父选择符" class="headerlink" title="6、引用父元素&amp;：在编译时，&amp;将被替换成父选择符"></a>6、引用父元素&amp;：在编译时，&amp;将被替换成父选择符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">　a &#123;</span><br><span class="line">　　　font-size: 20px;</span><br><span class="line">　　　text-decoration: none;</span><br><span class="line">　　　&amp;:hover &#123;</span><br><span class="line">　　　　　text-decoration: underline;</span><br><span class="line">　　　&#125;</span><br><span class="line">　&#125;</span><br><span class="line">&#x2F;&#x2F;编译之后</span><br><span class="line">　a &#123;</span><br><span class="line">　　　font-size: 20px;</span><br><span class="line">　　　text-decoration: none;</span><br><span class="line">　　&#125;</span><br><span class="line">　a:hover &#123;</span><br><span class="line">　　　text-decoration: underline;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>

<p>以上算是sass中比较常见的用法吧。得益于sass，css的编写不再那样千篇一律。而scss则是sass的最新语法，完全兼容css，如果写习惯了css，可能不太习惯于那种严格的缩进式语法，相比其他几种，scss更适合我。。。。。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/22/css/CSS%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/22/css/CSS%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-title-link" itemprop="url">CSS常见知识点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-22 10:59:25" itemprop="dateCreated datePublished" datetime="2019-04-22T10:59:25+08:00">2019-04-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="css-命名规范（BEM）和优化"><a href="#css-命名规范（BEM）和优化" class="headerlink" title="css 命名规范（BEM）和优化"></a>css 命名规范（BEM）和优化</h1><p>BlockElementModifier 其实是块（block）、元素（element）、修饰符（modifier）。</p>
<p>这三个部分使用 __ 与 – 连接。</p>
<p>.块 __ 元素 – 修饰符 {}</p>
<ul>
<li>block 代表了更高级别的抽象或组件。</li>
<li>block__element 代表 block 的后代，用于形成一个完整的 block 的整体。</li>
<li>block–modifier 代表 block 的不同状态或不同版本。</li>
</ul>
<p>使用 BEM 命名规范的优点</p>
<ol>
<li>CSS引擎查找样式表，对每条规则都按从右到左的顺序去匹配</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#ul-id</span> <span class="selector-tag">li</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看起来很快，实际上很慢。</p>
<p>通常我们会认为浏览器是这样工作的：找到唯一 ID 元素 ul-id —&gt; 把样式应用到 li 元素上。</p>
<p>事实上: 从右到左进行匹配，遍历页面上每个 li 元素并确定其父元素。<strong>所以尽量不要使 css 超过三层。</strong></p>
<p>eg： 相比于 # markdown-content-h3，显然使用 #markdown .content h3 时，浏览器生成渲染树（render-tree）所要花费的时间更多。后者需要先找到 DOM 中所有 h3 的元素，再过滤掉祖先元素不是 .content 的，最后再过滤祖先元素不是 #markdown 的元素。</p>
<ol start="2">
<li>语义化</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* .块 __ 元素 -- 修饰符 &#123;&#125; */</span></span><br><span class="line"><span class="selector-class">.person</span>&#123; &#125; <span class="comment">/*人*/</span></span><br><span class="line"><span class="selector-class">.person__hand</span>&#123; &#125; <span class="comment">/*人的手*/</span></span><br><span class="line"><span class="selector-class">.person--female</span>&#123; &#125; <span class="comment">/*女人*/</span></span><br><span class="line"><span class="selector-class">.person--female__hand</span>&#123; &#125; <span class="comment">/*女人的手*/</span></span><br><span class="line"><span class="selector-class">.person__hand--left</span>&#123; &#125; <span class="comment">/*人的左手*/</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 scss 中使用</li>
</ol>
<p><strong>使用 @at-root 内联选择器模式，编译出来的 CSS 无任何嵌套（这是关键）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.person &#123;</span><br><span class="line">  @at-root #&#123;&amp;&#125;__hand &#123;</span><br><span class="line">    color: red;</span><br><span class="line">    @at-root #&#123;&amp;&#125;--left &#123;</span><br><span class="line">     color: yellow;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @at-root #&#123;&amp;&#125;--female &#123;</span><br><span class="line">    color: blue;</span><br><span class="line">    @at-root #&#123;&amp;&#125;__hand &#123;</span><br><span class="line">      color: green;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*生成的css*/</span></span><br><span class="line"></span><br><span class="line">.person__hand &#123;</span><br><span class="line">   color: red;</span><br><span class="line">&#125;</span><br><span class="line">.person__hand--left &#123;</span><br><span class="line">   color: yellow; </span><br><span class="line">&#125;</span><br><span class="line">.person--female&#123;</span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br><span class="line">.person--female__hand &#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>减少使用昂贵的属性</li>
</ol>
<p>在浏览器绘制屏幕时，所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价。</p>
<p>当页面发生重绘时，它们会降低浏览器的渲染性能。所以在编写CSS时，我们应该尽量减少使用昂贵属性，如box-shadow/border-radius/filter/透明度/:nth-child等。</p>
<p>当然，并不是让大家不要使用这些属性，因为这些应该都是我们经常使用的属性。之所以提这一点，是让大家对此有一个了解。</p>
<p>当有两种方案可以选择的时候，可以优先选择没有昂贵属性或昂贵属性更少的方案，如果每次都这样的选择，网站的性能会在不知不觉中得到一定的提升。</p>
<ol start="5">
<li>减少回流和重绘</li>
</ol>
<h1 id="Flex布局常见属性"><a href="#Flex布局常见属性" class="headerlink" title="Flex布局常见属性"></a>Flex布局常见属性</h1><h2 id="1、flex-direction"><a href="#1、flex-direction" class="headerlink" title="1、flex-direction"></a>1、flex-direction</h2><p>flex-direction属性决定主轴的方向（即项目的排列方向）。 .box { display:flex; flex-direction: row | row-reverse | column | column-reverse; } row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿,自上而下。 column-reverse：主轴为垂直方向，起点在下沿,自下而上。</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/flex1.PNG" alt="markdown"></p>
<h2 id="2、flex-wrap"><a href="#2、flex-wrap" class="headerlink" title="2、flex-wrap"></a>2、flex-wrap</h2><p>//默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义 //如果一条轴线排不下，应该如何换行。 .box{ display:flex; flex-wrap: nowrap | wrap | wrap-reverse; } nowrap（默认）：不换行,宽度自动压缩。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 <img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/flex2.PNG" alt="markdown"> <img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/flex3.PNG" alt="markdown"> <img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/flex4.PNG" alt="markdown"></p>
<h2 id="3、flex-flow"><a href="#3、flex-flow" class="headerlink" title="3、flex-flow"></a>3、flex-flow</h2><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式 ，默认值为row nowrap。 .box { flex-flow: <flex-direction> || <flex-wrap>; } .box{ flex-flow:row||nowrap; }</p>
<h2 id="4、justify-content"><a href="#4、justify-content" class="headerlink" title="4、justify-content"></a>4、justify-content</h2><p>justify-content属性定义了项目在主轴上(即横向)的对齐方式。</p>
<p>flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，组件之间的间隔都相等。 space-around：距边界两侧的间隔相等，元素之间的间隔比项目与边框的间隔大一倍。</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/flex5.PNG" alt="markdown"></p>
<h2 id="5、align-items"><a href="#5、align-items" class="headerlink" title="5、align-items"></a>5、align-items</h2><p>align-items属性定义项目在交叉轴上(即纵向,垂直)如何对齐。 .box { align-items: flex-start | flex-end | center | baseline | stretch; } flex-start：交叉轴的起点(顶部)对齐。 flex-end：交叉轴的终点(底部)对齐。 center：交叉轴的中点(中间)对齐。 baseline: 项目的第一行文字的基线(即根据内容对齐,不再根据容器)对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 <img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/flex6.PNG" alt="markdown"></p>
<h2 id="6、align-content"><a href="#6、align-content" class="headerlink" title="6、align-content"></a>6、align-content</h2><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。</p>
<p>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/flex7.PNG" alt="markdown"></p>
<h1 id="link与-import的区别"><a href="#link与-import的区别" class="headerlink" title="link与@import的区别"></a>link与@import的区别</h1><p>区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</p>
<p>区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</p>
<p>区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</p>
<p>区别4：link支持使用Javascript控制DOM去改变样式；而@import不支持。 　　import的写法比较多：推荐使用 @import url(index.css);</p>
<h1 id="src和href的区别"><a href="#src和href的区别" class="headerlink" title="src和href的区别"></a>src和href的区别</h1><p>href标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系</p>
<p>src表示引用资源，表示替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分</p>
<p>src是source的缩写，是指向外部资源的位置，指向的内部会迁入到文档中当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到当前文档中，例如js脚本，img图片和frame等元素。</p>
<p><code>&lt;script src=&quot;js.js&quot;&gt;&lt;/script&gt;</code>当浏览器解析到这一句的时候会暂停其他资源的下载和处理，直至将该资源加载，编译，执行完毕，图片和框架等元素也是如此，类似于该元素所指向的资源嵌套如当前标签内，这也是为什么要把js饭再底部而不是头部。</p>
<p><code>&lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;/&gt;</code>当浏览器解析到这一句的时候会识别该文档为css文件，会下载并且不会停止对当前文档的处理，这也是为什么建议使用link方式来加载css而不是使用@import。</p>
<h1 id="position属性"><a href="#position属性" class="headerlink" title="position属性"></a>position属性</h1><h2 id="1、position-absolute"><a href="#1、position-absolute" class="headerlink" title="1、position:absolute;"></a>1、position:absolute;</h2><p>绝对定位，<strong>脱离文档流</strong>的布局。相对于最近的已经定位的父元素，起始位置为最近的父元素(postion不为static)，否则为Body文档本身。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>绝对定位<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span>                </span><br><span class="line"><span class="css">  <span class="selector-tag">body</span>&#123;<span class="attribute">background</span>:green;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span>&#123; <span class="attribute">width</span>: <span class="number">500px</span>;<span class="attribute">height</span>: <span class="number">500px</span>;<span class="attribute">background</span>: <span class="number">#ccc</span>;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.son</span>&#123; <span class="attribute">width</span>: <span class="number">300px</span>;<span class="attribute">height</span>: <span class="number">300px</span>;<span class="attribute">background</span>: <span class="number">#aaa</span>;&#125;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">span</span>&#123;<span class="attribute">position</span>: absolute; <span class="attribute">right</span>: <span class="number">30px</span>; <span class="attribute">background</span>: <span class="number">#888</span>;&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>什么？<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/absolute2.png" alt="markdown"></p>
<h2 id="2、position-relative"><a href="#2、position-relative" class="headerlink" title="2、position:relative"></a>2、position:relative</h2><p><strong>相对定位元素的定位是相对它自己的正常位置的定位</strong><br>所以关键在于如何确定其正常的位置。不会脱离文档流</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/relative.jpg" alt="markdown"></p>
<p>在relative中，RLTB属性后的值如果是负数，则与其相同方向移动<br>如果值是正数，则与其反方向移动</p>
<h2 id="3、position-fixed"><a href="#3、position-fixed" class="headerlink" title="3、position:fixed"></a>3、position:fixed</h2><p>fixed定位是指元素的位置相对于<strong>浏览器窗口是固定位置</strong>，即使窗口是滚动的它也不会滚动，且fixed定位使元素的位置与<strong>文档流无关</strong>，因此不占据空间，且它会和其他元素发生重叠。<br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/fixed.png" alt="markdown"><br>所以这个属性的应用就类似于网站的小广告一样！！！<br>但是这个属性在IE7和IE8不支持，需要另外声明。</p>
<h2 id="4、position：static"><a href="#4、position：static" class="headerlink" title="4、position：static"></a>4、position：static</h2><p>默认的属性，只要有了这个属性，元素就会出现在<strong>正常的文档流</strong>，不会受到top、bottom、left和right的影响。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--对应的css样式--&gt;</span></span><br><span class="line">.wrap&#123;width: 300px;height: 300px; background: red;&#125;</span><br><span class="line">.content&#123;position: static; top:100px; width: 100px;height: 100px; background: blue;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、position：sticky"><a href="#5、position：sticky" class="headerlink" title="5、position：sticky"></a>5、position：sticky</h2><p>粘性定位。<br>基于用户的滚动位置来定位。<br>粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。<br>它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。<br>元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  div.sticky &#123;</span><br><span class="line">    position: -webkit-sticky;</span><br><span class="line">    position: sticky;</span><br><span class="line">    top: <span class="number">0</span>;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    background-color: #cae8ca;</span><br><span class="line">    border: 2px solid #4CAF50;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;sticky&quot;</span>&gt;我是粘性定位!&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div style=<span class="string">&quot;padding-bottom:2000px&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;滚动我&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;来回滚动我&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;滚动我&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;来回滚动我&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;滚动我&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;来回滚动我&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="6、position：inherit"><a href="#6、position：inherit" class="headerlink" title="6、position：inherit"></a>6、position：inherit</h2><p>继承父类的position属性</p>
<h2 id="7、position：initial"><a href="#7、position：initial" class="headerlink" title="7、position：initial"></a>7、position：initial</h2><p>将属性设置为初始值</p>
<p><strong>脱离文档流只有浮动属性，绝对定位以及固定定位</strong></p>
<h1 id="CSS清除浮动的几种方式"><a href="#CSS清除浮动的几种方式" class="headerlink" title="CSS清除浮动的几种方式"></a>CSS清除浮动的几种方式</h1><p>清除浮动的原因是由于高度的坍塌，本来父元素的高度是默认由子元素撑开的，但是由于子元素设置了浮动，则子元素完全脱离了文档流，导致子元素无法撑开父元素的高度，所以高度塌陷。</p>
<h2 id="1、父级div定义伪元素：after和zoom"><a href="#1、父级div定义伪元素：after和zoom" class="headerlink" title="1、父级div定义伪元素：after和zoom"></a>1、父级div定义伪元素：after和zoom</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span> </span><br><span class="line"><span class="css">   <span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;&#125;</span></span><br><span class="line"><span class="css">   <span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">margin-top</span>:<span class="number">10px</span>&#125;</span></span><br><span class="line">   </span><br><span class="line"><span class="css">   <span class="selector-class">.left</span>&#123;<span class="attribute">float</span><span class="selector-pseudo">:left</span>;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125;</span></span><br><span class="line"><span class="css">   <span class="selector-class">.right</span>&#123;<span class="attribute">float</span><span class="selector-pseudo">:right</span>;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125;</span></span><br><span class="line">   </span><br><span class="line"><span class="css">   <span class="comment">/*清除浮动代码*/</span></span></span><br><span class="line">   .clearfloat:after&#123;</span><br><span class="line"><span class="css">      <span class="attribute">display</span>:block;</span></span><br><span class="line"><span class="css">      <span class="attribute">clear</span>:both;</span></span><br><span class="line"><span class="css">      <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">visibility</span>:hidden;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>:<span class="number">0</span>;</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="css">   <span class="selector-class">.clearfloat</span>&#123;zoom:<span class="number">1</span>&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clearfloat&quot;</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div2&quot;</span>&gt;</span></span><br><span class="line">   div2</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，==zoom(IE转有属性)==可解决ie6,ie7浮动问题。这个方法相对而言更加推荐使用。</p>
<h2 id="2-在结尾处添加空div标签clear-both"><a href="#2-在结尾处添加空div标签clear-both" class="headerlink" title="2.在结尾处添加空div标签clear:both"></a>2.在结尾处添加空div标签clear:both</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span> </span><br><span class="line"><span class="css">   <span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red&#125;</span></span><br><span class="line"><span class="css">   <span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">margin-top</span>:<span class="number">10px</span>&#125;</span></span><br><span class="line"><span class="css">   <span class="selector-class">.left</span>&#123;<span class="attribute">float</span><span class="selector-pseudo">:left</span>;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125;</span></span><br><span class="line"><span class="css">   <span class="selector-class">.right</span>&#123;<span class="attribute">float</span><span class="selector-pseudo">:right</span>;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125;</span></span><br><span class="line">   </span><br><span class="line"><span class="css">   <span class="comment">/*清除浮动代码*/</span></span></span><br><span class="line"><span class="css">   <span class="selector-class">.clearfloat</span>&#123;<span class="attribute">clear</span>:both&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clearfloat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div2&quot;</span>&gt;</span></span><br><span class="line">   div2</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不推荐使用，如果页面的浮动布局多，会新增了空的div，但此方法是以前主要使用的一种清除浮动方法，不过代码量少，对浏览器的兼容性好。</p>
<h2 id="3、为父级元素增加高度"><a href="#3、为父级元素增加高度" class="headerlink" title="3、为父级元素增加高度"></a>3、为父级元素增加高度</h2><p>简单容易理解，但是需要给出精确的父级高度，适用于高度固定的布局。</p>
<h2 id="4-父级div定义overflow-hidden"><a href="#4-父级div定义overflow-hidden" class="headerlink" title="4.父级div定义overflow:hidden"></a>4.父级div定义overflow:hidden</h2><p>必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度 简单，代码少，浏览器支持好，但是不能和position配合使用，因为超出的尺寸的会被隐藏。</p>
<h1 id="em和rem和vw-vh单位"><a href="#em和rem和vw-vh单位" class="headerlink" title="em和rem和vw/vh单位"></a>em和rem和vw/vh单位</h1><p>这两个都是css单位，并且都是相对单位，先有的em，后有的rem。</p>
<h2 id="em"><a href="#em" class="headerlink" title="em"></a>em</h2><p>em可以让我们的页面更灵活，更健壮，比起到处写死的px值，em似乎更有张力，<strong>改动父元素的字体大小，子元素会等比例变化</strong>。但是使用em进行弹性布局，会使得单位之间的转换变得复杂，缺点还在于牵一发而动全身，一旦某个节点的字体大小发生变化，那么其后代元素都得重新计算。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;p1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;s1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;s2&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;p2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;s5&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;s6&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">.p1 &#123;font-size: 16px; line-height: 32px;&#125;</span><br><span class="line">.s1 &#123;font-size: 2em;&#125;</span><br><span class="line">.s2 &#123;font-size: 2em; line-height: 2em;&#125;</span><br><span class="line"></span><br><span class="line">.p2 &#123;font-size: 16px; line-height: 2;&#125;</span><br><span class="line">.s5 &#123;font-size: 2em;&#125;</span><br><span class="line">.s6 &#123;font-size: 2em; line-height: 2em;&#125;</span><br></pre></td></tr></table></figure>

<p>line-height: 2自身字体大小的两倍</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p2：font-size: 16px; line-height: 32px</span><br><span class="line">s5：font-size: 32px; line-height: 64px</span><br><span class="line">s6：font-size: 32px; line-height: 64px</span><br></pre></td></tr></table></figure>

<h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p>rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小。<br>实际开发可以设置网页的默认字体为50px，这样在换算成rem的时候直接将px的数值乘以0.2就可以了。<br>为了简便也可以使用webpack的px2rem-loader插件</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 作用于根元素，相对于原始大小（16px），所以html的font-size为32px*/</span></span><br><span class="line"><span class="selector-tag">html</span>&#123;<span class="attribute">font-size</span>:<span class="number">2rem</span>&#125;</span><br><span class="line"><span class="comment">/* 作用于非根元素，相对于根元素字体大小，所以为64px */</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">font-size</span>:<span class="number">2rem</span>&#125;</span><br></pre></td></tr></table></figure>

<p>（PS：<strong>弹性布局可以算作响应式布局的一种，但响应式布局不是弹性布局</strong>，弹性布局强调等比缩放，100%还原；响应式布局强调不同屏幕要有不同的显示，比如媒体查询）</p>
<p>缺点：如果要使用rem实现响应式的布局，则只要根据视图容器的大小，动态改变font-size就可以了，所以就必须通过js来动态控制根元素font-size的大小了，也就是说css样式和js有一定的耦合，而且必须把改变font-size的代码放在css样式之前，所以就有了另一种单位，vw和vh。</p>
<h2 id="vh和vw"><a href="#vh和vw" class="headerlink" title="vh和vw"></a>vh和vw</h2><p>视口：在桌面端，视口指的是在桌面端，指的是浏览器的可视区域；而在移动端，它涉及3个视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口）。</p>
<p>视口单位中的“视口”，桌面端指的是浏览器的可视区域；移动端指的就是Viewport中的Layout Viewport。</p>
<p>根据CSS3规范，视口单位主要包括以下4个：</p>
<ol>
<li><p>vw：1vw等于视口宽度的1%。</p>
</li>
<li><p>vh：1vh等于视口高度的1%。</p>
</li>
<li><p>vmin：选取vw和vh中最小的那个。</p>
</li>
<li><p>vmax：选取vw和vh中最大的那个。</p>
</li>
</ol>
<p> vh and vw：相对于视口的高度和宽度，而不是父元素的（CSS百分比是相对于包含它的最近的父元素的高度和宽度）。1vh 等于1/100的视口高度，1vw 等于1/100的视口宽度。</p>
<p>比如：浏览器高度950px，宽度为1920px, 1 vh = 950px/100 = 9.5 px，1vw = 1920px/100 =19.2 px。</p>
<p>vmax相对于视口的宽度或高度中较大的那个。其中最大的那个被均分为100单位的vmax。</p>
<p>vmin相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin。</p>
<p>如果要兼容opera浏览器的话，不建议使用。</p>
<h1 id="flex实现圣杯布局和双飞翼布局"><a href="#flex实现圣杯布局和双飞翼布局" class="headerlink" title="flex实现圣杯布局和双飞翼布局"></a>flex实现圣杯布局和双飞翼布局</h1><p>为什么要使用flex布局呢。因为比起绝对定位然后再去设置边距什么的，flex绝对容易理解然后代码量还少，DOM渲染时间更快，所以只讲flex，绝对不是因为懒！<br>圣杯布局：中间的div需要加上flex: 1，才可以将中间div的宽度填满。实现自适应宽度。<br>双飞翼布局和圣杯布局几乎一样(其实就是一回事)，区别在于处理center中被遮挡的部分。双飞翼是在center中再放一个div用来显示内容，为其设置margin。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>圣杯布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  * &#123;</span><br><span class="line"><span class="css">      <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">	.container&#123;</span><br><span class="line"><span class="css">		<span class="attribute">display</span>: flex;;</span></span><br><span class="line"><span class="css">		<span class="attribute">justify-content</span>: space-between;</span></span><br><span class="line">	&#125;</span><br><span class="line">	.box&#123;</span><br><span class="line"><span class="css">		<span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">		<span class="attribute">min-height</span>: <span class="number">200px</span>;</span></span><br><span class="line">	&#125;</span><br><span class="line">	.left&#123;</span><br><span class="line"><span class="css">		<span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">		<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line">	&#125;</span><br><span class="line">	.center&#123;</span><br><span class="line"><span class="css">		<span class="attribute">background</span>: yellow;</span></span><br><span class="line"><span class="css">		<span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line">	&#125;</span><br><span class="line">	.right&#123;</span><br><span class="line"><span class="css">		<span class="attribute">background</span>: pink;</span></span><br><span class="line"><span class="css">		<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box center&quot;</span>&gt;</span>233<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>CSS 盒子模型主要有两种，一种是标准盒子模型，另外一种是IE盒子模型。接下来用图片来展示两种盒子模型。</p>
<p>标准盒子模型：<br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/standardModel.jpg" alt="markdown"></p>
<p>IE盒子模型：<br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/IEmodel.jpg" alt="markdown"></p>
<p>标准盒子模型的 width = content + padding + border + margin,高度同理。<br>IE盒子模型的 width = content + margin。<br>所以两个模型的主要区别在于 IE 模型的 content 其实包含了 content 和 padding 及 border。</p>
<p>在现在的浏览器中，默认使用的是标准模型，二者的主要区别在于宽度和高度的计算方式不同。打开控制台就可以看到了。在这里，其实盒子模型的选取，看个人习惯吧，并没有绝对的好坏之分。<br><a target="_blank" rel="noopener" href="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/consoleBox.png">markdown</a></p>
<h2 id="2、切换两种盒子模型"><a href="#2、切换两种盒子模型" class="headerlink" title="2、切换两种盒子模型"></a>2、切换两种盒子模型</h2><p>有人开发可能习惯标准模型，有人可能习惯 IE 模型。那我们要怎么来切换这两种盒子模型呢？其实也是很简单，通过 CSS3 的 box-sizing 来设置就可以了。<br>box-sizing: content-box 是 W3C 盒子模型<br>box-sizing: border-box 是 IE 盒子模型</p>
<h2 id="3、获取盒子宽度和高度"><a href="#3、获取盒子宽度和高度" class="headerlink" title="3、获取盒子宽度和高度"></a>3、获取盒子宽度和高度</h2><p>那么问题来了，如何通过 JS 来获取盒子模型的宽高呢。<br>a、使用dom.style.width/height</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">		<span class="keyword">var</span> oBox=<span class="built_in">document</span>.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line">		<span class="built_in">console</span>.log(oBox.style.height);</span><br><span class="line">		<span class="built_in">console</span>.log(oBox.style.background);</span><br><span class="line">		<span class="comment">// console.log(oBox.currentStyle.width)</span></span><br><span class="line">		<span class="comment">// 上面的方法只是适用于IE</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">window</span>.getComputedStyle(oBox).width);</span><br><span class="line">		<span class="built_in">console</span>.log(oBox.getBoundingClientRect());</span><br><span class="line"><span class="comment">//dom这里就省略不写了。这个方法在这里只能获得内联样式，也就是如果你是外链的CSS样式文件，控制台是无法获得并打印出来的</span></span><br></pre></td></tr></table></figure>
<p>b、dom.currentStyle.width/height<br>这个方法相比上一个方法的区别，就是获取的浏览器即时运行的结果，就是渲染以后的结果，相对准确，并且不局限于内联样式，但是这个方法只有IE能支持。</p>
<p>c、window.getComputedStyle(dom).width<br>道理其实和第二个是一样的，但是相对第二个该方法兼容了谷歌浏览器和火狐浏览器，所以兼容性更好一点。</p>
<p>d、dom.getBoundingClientRect().width/height<br>该方法通常用于计算一个元素的绝对位置，也就是根据视窗计算的。该方法会返回8个值上下左右宽高和 xy</p>
<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><p>首先什么是 BFC，说实话这个概念之前都没有怎么接触过，所以赶紧找时间恶补了一下。。BFC 全称是Block Formatting Context，即块格式化上下文。它是 CSS2.1 规范定义的，关于 CSS 渲染定位的一个概念。要明白深入了解 BFC 的话，需要先了解视觉格式化模型(visual formatting model)和 CSS 的盒子（BOX）概念。</p>
<h2 id="视觉格式化模型"><a href="#视觉格式化模型" class="headerlink" title="视觉格式化模型"></a>视觉格式化模型</h2><p>视觉格式化模型(visual formatting model)是用来处理文档并将它显示在视觉媒体上的机制，它也是 CSS中的一个概念。<br>视觉格式化模型定义了盒（Box）的生成，盒主要包括了块盒、行内盒、匿名盒（没有名字不能被选择器选中的盒）以及一些实验性的盒（未来可能添加到规范中）。盒的类型由 display 属性决定。</p>
<h3 id="BOX"><a href="#BOX" class="headerlink" title="BOX"></a>BOX</h3><ol>
<li>块级盒：即 display 属性为 block、list-item、table 的元素，在视觉上呈现为块，竖直排列，独占一行。（支持宽高 width、height）</li>
<li>行内盒：即 display 的计算值为 inline，inline-block 或 inline-table。</li>
<li>匿名盒：匿名盒没有名字，不能利用选择器来选择它们，所以它们的所有属性都为 inherit 或初始默认值。</li>
</ol>
<h3 id="三个定位方案"><a href="#三个定位方案" class="headerlink" title="三个定位方案"></a>三个定位方案</h3><ul>
<li>常规流</li>
<li>浮动</li>
<li>定位</li>
</ul>
<h2 id="BFC-的形成条件"><a href="#BFC-的形成条件" class="headerlink" title="BFC 的形成条件"></a>BFC 的形成条件</h2><ul>
<li>根元素。</li>
<li>float 的值不能为 none。</li>
<li>overflow 的值不能为 visible。</li>
<li>display 的值为 table-cell, table-caption, inline-block, flex, inline-flex 中的任何一个。</li>
<li>position 的值为 absolute 和 fixed。</li>
</ul>
<h2 id="BFC-的约束规则"><a href="#BFC-的约束规则" class="headerlink" title="BFC 的约束规则"></a>BFC 的约束规则</h2><ol>
<li>内部的 Box 会在垂直方向上一个接一个的放置。</li>
<li>垂直方向的距离有 margin 决定(属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠，与方向无关)。</li>
<li>每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>
</ol>
<p><strong>4. BFC 的区域不会与 float 的元素区域重叠。</strong><br><strong>5. 计算 BFC 的高度时，浮动子元素也参与计算。</strong><br><strong>6. BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然。</strong></p>
<h2 id="BFC-的作用"><a href="#BFC-的作用" class="headerlink" title="BFC 的作用"></a>BFC 的作用</h2><h3 id="不和浮动的元素相重叠"><a href="#不和浮动的元素相重叠" class="headerlink" title="不和浮动的元素相重叠"></a>不和浮动的元素相重叠</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">	    .Box &#123;</span><br><span class="line"><span class="css">	        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">	        <span class="attribute">position</span>: relative;</span></span><br><span class="line">	    &#125;</span><br><span class="line">	    .aside &#123;</span><br><span class="line"><span class="css">	        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">	        <span class="attribute">height</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="css">	        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">	        <span class="attribute">background</span>: <span class="number">#f66</span>;</span></span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    .main &#123;</span><br><span class="line"><span class="css">	        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">	        <span class="attribute">background</span>: <span class="number">#fcc</span>;</span></span><br><span class="line">	    &#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Box&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>分析：<br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/BFC1.png" alt="markdown"><br>由于 aside 向左浮动具有 BFC，但是 main 并不具有 BFC，所以发生了重叠。在这里，根据上面的第四条规则，可以使 main 具备 BFC，便不会发生重叠。<br>给 main 元素的 overflow 属性加上 heiiden值便可满足条件。<br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/BFC2.png" alt="markdown"></p>
<h3 id="清除元素内部的浮动"><a href="#清除元素内部的浮动" class="headerlink" title="清除元素内部的浮动"></a>清除元素内部的浮动</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">		    .par &#123;</span><br><span class="line"><span class="css">		        <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#fcc</span>;</span></span><br><span class="line"><span class="css">		        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line">		    &#125;</span><br><span class="line"></span><br><span class="line">		    .child &#123;</span><br><span class="line"><span class="css">		        <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#f66</span>;</span></span><br><span class="line"><span class="css">		        <span class="attribute">width</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">		        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">		        <span class="attribute">float</span>: left;</span></span><br><span class="line">		    &#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;par&quot;</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>分析：<br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/BFC3.png" alt="markdown"><br>根据 BFC 布局规则第六条：计算 BFC 的高度时，浮动元素也参与计算，为达到清除内部浮动，我们可以触发 par 生成 BFC，那么 par 在计算高度时，par 内部的浮动元素 child 也会参与计算。<br>所以在这里给 par 加上一个 overflow 的 hidden 属性值，触发 par 生成 BFC 就可以了。<br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/BFC4.png" alt="markdown"></p>
<h3 id="防止垂直-margin-重叠"><a href="#防止垂直-margin-重叠" class="headerlink" title="防止垂直 margin 重叠"></a>防止垂直 margin 重叠</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">	    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">	        <span class="attribute">color</span>: <span class="number">#f55</span>;</span></span><br><span class="line"><span class="css">	        <span class="attribute">background</span>: <span class="number">#fcc</span>;</span></span><br><span class="line"><span class="css">	        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">	        <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">	        <span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="css">	        <span class="attribute">margin</span>: <span class="number">100px</span>;</span></span><br><span class="line">	    &#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Haha<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hehe<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>分析：<br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/BFC5.png" alt="markdown"><br>很明显，在这里两个标签的 margin 发生了重叠，应该是 200px。<br>根据 BFC 布局规则第二条：Box 垂直方向的距离由margin决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠，并且取值较大的那一个。<br>为了能够正常显示，那我们可以在p外面包裹一层容器，并触发该容器生成一个 BFC。那么两个 P 便不属于同一个 BFC，就不会发生 margin 重叠了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    .wrap &#123;</span><br><span class="line"><span class="css">      <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: <span class="number">#f55</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background</span>: <span class="number">#fcc</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">100px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Haha<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hehe<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/BFC5.png" alt="markdown"><br>按照 BFC 的定义，只有同属于一个 BFC 时，两个元素才有可能发生垂直 Margin 的重叠，这个包括相邻元素，嵌套元素，只要他们之间没有阻挡(例如边框，非空内容，padding 等)就会发生 margin 重叠。<br>因此要解决 margin 重叠问题，只要让它们不在同一个 BFC 就行了，但是对于两个相邻元素来说，意义不大，没有必要给它们加个外壳，但是对于嵌套元素来说就很有必要了，只要把父元素设为 BFC 就可以了。这样子元素的 margin 就不会和父元素的 margin 发生重叠了。</p>
<h1 id="IFC（Inline-Formatting-Contexts）行内级格式化上下文"><a href="#IFC（Inline-Formatting-Contexts）行内级格式化上下文" class="headerlink" title="IFC（Inline Formatting Contexts）行内级格式化上下文"></a>IFC（Inline Formatting Contexts）行内级格式化上下文</h1><p>行内级格式化上下文用来规定行内级盒子的格式化规则。</p>
<p>先来看看如何生成一个 IFC ：</p>
<p>IFC 只有在一个块级元素中仅包含内联级别元素时才会生成。</p>
<p><strong>布局规则</strong></p>
<ol>
<li><p>内部的盒子会在水平方向，一个接一个地放置。</p>
</li>
<li><p>这些盒子垂直方向的起点从包含块盒子的顶部开始。</p>
</li>
<li><p>摆放这些盒子的时候，它们在水平方向上的 padding、border、margin 所占用的空间都会被考虑在内。</p>
</li>
<li><p>在垂直方向上，这些框可能会以不同形式来对齐（vertical-align）：它们可能会使用底部或顶部对齐，也可能通过其内部的文本基线（baseline）对齐。</p>
</li>
<li><p>能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框（line box）。行框的宽度是由包含块（containing box）和存在的浮动来决定。</p>
</li>
<li><p>IFC中的 line box 一般左右边都贴紧其包含块，但是会因为float元素的存在发生变化。float 元素会位于IFC与与 line box 之间，使得 line box 宽度缩短。</p>
</li>
<li><p>IFC 中的 line box 高度由 CSS 行高计算规则来确定，同个 IFC 下的多个 line box 高度可能会不同（比如一行包含了较高的图片，而另一行只有文本）</p>
</li>
<li><p>当 inline-level boxes 的总宽度少于包含它们的 line box 时，其水平渲染规则由 text-align 属性来确定，如果取值为 justify，那么浏览器会对 inline-boxes（注意不是inline-table 和 inline-block boxes）中的文字和空格做出拉伸。</p>
</li>
<li><p>当一个 inline box 超过 line box 的宽度时，它会被分割成多个boxes，这些 boxes 被分布在多个 line box 里。如果一个 inline box 不能被分割（比如只包含单个字符，或 word-breaking 机制被禁用，或该行内框受 white-space 属性值为 nowrap 或 pre 的影响），那么这个 inline box 将溢出这个 line box。</p>
</li>
</ol>
<p><strong>具体用处：</strong></p>
<p>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过设置父容器 text-align:center 则可以使其水平居中。<strong>inline-block 的宽度默认由内容撑开</strong>。</p>
<p>值得注意的是，设置一个块为 inline-block ，以单个封闭块来参与外部的 IFC，而内部则生成了一个 BFC。</p>
<p>垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</p>
<h1 id="FFC（Flex-Formatting-Contexts）Flex格式化上下文"><a href="#FFC（Flex-Formatting-Contexts）Flex格式化上下文" class="headerlink" title="FFC（Flex Formatting Contexts）Flex格式化上下文"></a>FFC（Flex Formatting Contexts）Flex格式化上下文</h1><p>当 display 的值为 flex 或 inline-flex 时，将生成弹性容器（Flex Containers）。</p>
<p>一个弹性容器为其内容建立了一个新的弹性格式化上下文环境（FFC）。</p>
<p>值得注意的是，弹性容器不是块容器，下列适用于块布局的属性不适用于弹性布局：</p>
<ol>
<li><p>在 CSS3 多列布局模块中定义的 column-* 属性不适用于弹性容器。</p>
</li>
<li><p>float 和 clear 属性对于弹性项没有作用，并不会把它带离文档流（或相反）。然而，浮动属性仍然会通过影响 display 属性的计算值而影响 box 的生成。</p>
</li>
<li><p>vertical-align 属性对于弹性项没有作用。</p>
</li>
<li><p>::first-line 和 ::first-letter 伪元素不适用于弹性容器，而且弹性容器不为他们的祖先提供第一个格式化的行或第一个字母。</p>
</li>
</ol>
<h1 id="GFC（Grid-Formatting-Contexts）栅格格式化上下文"><a href="#GFC（Grid-Formatting-Contexts）栅格格式化上下文" class="headerlink" title="GFC（Grid Formatting Contexts）栅格格式化上下文"></a>GFC（Grid Formatting Contexts）栅格格式化上下文</h1><p>display: grid。</p>
<p>大漠老师教程马克：<code>https://www.w3cplus.com/blog/tags/355.html</code>。</p>
<h1 id="css选择器以及优先级"><a href="#css选择器以及优先级" class="headerlink" title="css选择器以及优先级"></a>css选择器以及优先级</h1><p>优先级从上往下递减。</p>
<ol>
<li><p>!important<br> 在属性后面写上这条样式，会覆盖掉页面上任何位置定义的元素的样式。</p>
</li>
<li><p>行内样式（1000），在style属性里面写的样式。</p>
</li>
<li><p>id选择器（100）    #box</p>
</li>
<li><p>class选择器和伪类选择器（10）.class{}</p>
</li>
<li><p>标签选择器（1）    p ul li</p>
</li>
<li><p>通配符选择器（0）*{}</p>
</li>
<li><p>浏览器的自定义属性和继承</p>
</li>
</ol>
<h1 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h1><p><strong>伪类包含两种：状态伪类和结构性伪类。</strong> </p>
<h2 id="状态伪类是基于元素当前状态进行选择的。在与用户的交互过程中元素的状态是动态变化的，因此该元素会根据其状态呈现不同的样式。当元素处于某状态时会呈现该样式，而进入另一状态后，该样式也会失去。常见的状态伪类主要包括："><a href="#状态伪类是基于元素当前状态进行选择的。在与用户的交互过程中元素的状态是动态变化的，因此该元素会根据其状态呈现不同的样式。当元素处于某状态时会呈现该样式，而进入另一状态后，该样式也会失去。常见的状态伪类主要包括：" class="headerlink" title="状态伪类是基于元素当前状态进行选择的。在与用户的交互过程中元素的状态是动态变化的，因此该元素会根据其状态呈现不同的样式。当元素处于某状态时会呈现该样式，而进入另一状态后，该样式也会失去。常见的状态伪类主要包括："></a>状态伪类是基于元素当前状态进行选择的。在与用户的交互过程中元素的状态是动态变化的，因此该元素会根据其状态呈现不同的样式。当元素处于某状态时会呈现该样式，而进入另一状态后，该样式也会失去。常见的状态伪类主要包括：</h2><p>:link 应用于未被访问过的链接</p>
<p>:hover 应用于鼠标悬停到的元素</p>
<p>:active 应用于被激活的元素</p>
<p>:visited 应用于被访问过的链接，与:link互斥</p>
<p>:focus 应用于拥有键盘输入焦点的元素（比如输入框）</p>
<p>p:nth-child(2){} 规定属于其父元素的第二个子元素的每个 p 的背景色<br>PS: odd 和 even 是可用于匹配下标是奇数或偶数的子元素的关键词（第一个子元素的下标是 1）。</p>
<h2 id="结构性伪类是css3新增选择器，利用dom树进行元素过滤，通过文档结构的互相关系来匹配元素，能够减少class和id属性的定义，使文档结构更简洁。常见的包括："><a href="#结构性伪类是css3新增选择器，利用dom树进行元素过滤，通过文档结构的互相关系来匹配元素，能够减少class和id属性的定义，使文档结构更简洁。常见的包括：" class="headerlink" title="结构性伪类是css3新增选择器，利用dom树进行元素过滤，通过文档结构的互相关系来匹配元素，能够减少class和id属性的定义，使文档结构更简洁。常见的包括："></a>结构性伪类是css3新增选择器，利用dom树进行元素过滤，通过文档结构的互相关系来匹配元素，能够减少class和id属性的定义，使文档结构更简洁。常见的包括：</h2><p>:first-child 选择某个元素的第一个子元素；</p>
<p>:last-child 选择某个元素的最后一个子元素；</p>
<p>:first-of-type 选择一个上级元素下的第一个同类子元素；</p>
<p>:last-of-type 选择一个上级元素的最后一个同类子元素；</p>
<p>等等。。。</p>
<p><strong>伪元素的本质是在不增加dom结构的基础上添加的一个元素，在用法上跟真正的dom无本质区别。普通元素能实现的效果，伪元素都可以。有些用伪元素效果更好，代码更精简。</strong> </p>
<p>一般使用单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素</p>
<p>最常见的应用场景就是清除浮动了</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span>:after &#123;</span><br><span class="line">    content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">	  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">	  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="css3新增的其他伪类"><a href="#css3新增的其他伪类" class="headerlink" title="css3新增的其他伪类"></a>css3新增的其他伪类</h2><p>:after 在元素之后添加内容，也可以用来清除浮动</p>
<p>:before 在元素之前添加内容</p>
<p>:enabled 已经启用的表单元素</p>
<p>:disabled 已经禁用的表单元素</p>
<p>:checked 单选框或复选框被选中</p>
<h1 id="css有哪些属性是可以继承的？"><a href="#css有哪些属性是可以继承的？" class="headerlink" title="css有哪些属性是可以继承的？"></a>css有哪些属性是可以继承的？</h1><ol>
<li>字体系列</li>
</ol>
<ul>
<li>font-family：字体系列</li>
<li>font-weight：字体的粗细</li>
<li>font-size：字体的大小</li>
<li>font-style：字体的风格</li>
</ul>
<ol start="2">
<li>文本系列属性</li>
</ol>
<ul>
<li>text-indent：文本缩进</li>
<li>text-align：文本水平对齐</li>
<li>line-height：行高</li>
<li>word-spacing：单词之间的间距</li>
<li>letter-spacing：中文或者字母之间的间距</li>
<li>text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</li>
<li>color：文本颜色</li>
</ul>
<ol start="3">
<li>元素可见性</li>
</ol>
<ul>
<li>visibility：控制元素显示隐藏</li>
</ul>
<ol start="4">
<li><p>list-style：列表风格，包括list-style-type、list-style-image等</p>
</li>
<li><p>光标属性：cursor：光标显示为何种形态</p>
</li>
</ol>
<h1 id="CSS中哪些是不可继承的？"><a href="#CSS中哪些是不可继承的？" class="headerlink" title="CSS中哪些是不可继承的？"></a>CSS中哪些是不可继承的？</h1><ol>
<li><p>display属性。</p>
</li>
<li><p>文本属性。</p>
</li>
</ol>
<ul>
<li>vertical-align：垂直文本对齐。</li>
<li>text-decoration：规定添加到文本的装饰。</li>
<li>text-shadow：文本阴影效果。</li>
<li>white-space：空白符的处理。</li>
<li>unicode-bidi：设置文本的方向。</li>
</ul>
<ol start="3">
<li>盒子模型属性</li>
</ol>
<p>width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left</p>
<ol start="4">
<li>背景属性：</li>
</ol>
<p>background、background-color、background-image、background-repeat、background-position、background-attachment</p>
<ol start="5">
<li>定位属性：</li>
</ol>
<p>float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index<br>等等。。。。</p>
<h1 id="块级元素和行内元素"><a href="#块级元素和行内元素" class="headerlink" title="块级元素和行内元素"></a>块级元素和行内元素</h1><ol>
<li>块级元素，独占一行，会自动填满父元素，并且可以设置margin和padding以及宽度和高度(前后有换行符)</li>
</ol>
<p>p div hn form table ul li ol dl</p>
<ol start="2">
<li>行内元素，不会独占一行，并且宽度和高度会失效，垂直方向的padding和margin会失效(前后无换行符)</li>
</ol>
<p>span a b input img i textarea select </p>
<ol start="3">
<li>行内块级元素，能设置宽度和高度，padding和margin水平垂直方向都有效(前后没有换行符)</li>
</ol>
<h1 id="居中为什么要使用transform（为什么不使用marginLeft-Top）"><a href="#居中为什么要使用transform（为什么不使用marginLeft-Top）" class="headerlink" title="居中为什么要使用transform（为什么不使用marginLeft/Top）"></a>居中为什么要使用transform（为什么不使用marginLeft/Top）</h1><p>可以简单的这样理解，浏览器渲染的图层一般包含两大类：普通图层(默认复合图层)以及复合图层</p>
<p>可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</p>
<p>transform是通过创建一个RenderLayers合成层，它所引起的paint也只是发生在单独的GraphicsLayer中，<strong>并不会引起整个页面的回流重绘。</strong></p>
<p>层创立的条件如下：</p>
<ul>
<li>video元素的层</li>
<li>canvas元素的层</li>
<li>flash</li>
<li>对opacity和transform应用了CSS动画的层</li>
<li>transform:translateZ(0)</li>
<li>will-change: transform(对于接下来要做transform操作浏览器会为其新建一个图层)</li>
<li>position: fixed</li>
</ul>
<p>除此之外，在硬件加速体系结构，合成由GPU负责。在chrome浏览器多进程模型中，有一个专门的进程来负责传递Render进程的命令，即GPU进程。</p>
<p>Render进程和GPU进程是通过共享内存传递的。Render进程可以快速 的将命令发给命令缓冲区，并且返回到CPU密集的render活动中，留给GPU进程去处理这些命令。我们可以充分利用多内核机器上的GPU进程和CPU进程。这也是为什么GPU硬件加速会加速渲染，使transform渲染速度更快的又一原因。但是会占用一定的内存。</p>
<p>对元素进行动画的一些要点:</p>
<ul>
<li>尽量使用keyframes和transform进行动画，这样浏览器会自身分配每帧的长度，并作出优化</li>
<li>如果非要使用js来进行动画，使用requestAnimationFrame</li>
<li>使用2d transform而不是改变top/left的值，这样会有更短的repaint时间和更圆滑的动画效果</li>
<li>移动端的动画效果可能会比pc端的差，因此一定要注意性能优化，尽量减少动画元素的DOM复杂性，待动画结束后异步执行DOM操作。</li>
</ul>
<p>在实际开发的过程中，也应该对gif 动态图片新建立一个图层，但是图层太多，会导致页面耗费大量时间绘制图层，从而影响页面性能。所以必须平衡使用图层进行优化前后的方案，可以使用chrome 的performance 工具进行前后性能的对比。</p>
<h1 id="层叠等级和层叠上下文"><a href="#层叠等级和层叠上下文" class="headerlink" title="层叠等级和层叠上下文"></a>层叠等级和层叠上下文</h1><h2 id="层叠上下文-stacking-context"><a href="#层叠上下文-stacking-context" class="headerlink" title="层叠上下文(stacking context)"></a>层叠上下文(stacking context)</h2><p>HTML中一个三维的概念。在CSS2.1规范中，每个盒模型的位置是三维的，分别是平面画布上的X轴，Y轴以及表示层叠的Z轴。</p>
<p>一般情况下，元素在页面上沿X轴Y轴平铺，我们察觉不到它们在Z轴上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。</p>
<p>如果一个元素含有层叠上下文，(也就是说它是层叠上下文元素)，我们可以理解为这个元素在Z轴上就“高人一等”，最终表现就是它离屏幕观察者更近。</p>
<h2 id="层叠等级"><a href="#层叠等级" class="headerlink" title="层叠等级"></a>层叠等级</h2><p>层叠等级(stacking level，叫“层叠级别”/“层叠水平”也行)</p>
<ul>
<li><p>在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在Z轴上的上下顺序。</p>
</li>
<li><p>在其他普通元素中，它描述定义的是这些普通元素在Z轴上的上下顺序。</p>
</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol>
<li><p>普通元素的层叠等级优先由其所在的层叠上下文决定。</p>
</li>
<li><p>层叠等级的比较只有在当前层叠上下文元素中才有意义。不同层叠上下文中比较层叠等级是没有意义的。</p>
</li>
</ol>
<p>关键问题，如何产生层叠上下文？</p>
<p>其实，层叠上下文也基本上是有一些特定的CSS属性创建的，一般有3种方法</p>
<ul>
<li>HTML中的根元素本身就具有层叠上下文，称为“根层叠上下文”。</li>
<li>普通元素设置position属性为非static值并设置z-index属性为具体数值，产生层叠上下文。</li>
<li>CSS3中的新属性也可以产生层叠上下文。(opacity属性值不是1;元素的transform属性值不是none)</li>
</ul>
<p>举个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .box1 &#123;</span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">2</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .box2 &#123;</span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .a &#123;</span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">100</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .b &#123;</span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">200</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  .c &#123;</span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: -<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">9999</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;c&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/z-index.png" alt="markdown"></p>
<p>虽然p.c元素的z-index值为9999，远大于p.a和p.b的z-index值，但是由于p.a、p.b的父元素div.box1产生的层叠上下文的z-index的值为2，p.c的父元素div.box2所产生的层叠上下<br>文的z-index值为1，所以p.c永远在p.a和p.b下面。<br>同时，如果我们只更改p.a和p.b的z-index值，由于这两个元素都在父元素div.box1产生的层叠上下文中，所以，谁的z-index值大，谁在上面。</p>
<p><strong>z-index 层级(仅能在定位元素上奏效，就是该元素的定位值为relative、absolute、或者fixed)。</strong></p>
<h2 id="层叠顺序"><a href="#层叠顺序" class="headerlink" title="层叠顺序"></a>层叠顺序</h2><p>在不考虑CSS3的情况下，当元素发生层叠时，层叠顺讯遵循下面图·中的规则</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/z-indexRules.png" alt="markdown"></p>
<h1 id="display-none-和-visibility-hidden-以及-opacity-0-的区别"><a href="#display-none-和-visibility-hidden-以及-opacity-0-的区别" class="headerlink" title="display:none 和 visibility:hidden 以及 opacity:0 的区别"></a>display:none 和 visibility:hidden 以及 opacity:0 的区别</h1><ol>
<li>空间占据</li>
</ol>
<p>display:none隐藏后不占据额外空间，它会产生回流和重绘，而visibility:hidden和opacity:0元素虽然隐藏了，但它们仍然占据着空间，它们俩只会引起页面重绘。</p>
<ol start="2">
<li>子元素继承</li>
</ol>
<ul>
<li><p>display:none不会被子元素继承，但是父元素都不在了，子元素自然也就不会显示了</p>
</li>
<li><p>visibility:hidden 会被子元素继承，可以通过设置子元素visibility:visible 使子元素显示出来</p>
</li>
<li><p>opacity: 0 也会被子元素继承，但是不能通过设置子元素opacity: 0使其重新显示</p>
</li>
</ul>
<ol start="3">
<li>事件绑定</li>
</ol>
<ul>
<li><p>display:none 的元素都已经不再页面存在了，因此肯定也无法触发它上面绑定的事件</p>
</li>
<li><p>visibility:hidden 元素上绑定的事件也无法触发</p>
</li>
<li><p>opacity: 0元素上面绑定的事件是可以触发的</p>
</li>
</ul>
<ol start="4">
<li>过渡动画</li>
</ol>
<ul>
<li><p>transition对于display肯定是无效的</p>
</li>
<li><p>transition对于visibility也是无效的</p>
</li>
<li><p>transition对于opacity是有效</p>
</li>
</ul>
<h1 id="display的值"><a href="#display的值" class="headerlink" title="display的值"></a>display的值</h1><p>inherit(继承父元素的display的值)        initial(初始值)</p>
<p>block    inline    none    flex    inline-block    inline-flex        inline-grid        inlie-table</p>
<p>grid    table    table-cell    table-caption    table-column    table-row    table-column-group    table-footer-group    table-header-group</p>
<p>等等。。</p>
<h1 id="网页制作用到的图片格式"><a href="#网页制作用到的图片格式" class="headerlink" title="网页制作用到的图片格式"></a>网页制作用到的图片格式</h1><h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><ol>
<li><p>位图又叫做点阵图，是一个个很小的颜色小方块组合在一起的图片。一个小方块代表 1px（像素）。我们的手机屏幕和电脑屏幕也都是由很多个像素方块组成的</p>
</li>
<li><p>常见的位图设计软件有 Photoshop(PS)\LR 等；常见的位图图片格式有 JPG、PNG、Bmp 等。所有位图图片都可以使用 PS 进行修改设计。在 PS 中把图片放大1600倍后，就可以看到一个个的像素点。类似马赛克的效果</p>
</li>
</ol>
<h2 id="矢量图"><a href="#矢量图" class="headerlink" title="矢量图"></a>矢量图</h2><p>矢量图是由<strong>一个个点链接在一起组成的，是根据几何特性来绘制的图像，和位图的分辨率是没有关系的</strong>。因此图片放大后也不会失真，不会出现位图的马赛克的样子，也就是说可以无限放大图片。下图是用 AI 软件中放大6400倍的矢量图，依然很清晰</p>
<h2 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h2><ol>
<li><p>png：支持 256 色调色板，静态图片，支持 alpha 透明度，无动画，适用图标、背景、按钮</p>
</li>
<li><p>GIF：多达256种的颜色，动态图片，适合简单动画</p>
</li>
<li><p>jpg：静态图片</p>
</li>
<li><p>WebP 格式，谷歌（google）新推出的影像技术，它可让网页图档有效进行压缩，同时又不影响图片格式兼容与实际清晰度，进而让整体网页下载速度加快 。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%，但是缺点是兼容性较差</p>
</li>
<li><p>apng 格式，说到动图，大家首先想到的肯定是 GIF。但 GIF 最大的缺点是，图像是基于颜色列表的（存储的数据是该点的颜色对应于颜色列表的索引值），最多只支持 8 位（256 色）。这使得使用 GIF 格式不可能得到高清的动画图片。<strong>而 apng 是位图动画的拓展，可以实现 png 格式的动态图片效果</strong>，有望代替 gif 成为下一代动态图的标准</p>
</li>
</ol>
<ul>
<li>支持 24 位真彩色图片</li>
<li>支持 8 位 Alpha 透明通道</li>
<li>向下兼容 PNG</li>
</ul>
<h2 id="其他图片知识"><a href="#其他图片知识" class="headerlink" title="其他图片知识"></a>其他图片知识</h2><ol>
<li>雪碧图</li>
</ol>
<p>优点：</p>
<ul>
<li>减少 HTTP 请求数，极大地提高页面加载速度</li>
<li>增加图片信息的重复度，提高压缩比，减少图片大小</li>
</ul>
<p>缺点：</p>
<ul>
<li>图片合并麻烦</li>
<li>维护麻烦，修改一个图片可能需要重新布局整个图片、样式</li>
</ul>
<ol start="2">
<li>base64 格式图片（在webpack 中可以使用 url-loader 进行图片打包）</li>
</ol>
<p>优点：可以加密，减少 http 请求，适用于小图片（20kb左右），体积约为原图的4/3，一般比源文件大 30% 左右。</p>
<p>缺点：需要消耗cpu 进行编解码</p>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5a4dbe026fb9a0452207ebe6">什么是BFC?</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/59b73d5bf265da064618731d">学习 BFC (Block Formatting Context)</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/54b000099217">css BEM</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903649605320711">CSS性能优化的8个技巧</a><br><a target="_blank" rel="noopener" href="https://github.com/chokcoco/iCSS/issues/56">谈谈一些有趣的CSS题目（11）– IFC、BFC、GFC 与 FFC 知多少</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/20/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/%E6%89%8B%E6%92%95Ajax/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/20/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/%E6%89%8B%E6%92%95Ajax/" class="post-title-link" itemprop="url">手撕Ajax</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-20 20:52:25" itemprop="dateCreated datePublished" datetime="2019-04-20T20:52:25+08:00">2019-04-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Ajax/" itemprop="url" rel="index"><span itemprop="name">Ajax</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="实现原生的AJAX通信"><a href="#实现原生的AJAX通信" class="headerlink" title="实现原生的AJAX通信"></a>实现原生的AJAX通信</h1><p>原生ajax请求</p>
<p>XMLHttpRequest 对象<br>XMLHttpRequest对象是ajax的基础,XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。目前所有浏览器都支持XMLHttpRequest。</p>
<p>onreadystatechange  每次状态改变所触发事件的事件。<br>responseText  从服务器接收到的响应体（不包括头部），或者如果还没有接收到数据的话，就是空字符串。<br>responseXML  对请求的响应，解析为 XML 并作为 Document 对象返回。<br>status  从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）<br>status Text   请求的 HTTP 的状态代码</p>
<p>readyState   HTTP 请求的状态.当一个 XMLHttpRequest 初次创建时，这个属性的值从 0 开始，直到接收到完整的 HTTP 响应，这个值增加到 4。</p>
<ul>
<li>0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）</li>
<li>1 (初始化) 对象已建立，尚未调用send方法</li>
<li>2 (发送数据) send方法已调用，但是当前的状态及http头未知</li>
<li>3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误</li>
<li>4 (完成) 数据接收完毕,此时可以通过responseXml和responseText获取完整的回应数据</li>
</ul>
<p>手撕原生Ajax完整版代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ajax = <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Ajax的核心对象，并且兼容IE低版本浏览器</span></span><br><span class="line">   <span class="keyword">var</span> xhr = XMLHttpRequest ? <span class="keyword">new</span> XMLHttpRequest() : <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">   <span class="comment">//对传入的值进行前期处理，包括type/url/data，将type值转换为大写</span></span><br><span class="line">   <span class="keyword">var</span> type = (param.type || <span class="string">&#x27;get&#x27;</span>).toUpperCase();</span><br><span class="line">   <span class="keyword">var</span> url = param.url;</span><br><span class="line">   <span class="keyword">if</span> (!url) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> data = param.data,</span><br><span class="line">       dataArr = [];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">      dataArr.push(k + <span class="string">&#x27;=&#x27;</span> + data[k]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//为了避免取得的是缓存数据，为其添加一个唯一的id</span></span><br><span class="line">   dataArr.push(<span class="string">&#x27;_=&#x27;</span> + <span class="built_in">Math</span>.random());</span><br><span class="line">   <span class="comment">//get还是post。url处理，open()。send()</span></span><br><span class="line">   <span class="keyword">if</span> (type == <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">      url = url + <span class="string">&#x27;?&#x27;</span> + dataArr.join(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">      xhr.open(type, url);</span><br><span class="line">      xhr.send();</span><br><span class="line">   &#125; <span class="keyword">else</span> (type == <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">     xhr.open(type, url);</span><br><span class="line">     <span class="comment">//像表单一样post数据，使用setRequestHeader来添加头部</span></span><br><span class="line">     xmlhttp.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">     xhr.send(dataArr.join(<span class="string">&#x27;&amp;&#x27;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//接收请求</span></span><br><span class="line">   xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">//成功</span></span><br><span class="line">   <span class="keyword">if</span> (xhr.status == <span class="number">200</span> || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> res;</span><br><span class="line">      <span class="keyword">if</span> (param.success &amp;&amp; param.success <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">          <span class="comment">//获取字符串形式的响应数据</span></span><br><span class="line">         res = xhr.responseText;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">typeof</span> res === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">             <span class="comment">//把字符串形式转换成JSON形式</span></span><br><span class="line">            res = <span class="built_in">JSON</span>.parse(res);</span><br><span class="line">            param.success.call(xhr, res);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//失败</span></span><br><span class="line">			<span class="keyword">if</span>(param.error &amp;&amp; param.error instanceOf <span class="built_in">Function</span>)&#123;</span><br><span class="line">				param.error.call(xhr,res);</span><br><span class="line">			&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法的使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//这个是ajax的get跟post请求demo</span></span><br><span class="line">    ajax(&#123;</span><br><span class="line">        type: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">        url: <span class="string">&#x27;http://127.0.0.1:3000/ajax&#x27;</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            name: <span class="string">&#x27;jgchen&#x27;</span>,</span><br><span class="line">            stuNo: <span class="number">2016130201</span>,</span><br><span class="line">            method: <span class="string">&#x27;post&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">success</span>(<span class="params">res</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;POST success:&#x27;</span>,res);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">error</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    ajax(&#123;</span><br><span class="line">        type: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        url: <span class="string">&#x27;http://127.0.0.1:3000/ajax&#x27;</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            name: <span class="string">&#x27;jgchen&#x27;</span>,</span><br><span class="line">            stuNo: <span class="number">2016130201</span>,</span><br><span class="line">            method: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">success</span>(<span class="params">res</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;GET success:&#x27;</span>,res);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">error</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<p>get请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤一:创建异步对象</span></span><br><span class="line">    <span class="keyword">var</span> ajax = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">//步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数starName到服务端</span></span><br><span class="line">    ajax.open(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;getStar.php?starName=&#x27;</span>+name);</span><br><span class="line"><span class="comment">//步骤三:发送请求</span></span><br><span class="line">    ajax.send();</span><br><span class="line"><span class="comment">//步骤四:注册事件 onreadystatechange 状态改变就会调用</span></span><br><span class="line">    ajax.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ajax.readyState==<span class="number">4</span> &amp;&amp;ajax.status==<span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">//步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的</span></span><br><span class="line">　　　　<span class="built_in">console</span>.log(ajax.responseText);<span class="comment">//输入相应的内容</span></span><br><span class="line">  　　    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>post请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建异步对象  </span></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">//设置请求的类型及url，必须要先open才能继续下一步</span></span><br><span class="line">	xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;02.post.php&#x27;</span> );</span><br><span class="line"><span class="comment">//post请求一定要添加请求头才行不然会报错</span></span><br><span class="line">	xhr.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">	xhr.send(<span class="string">&#x27;name=fox&amp;age=18&#x27;</span>);</span><br><span class="line">	xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这步为判断服务器是否正确响应</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>参考文章：<br><a target="_blank" rel="noopener" href="https://juejin.im/post/5d007134e51d45590a445b23">终于明白如何去写原生AJAX</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006669043">聊聊Ajax那些事</a> </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/13/ES6/ES6%E6%96%B0%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83%E5%B8%B8%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/13/ES6/ES6%E6%96%B0%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83%E5%B8%B8%E7%94%A8/" class="post-title-link" itemprop="url">ES6新特性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-13 23:06:21" itemprop="dateCreated datePublished" datetime="2019-04-13T23:06:21+08:00">2019-04-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="关键字let和const"><a href="#关键字let和const" class="headerlink" title="关键字let和const"></a>关键字<strong>let</strong>和<strong>const</strong></h1><h2 id="let关键字的使用"><a href="#let关键字的使用" class="headerlink" title="let关键字的使用"></a>let关键字的使用</h2><p>let声明的变量只在let命令所在的<strong>代码块内有效，是块级作用域的前提，不允许重复声明，不存在变量提升，存在暂时性死区</strong>（加粗的是let和const的相同点）。<br>PS：暂时性死区的本质是，只要进入当前作用域，所要使用的变量就已经存在但是不可获取，只有等到变量声明的那一行代码出现，才可以获取和操作该变量。</p>
<p>const声明一个只读的常量，一旦声明，常量的值就不能改变，所以声明的时候必须初始化，同时也不存在变量提升。<br>let的基本用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);   <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">// 报错 ReferenceError: a is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(b);<span class="comment">//  1 </span></span><br><span class="line"><span class="comment">//=========&gt;分割线</span></span><br><span class="line"><span class="comment">//let只能声明一次，而var可以声明多次，所以for的循环计时器适合用let</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Identifier &#x27;a&#x27; has already been declared</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>举一个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出十个 10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出0到9</span></span><br></pre></td></tr></table></figure>

<p>var声明的变量在全局范围内只有一个变量i，循环里的十个 setTimeout 是在循环结束后才执行，用于计数的变量泄露成为全局变量，所以此时的 i 都是 10；<br>变量 j 是用 let 声明的，当前的 j 只在本轮循环中有效，每次循环的 j 其实都是一个新的变量，所以 setTimeout 定时器里面的 j 其实是不同的变量，即最后输出0123456789。（JS引擎内部会记住前一次循环的值），所以这与JS的运行机制并不冲突。</p>
<p>注意点：使用let声明变量。并不存<strong>在变量提升</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//ReferenceError: a is not defined</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;banana&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="const关键字的使用"><a href="#const关键字的使用" class="headerlink" title="const关键字的使用"></a>const关键字的使用</h2><p>const 声明一个只读变量，声明之后不允许改变。意味着，一但声明<strong>必须初始化</strong>，否则会报错。但是如果是一个对象，可以改变对象里面属性值。</p>
<p><strong>const使用的注意点：</strong><br><strong>其实 const保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动</strong>。但是简单类型和复合类型保存值的方式是不同的。对于简单类型（数值 number、字符串 string 、布尔值 boolean）,值就保存在变量指向的那个内存地址，因此 const 声明的简单类型变量等同于常量。而复杂类型（对象 object，数组 array，函数 function），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能<strong>保证指针是固定</strong>的，至于指针指向的数据结构则无法来控制了，所以使用 const 声明复杂类型对象时要慎重。</p>
<p>在 ES6 快速入门中，对于 let 和 const ，建议优先选择 const，尤其是在全局环境中，不应该设置变量，只应设置常量</p>
<ul>
<li>const 可以提醒阅读程序的人，这个变量不应该改变</li>
<li>const 比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算</li>
<li>JavaScript 的编译器会对const 进行优化，所以多使用 const 有利于提高程序的运行效率</li>
</ul>
<h2 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h2><p>ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。</p>
<h1 id="ES6-提供了对函数的扩展"><a href="#ES6-提供了对函数的扩展" class="headerlink" title="ES6 提供了对函数的扩展"></a>ES6 提供了对函数的扩展</h1><h2 id="ES6为参数提供了默认值"><a href="#ES6为参数提供了默认值" class="headerlink" title="ES6为参数提供了默认值"></a>ES6为参数<strong>提供了默认值</strong></h2><p>在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">a,b=<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a+b);</span><br><span class="line">&#125;</span><br><span class="line">A(<span class="number">1</span>);    <span class="comment">//2</span></span><br><span class="line">A(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>在es6中，提供了一种简洁的函数写法，我们称作“箭头函数”。</p>
<p>写法：函数名=(形参)=&gt;{……}     当函数体中只有一个表达式时，{}和return可以省略，当函数体中形参只有一个时，()可以省略。所以当函数体内代码多于1行时，必须使用{}，并且使用return语句返回</p>
<p>在函数执行时，<strong>this 总是指向调用该函数的对象</strong>。要判断 this 的指向，其实就是判断 this 所在的函数属于谁</p>
<p><strong>特点：箭头函数使得this的指向固定化，this始终指向箭头函数定义时的离this最近的一个函数，如果没有最近的函数就指向window</strong></p>
<p>箭头函数的注意事项：</p>
<ol>
<li>函数体内的 this 对象就是定义时所在的对象，而不是使用是所在的对象</li>
<li>不可以单作构造函数，所以就不可以使用 new 命令，否则会抛出错误</li>
<li>不可以使用 arguments 对象，该对象在函数体内不存在。如果需要使用可以用 rest 参数代替</li>
<li>不可以使用 yield 命令，因此箭头函数不能作 Generator 函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略写法</span></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="function"><span class="params">f</span> =&gt;</span> &#123; hhh &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//es5写法</span></span><br><span class="line"><span class="keyword">var</span> f1 = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hhh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h1><h2 id="属性的简写。"><a href="#属性的简写。" class="headerlink" title="属性的简写。"></a>属性的简写。</h2><p>ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;  <span class="comment">//等同于  var baz = &#123;foo: foo&#125;;</span></span><br></pre></td></tr></table></figure>

<h2 id="方法的简写，省略冒号与function关键字"><a href="#方法的简写，省略冒号与function关键字" class="headerlink" title="方法的简写，省略冒号与function关键字"></a>方法的简写，省略冒号与function关键字</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Object-keys-方法"><a href="#Object-keys-方法" class="headerlink" title="Object.keys()方法"></a>Object.keys()方法</h2><p>获取对象的所有属性名或方法名（不包括原形的内容,for…in循环遍历出原型对象的属性，可以使用hasOwnProperty()判断），返回一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">name</span>: <span class="string">&quot;john&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;21&quot;</span>, <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="built_in">this</span>.name)&#125;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj));    <span class="comment">// [&quot;name&quot;, &quot;age&quot;, &quot;getName&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj).length);    <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys([<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>]));    <span class="comment">//[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(<span class="string">&quot;abcdef&quot;</span>));    <span class="comment">//[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-values-方法"><a href="#Object-values-方法" class="headerlink" title="Object.values()方法"></a>Object.values()方法</h2><p>获取对象的所有属性值，返回一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">name</span>: <span class="string">&quot;john&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;21&quot;</span>, <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="built_in">this</span>.name)&#125;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj))    <span class="comment">// [&quot;john&quot;, &quot;21&quot;, ƒ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj).length)    <span class="comment">//  3</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h2><p>将对象的属性名和属性值作为一个数组的两个元素，插入到另一个空数组中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;james&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sex: <span class="string">&#x27;man&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> man = <span class="built_in">Object</span>.entries(person)</span><br><span class="line"><span class="built_in">console</span>.log(man)  <span class="comment">// [[&#x27;name&#x27;,&#x27;james&#x27;],[&#x27;age&#x27;,18],[&#x27;sex&#x27;,&#x27;man&#x27;]]</span></span><br></pre></td></tr></table></figure>

<h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of  循环"></a>for…of  循环</h2><p>是遍历所有数据结构的统一的方法。for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator 对象，以及字符串。(因为对象没有Iterator接口，所以无法被遍历)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="string">&quot;小林&quot;</span>,<span class="string">&quot;小吴&quot;</span>,<span class="string">&quot;小佳&quot;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> v <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小林 </span></span><br><span class="line"><span class="comment">//小吴 </span></span><br><span class="line"><span class="comment">//小佳</span></span><br></pre></td></tr></table></figure>

<p>PS:其他循环</p>
<h3 id="for…in-循环"><a href="#for…in-循环" class="headerlink" title="for…in 循环"></a>for…in 循环</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123; <span class="comment">// 实际代码中不要这么做，使用for...of循环更合适</span></span><br><span class="line">  <span class="built_in">console</span>.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。如果你使用字符串的 index 去参与某些运算（”2” + 1 == “21”），运算结果可能会不符合预期。</p>
</li>
<li><p>for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。(比如继承关系的时候，就有些麻烦了，遍历的时候会把继承的属性也遍历出来)</p>
</li>
<li><p>某些情况下，for…in循环会以任意顺序遍历键名。</p>
</li>
<li><p>总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组。</p>
</li>
</ul>
<p>PS:如何解决for…in循环遍历出原型对象的属性。使用hasOwnProperty()判断</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Animal()</span><br><span class="line">Animal.prototype.height = <span class="number">99</span></span><br><span class="line">dog.weight = <span class="number">18</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> dog)&#123;</span><br><span class="line">  <span class="keyword">if</span>(dog.hasOwnProperty(item))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//name</span></span><br><span class="line"><span class="comment">//age</span></span><br><span class="line"><span class="comment">//weight,而height是原型对象上的属性，所以不会输出</span></span><br></pre></td></tr></table></figure>

<h3 id="forEach循环"><a href="#forEach循环" class="headerlink" title="forEach循环"></a>forEach循环</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">myArray.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item,index,arr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item,index,arr)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种写法的问题在于，无法中途跳出forEach循环，break命令也不能用return语句从闭包函数中返回，所以没有返回值</p>
<h1 id="模块化的支持"><a href="#模块化的支持" class="headerlink" title="模块化的支持"></a>模块化的支持</h1><p>ES6标准中，JavaScript原生支持模块(module)了。这种将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用。</p>
<p>export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口。</p>
<p>import用于在一个模块中加载另一个含有export接口的模块。</p>
<p>import和export命令只能在模块的顶部，不能在代码块之中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入部分</span></span><br><span class="line"><span class="comment">//全部导入</span></span><br><span class="line"><span class="keyword">import</span> Person <span class="keyword">from</span> <span class="string">&#x27;./example&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//将整个模块所有导出内容当做单一对象，用as起别名</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> example <span class="keyword">from</span> <span class="string">&quot;./example.js&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(example.name)</span><br><span class="line"><span class="built_in">console</span>.log(example.getName())</span><br><span class="line"> </span><br><span class="line"><span class="comment">//导入部分</span></span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;./example&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//导出部分</span></span><br><span class="line"><span class="comment">// 导出默认</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 部分导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="title">extend</span> <span class="title">Component</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="五、模板字符串"><a href="#五、模板字符串" class="headerlink" title="五、模板字符串"></a>五、模板字符串</h2><p>所有的空格和缩进都会被保留在输出之中。。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果说不想要换行，就可以使用trim方法去除空格和换行</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">&#x27;#list&#x27;</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>.trim())</span><br></pre></td></tr></table></figure>

<h1 id="新增-symbol-基础数据类型"><a href="#新增-symbol-基础数据类型" class="headerlink" title="新增 symbol 基础数据类型"></a>新增 symbol 基础数据类型</h1><p>JS中的数据类型分为基本数据类型还有复杂数据类型(引用数据类型)</p>
<p>复杂数据类型：object、function、array、date、基本包装类、内置对象（存放在堆中）<br>基本数据类型：字符串、数字、布尔值、null和undefined。ES6引入了第6种——Symbol（存放栈中）</p>
<p>PS：两种类型的区别是：存储位置不同</p>
<p>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</p>
<p>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/dizhi.png" alt="markdown"></p>
<p>Symbol功能类似于一种标识唯一性的ID</p>
<p>ES5的对象属性名都是字符串，很容易造成属性名冲突。比如，使用了一个他人提供的对象，想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的，这样就从根本上防止了属性名冲突。这就是ES6引入Symbol的原因，防止某一个键被不小心改写或覆盖</p>
<p>通常情况下，我们可以通过调用Symbol()函数来创建一个Symbol实例。</p>
<p>Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()   <span class="comment">//symbol</span></span><br><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>(<span class="string">&quot;first name&quot;</span>)    <span class="comment">//Symbol函数接受一个可选参数，可以添加一段文本来描述即将创建的Symbol，这段描述不可用于属性访问，但是建议在每次创建Symbol时都添加这样一段描述，以便于阅读代码和调试Symbol程序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(person, &#123;</span><br><span class="line">    [firstName]: &#123;</span><br><span class="line">        value: <span class="string">&quot;match&quot;</span>,</span><br><span class="line">        writable: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)                                <span class="comment">// 让该属性变为只读</span></span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>使用Symbol来替代常量</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> TYPE_AUDIO = <span class="string">&#x27;AUDIO&#x27;</span></span><br><span class="line"><span class="keyword">const</span> TYPE_VIDEO = <span class="string">&#x27;VIDEO&#x27;</span></span><br><span class="line"><span class="keyword">const</span> TYPE_IMAGE = <span class="string">&#x27;IMAGE&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用Symbol，就不必一直为起变量的名字头疼了。一下这样定义就可以保证三个变量是完全独一无二的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> TYPE_AUDIO = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> TYPE_VIDEO = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> TYPE_IMAGE = <span class="built_in">Symbol</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用Symbol定义类的私有属性/方法</li>
</ol>
<p>JavaScript中，是没有如Java等面向对象语言的访问控制关键字private的，类上所有定义的属性或方法都是可公开访问的。因此这对我们进行API的设计时造成了一些困扰。<br>有了Symbol以及模块化机制，类的私有属性和方法才变成可能。<br>新建一个a.js文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> PASSWORD = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">username, password</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.username = username</span><br><span class="line">    <span class="built_in">this</span>[PASSWORD] = password</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">checkPassword</span>(<span class="params">pwd</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>[PASSWORD] === pwd</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Login</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另建b.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> login = <span class="keyword">new</span> Login(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br><span class="line"></span><br><span class="line">login.checkPassword(<span class="string">&#x27;123456&#x27;</span>)  <span class="comment">// true</span></span><br><span class="line">login.PASSWORD  <span class="comment">// 无法访问到</span></span><br><span class="line">login[PASSWORD] <span class="comment">// 同上</span></span><br><span class="line">login[<span class="string">&quot;PASSWORD&quot;</span>] <span class="comment">// 同上</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于Symbol常量PASSWORD被定义在a.js所在的模块中，外面的模块获取不到这个Symbol，也不可能再创建一个一模一样的Symbol出来（因为Symbol是唯一的），<strong>因此这个PASSWORD的Symbol只能被限制在a.js内部使用</strong>，所以使用它来定义的类属性是没有办法被模块外访问到的，达到了一个私有化的效果。</p>
<ol start="3">
<li>注册和获取全局Symbol</li>
</ol>
<p>通常情况下，我们在一个浏览器窗口中（window），使用Symbol()函数来定义和Symbol实例就足够了。但是，如果你的应用涉及到多个window（最典型的就是页面中使用了 iframe ），并需要这些window中使用的某些Symbol是同一个，那就不能使用Symbol()函数了，因为用它在不同window中创建的Symbol实例总是唯一的，而我们需要的是在所有这些window环境下保持一个共享的Symbol。这种情况下，我们就需要使用另一个API来创建或获取Symbol，那就是**Symbol.for()**，它可以注册或获取一个window间全局的Symbol实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> gs1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;global_symbol_1&#x27;</span>)  <span class="comment">//注册一个全局Symbol</span></span><br><span class="line"><span class="keyword">let</span> gs2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;global_symbol_1&#x27;</span>)  <span class="comment">//获取全局Symbol</span></span><br><span class="line"></span><br><span class="line">gs1 === gs2  <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样一个Symbol不光在单个window中是唯一的，在多个相关window间也是唯一的了。</p>
<ol start="4">
<li>属性检索</li>
</ol>
<p>Symbol作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.getOwnPropertyNames()、Object.keys()、JSON.stringify()返回。于是，在ES6中添加了一个Object.getOwnpropertySymbols()方法来检索对象中的Symbol属性</p>
<p>Object.getOwnPropertySymbols()方法的返回值是一个包含所有Symbol自有属性的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">&quot;uid&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">    [uid]: <span class="string">&quot;12345&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> symbols = <span class="built_in">Object</span>.getOwnPropertySymbols(object)</span><br><span class="line"><span class="built_in">console</span>.log(symbols.length) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(symbols[<span class="number">0</span>]) <span class="comment">// &quot;Symbol(uid)&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(object[symbols[<span class="number">0</span>]]) <span class="comment">// &quot;12345&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="新增-set-数据类型"><a href="#新增-set-数据类型" class="headerlink" title="新增 set 数据类型"></a>新增 set 数据类型</h1><p>ES6中新增了Set数据结构，类似于数组，但是 它的成员都是唯一的 ，其构造函数可以接受一个数组作为参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(array);</span><br><span class="line"><span class="built_in">console</span>.log(set); <span class="comment">// 此时打印的是set 结构 Set(5) &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(set)); <span class="comment">//将Set结构强制转换为数组</span></span><br></pre></td></tr></table></figure>

<h1 id="新增-Map-数据"><a href="#新增-Map-数据" class="headerlink" title="新增 Map 数据"></a>新增 Map 数据</h1><p>其实数组也是集合, 只不过数组的索引是数值类型.当想用非数值类型作为索引时, 数组就无法满足需要了.</p>
<p>而 Map 集合可以保存多个键-值对(key-value), Set 集合可以保存多个元素.</p>
<p>对Map 和 Set 一般不会逐一遍历其中的元素. Map 一般用来存储需要频繁取用的数据, Set 一般用来判断某个值是否存在其中.<br>键和值都可以是任意类型。键的比较使用的是Object.is()，因此你可以将5与“5”同时作为键，因为他们类型不同。对象也可以作为 key . 这比用对象来模拟的方式就灵活了很多</p>
<ul>
<li>set(key, value): 向其中加入一个键值对</li>
<li>get(key): 若不存在 key 则返回 undefined</li>
<li>has(key):返回布尔值</li>
<li>delete(key): 删除成功则返回 true, 若key不存在或者删除失败会返回 false</li>
<li>clear(): 将全部元素清除</li>
</ul>
<p>Set是无重复值的有序列表。Set会自动移除重复的值，因此你可以使用它来过滤数组中重复的值并返回结果。<br>Map是有序的键值对，其中的键允许是任何类型。<br>Set和Map是es6新增的两个数据集合。</p>
<p>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>
<h1 id="class、extends、super"><a href="#class、extends、super" class="headerlink" title="class、extends、super"></a>class、extends、super</h1><p>这三个特性设计到ES5几个点，就是原型，继承还有多态，确实是令人挺烦的。。但那是ES6之前的事了蛤蛤。</p>
<p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;  <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">prop</span>() &#123;  <span class="comment">// 取值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;getter&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">prop</span>(<span class="params">value</span>) &#123; <span class="comment">// 存值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line">inst.prop = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"><span class="built_in">console</span>.log(inst.prop);</span><br><span class="line"><span class="comment">// &#x27;getter&#x27;</span></span><br></pre></td></tr></table></figure>

<p>extends用法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y, color</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="built_in">super</span>(x, y);</span><br><span class="line">    <span class="built_in">this</span>.color = color; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在子类的构造函数中，<strong>只有调用super之后</strong>，才可以使用this关键字，否则会报错。</p>
<p>其实 super(…) 做的事情就是绑定 this。因为在原型继承中，如果一个类要继承自另一个类，那就得先实例化一次它的父类作为作为子类的原型。如果不做这件事，子类的原型就不能确定，当然也就无法创建 this。所以如果在 constructor 中没有 super(…) 就企图获取 this 就会报错。</p>
<p>这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。父类的静态方法，也会被子类继承。</p>
<p>注意，super虽然代表了父类Point的构造函数，但是返回的是子类ColorPoint的实例，即super内部的this指的是ColorPoint，因此super()在这里相当于<strong>Point.prototype.constructor.call(this)。</strong></p>
<p>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">m</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>(); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：static 关键字解释：类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用， 这就称为“ 静态方法”。</p>
<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">122</span>,<span class="number">321</span>,<span class="number">344</span>]</span><br><span class="line"><span class="keyword">const</span> [a,b,c] = arr</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c)    <span class="comment">//122,321,344</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> [head,...tail] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"> head  <span class="comment">//1</span></span><br><span class="line"> tail  <span class="comment">//2,3,4</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> [x,y] = [<span class="string">&quot;a&quot;</span>]</span><br><span class="line"> y   <span class="comment">// undefined，如果结构不成功，那么变量的值就是undefined</span></span><br></pre></td></tr></table></figure>
<p>如果右边不是可以遍历的结构，那么将会报错。<strong>事实上只要某种数据结构具有 iterator 接口，都可以使用数组形式的解构赋值</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>并且允许指定默认值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = []</span><br><span class="line">foo <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>]</span><br><span class="line">x <span class="comment">//null，如果一个数组成员是null，那么默认值就不会生效</span></span><br></pre></td></tr></table></figure>

<h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&quot;james&quot;</span>,<span class="attr">age</span>: <span class="number">66</span>&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">name</span>:myName,age&#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(myName,age)   <span class="comment">//james 66</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值是由它的位置决定的；</span></span><br><span class="line"> <span class="comment">//而对象的属性没有次序，变量必须与属性同名才能取到正确的值</span></span><br></pre></td></tr></table></figure>

<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。如果解构失败，变量的值等于undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p>字符串的解构赋值，会使得字符串被转换成一个类似数组的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a,b,c,d,e] = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">a <span class="comment">//  &quot;h&quot;</span></span><br><span class="line">b <span class="comment">//  &quot;e&quot;</span></span><br><span class="line">c <span class="comment">//  &quot;l&quot;</span></span><br><span class="line">d <span class="comment">//  &quot;d&quot;</span></span><br><span class="line">e <span class="comment">//  &quot;o&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="解构赋值的用途"><a href="#解构赋值的用途" class="headerlink" title="解构赋值的用途"></a>解构赋值的用途</h2><ol>
<li>交换变量的值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span></span><br><span class="line">[x, y] = [y, x]    <span class="comment">//交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从函数返回多个值</li>
</ol>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>提取JSON 数据</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, &quot;OK&quot;, [867, 5309]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>遍历 Map 结构</li>
</ol>
<p>任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; is &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="尾调用和尾递归"><a href="#尾调用和尾递归" class="headerlink" title="尾调用和尾递归"></a>尾调用和尾递归</h1><h2 id="尾调用（Tail-Call）"><a href="#尾调用（Tail-Call）" class="headerlink" title="尾调用（Tail Call）"></a>尾调用（Tail Call）</h2><p>是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后一步调用并不是指在函数的尾部，只要是最后异步操作即可：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。</span></span><br><span class="line"><span class="comment">//值得注意的是，以下三种情况均不是尾调用：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = g(x);</span><br><span class="line">  <span class="keyword">return</span> y;   <span class="comment">//   尾调用之后还有操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于调用g(x)后return undefined。</p>
<h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。<br>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面是尾调用例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> b(m + n)</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br><span class="line"><span class="comment">// 上面例子实际上等同于:</span></span><br><span class="line">b(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果函数b不是尾调用，函数f就需要保存内部变量m和n的值、b的调用位置等信息。但由于调用b之后，函数a就结束了，所以执行到最后一步，完全可以删除a(x)的调用帧，只保留b(3)的调用帧。</p>
<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数(即b函数)的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<p><strong>注意，只有不再用到外层函数(函数f)的内部变量，内层函数(函数g)的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b + one;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>显而易见，上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。</p>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<h3 id="例子一：求阶乘"><a href="#例子一：求阶乘" class="headerlink" title="例子一：求阶乘"></a>例子一：求阶乘</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>让我们来理一下上面函数的顺序：<br>进入之后 由于 n !== 1 进入 return n * factorial(n - 1) 即 5 * factorial(4)<br>第二次进入 n === 4 , return 4 * factorial(3)<br>知道 n === 1, return 1出来相当于变成了 5 * 4 * 3 * 2 * 1 = 120<br>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n)(可以理解为调用帧个数) 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br><span class="line"><span class="comment">//也可以直接给total一个默认值等于1，那么调用的时候只给n赋值就可以</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里传了两个参数，第二个参数为total,我们来看一下函数的运作：<br>第一次进入：直接调用 factorial(5-1, 5 * 1) 即 factorial(4, 5)<br>第二次进入：调用 factorial(4-1, 4 * 5) 即 factorial(3, 20)<br>第三次进入：调用 factorial(3-1, 3 * 20) 即 factorial(2, 60)<br>第四次进入：调用 factorial(2-1, 2 * 60) 即 factorial(1, 120)<br>第五次进入：因为n === 1, 所以 return 120</p>
<h3 id="例子二-斐波那契数列"><a href="#例子二-斐波那契数列" class="headerlink" title="例子二:斐波那契数列"></a>例子二:斐波那契数列</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">//不使用尾递归求斐波那契数列</span></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>)</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//上面的例子由于从上到下递归，会有非常多的重复的运算，导致消耗大量的性能</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//提高性能版本</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//数列存放在数组中，第n项对应数组的第n-1个数</span></span><br><span class="line">			<span class="keyword">let</span> result = []</span><br><span class="line">			result[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">			result[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">3</span>;i &lt; n;i++)&#123;</span><br><span class="line">				result[i] = result[i-<span class="number">1</span>] + result[i-<span class="number">2</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		  <span class="keyword">return</span> result[n-<span class="number">1</span>]<span class="comment">//数列的第三项就是数组的第二项</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用ES6的尾递归提高性能</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n, num1 = <span class="number">1</span>,num2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">	 	<span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;<span class="keyword">return</span> num2&#125;</span><br><span class="line">	 	<span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>,num2,num1 + num2)</span><br><span class="line">	&#125;</span><br><span class="line">	Fibonacci(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>值得注意的是：<br><strong>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</strong></p>
<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>
<ul>
<li>func.arguments：返回调用时函数的参数。</li>
<li>func.caller：返回调用当前函数的那个函数。</li>
<li>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</li>
</ul>
<p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<h1 id="新增-Map-和-Set-数据结构"><a href="#新增-Map-和-Set-数据结构" class="headerlink" title="新增 Map 和 Set 数据结构"></a>新增 Map 和 Set 数据结构</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(map))   <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(set))    <span class="comment">//object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Set-数据结构"><a href="#Set-数据结构" class="headerlink" title="Set 数据结构"></a>Set 数据结构</h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;   <span class="comment">// 2 3 5 4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码通过add方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p>
<p>Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>
<p>利用 Set 数据结构的特性，可以实现数组的去重。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)))</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(arr)])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Set实例的属性和方法</strong></p>
<ul>
<li>Set.prototype.constructor：构造函数，默认就是Set函数。</li>
<li>Set.prototype.size：返回Set实例的成员总数。</li>
</ul>
<h3 id="Set-实例的操作方法（用于操作数据）"><a href="#Set-实例的操作方法（用于操作数据）" class="headerlink" title="Set 实例的操作方法（用于操作数据）"></a>Set 实例的操作方法（用于操作数据）</h3><ul>
<li>add(value)：添加某个值，返回 Set 结构本身。</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line"></span><br><span class="line">s.size <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.has(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">3</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s.delete(<span class="number">2</span>);</span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Set-实例的遍历方法（用于遍历成员）"><a href="#Set-实例的遍历方法（用于遍历成员）" class="headerlink" title="Set 实例的遍历方法（用于遍历成员）"></a>Set 实例的遍历方法（用于遍历成员）</h3><ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red green blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red green blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。这意味着，可以省略values方法，直接用for…of循环遍历 Set。</p>
<p>entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>
<p>foreach方法则和数组类似。</p>
<h2 id="Map-数据结构"><a href="#Map-数据结构" class="headerlink" title="Map 数据结构"></a>Map 数据结构</h2><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">p</span>: <span class="string">&#x27;Hello World&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">&#x27;content&#x27;</span>)</span><br><span class="line">m.get(o) <span class="comment">// &quot;content&quot;</span></span><br><span class="line"></span><br><span class="line">m.has(o) <span class="comment">// true</span></span><br><span class="line">m.delete(o) <span class="comment">// true</span></span><br><span class="line">m.has(o) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码使用 Map 结构的set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。</p>
<p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">map.has(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// &quot;Author&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心！！</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set([<span class="string">&#x27;a&#x27;</span>], <span class="number">555</span>);</span><br><span class="line">map.get([<span class="string">&#x27;a&#x27;</span>]) <span class="comment">// undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。</p>
<p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.set(k1, <span class="number">111</span>)</span><br><span class="line">.set(k2, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">map.get(k1) <span class="comment">// 111</span></span><br><span class="line">map.get(k2) <span class="comment">// 222</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量k1和k2的值是一样的，但是它们在 Map 结构中被视为两个键。</p>
<p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>
<p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），<strong>则只要两个值严格相等，Map 将其视为一个键</strong>，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set(-<span class="number">0</span>, <span class="number">123</span>);</span><br><span class="line">map.get(+<span class="number">0</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="literal">true</span>, <span class="number">1</span>);</span><br><span class="line">map.set(<span class="string">&#x27;true&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">map.get(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="literal">undefined</span>, <span class="number">3</span>);</span><br><span class="line">map.set(<span class="literal">null</span>, <span class="number">4</span>);</span><br><span class="line">map.get(<span class="literal">undefined</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="literal">NaN</span>, <span class="number">123</span>);</span><br><span class="line">map.get(<span class="literal">NaN</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Map-实例的属性和操作方法"><a href="#Map-实例的属性和操作方法" class="headerlink" title="Map 实例的属性和操作方法"></a>Map 实例的属性和操作方法</h3><ol>
<li>size 属性</li>
</ol>
<p>size属性返回 Map 结构的成员总数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.set(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>set(key, value)</li>
</ol>
<p>set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">m.set(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">m.set(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>)    <span class="comment">// 键是 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set方法返回的是当前的Map对象，因此可以采用链式写法。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  .set(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  .set(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>get(key)</li>
</ol>
<p>get方法读取key对应的键值，如果找不到key，返回undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);&#125;;</span><br><span class="line">m.set(hello, <span class="string">&#x27;Hello ES6!&#x27;</span>) <span class="comment">// 键是函数</span></span><br><span class="line"></span><br><span class="line">m.get(hello)  <span class="comment">// Hello ES6!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>has(key)</li>
</ol>
<p>has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">m.set(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>);</span><br><span class="line">m.set(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>);</span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line"></span><br><span class="line">m.has(<span class="string">&#x27;edition&#x27;</span>)     <span class="comment">// true</span></span><br><span class="line">m.has(<span class="string">&#x27;years&#x27;</span>)       <span class="comment">// false</span></span><br><span class="line">m.has(<span class="number">262</span>)           <span class="comment">// true</span></span><br><span class="line">m.has(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>delete(key)</li>
</ol>
<p>delete方法删除某个键，返回true。如果删除失败，返回false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line">m.has(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">m.delete(<span class="literal">undefined</span>)</span><br><span class="line">m.has(<span class="literal">undefined</span>)       <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>clear()</li>
</ol>
<p>clear方法清除所有成员，没有返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.set(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line">map.clear()</span><br><span class="line">map.size <span class="comment">// 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Map-实例的遍历方法"><a href="#Map-实例的遍历方法" class="headerlink" title="Map 实例的遍历方法"></a>Map 实例的遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p>
<ul>
<li>keys()：返回键名的遍历器。</li>
<li>values()：返回键值的遍历器。</li>
<li>entries()：返回所有成员的遍历器。</li>
<li>forEach()：遍历 Map 的所有成员。</li>
</ul>
<p>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;T&#x27;</span>,  <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//    [&#x27;F&#x27;, &#x27;no&#x27;],</span></span><br><span class="line"><span class="comment">//    [&#x27;T&#x27;,  &#x27;yes&#x27;]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// &quot;F&quot;</span></span><br><span class="line">  <span class="comment">// &quot;T&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// &quot;no&quot;</span></span><br><span class="line">  <span class="comment">// &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line">  <span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 或者</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line">  <span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等同于使用map.entries()</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line">  <span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Map-和数组互相转换"><a href="#Map-和数组互相转换" class="headerlink" title="Map 和数组互相转换"></a>Map 和数组互相转换</h3><p>Map转换为数组，使用扩展运算符(…)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">[...map.keys()]</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">[...map.values()]</span><br><span class="line"><span class="comment">// [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span></span><br><span class="line"></span><br><span class="line">[...map.entries()]</span><br><span class="line"><span class="comment">// [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span></span><br><span class="line"></span><br><span class="line">[...map]</span><br><span class="line"><span class="comment">// [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span></span><br></pre></td></tr></table></figure>

<p>数组转换为Map 构造函数，将数组传入 Map 构造函数，就可以转为 Map。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="literal">true</span>, <span class="number">7</span>],</span><br><span class="line">  [&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// Map &#123;</span></span><br><span class="line"><span class="comment">//   true =&gt; 7,</span></span><br><span class="line"><span class="comment">//   Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Map-和对象的互相转换"><a href="#Map-和对象的互相转换" class="headerlink" title="Map 和对象的互相转换"></a>Map 和对象的互相转换</h3><p>Map 转为对象</p>
<p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="string">&#x27;yes&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">  .set(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToObj(myMap)</span><br><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>
<p>对象转为 Map</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToStrMap</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToStrMap(&#123;<span class="attr">yes</span>: <span class="literal">true</span>, <span class="attr">no</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="babel-转码原理"><a href="#babel-转码原理" class="headerlink" title="babel 转码原理"></a>babel 转码原理</h1><p>babel的转译过程分为三个阶段：parsing(解析)、transforming(转换)、generating(产生)</p>
<p>具体过程：</p>
<ol>
<li>编写ES6代码</li>
<li>babylon进行解析，解析得到AST</li>
<li>plugin用babel-traverse对AST树进行遍历转译，得到新的AST树</li>
<li>用babel-generator通过AST树生成ES5代码</li>
</ol>
<p>需注意的一点就是，babel默认只是转译新标准引入的语法，比如ES6的箭头函数，不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。</p>
<p>举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p>Proxy 是 ES6 中新增的功能，可以⽤来⾃定义对象中的操作。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler); <span class="comment">// `target` 代表需要添加代理的对象 // `handler` ⽤来⾃定义对象中的操作 可以很⽅便的使⽤ Proxy 来实现⼀个数据绑定和监听 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> onWatch = <span class="function">(<span class="params">obj, setBind, getLogger</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">let</span> handler = &#123;     </span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, property, receiver</span>)</span> &#123;       </span><br><span class="line">      getLogger(target, property)       </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver)  </span><br><span class="line">      &#125;,     </span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, property, value, receiver</span>)</span> &#123;       </span><br><span class="line">      setBind(value);       </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, property, value)</span><br><span class="line">      &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125; </span><br><span class="line"><span class="keyword">let</span> value </span><br><span class="line"><span class="keyword">let</span> p = onWatch(obj, <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;   </span><br><span class="line">  value = v &#125;, </span><br><span class="line">  (target, property) =&gt; &#123;   </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Get &#x27;<span class="subst">$&#123;property&#125;</span>&#x27; = <span class="subst">$&#123;target[property]&#125;</span>`</span>); </span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line">p.a = <span class="number">2</span> <span class="comment">// bind `value` to `2` p.a // -&gt; Get &#x27;a&#x27; = 2</span></span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Array-find-简写"><a href="#Array-find-简写" class="headerlink" title="Array.find 简写"></a>Array.find 简写</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pets = [&#123;</span><br><span class="line">    type: <span class="string">&#x27;Dog&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;wangcai&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">&#x27;Cat&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">&#x27;Dog&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Tommy&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">pet = pets.find(<span class="function"><span class="params">item</span> =&gt;</span> item.type === <span class="string">&#x27;Dog&#x27;</span> &amp;&amp; item.name === <span class="string">&#x27;Tommy&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pet) <span class="comment">// &#123; type: &#x27;Dog&#x27;, name: &#x27;Tommy&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="隐式返回"><a href="#隐式返回" class="headerlink" title="隐式返回"></a>隐式返回</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> implicitReturn = <span class="function">(<span class="params">value</span>) =&gt;</span> (value + value) <span class="comment">// 注意这里是圆括号 不是花括号</span></span><br><span class="line"><span class="built_in">console</span>.log(implicitReturn(<span class="string">&#x27;giao&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="charAt-简写"><a href="#charAt-简写" class="headerlink" title="charAt() 简写"></a>charAt() 简写</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;SampleString&#x27;</span>.charAt(<span class="number">0</span>) <span class="comment">// S</span></span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="string">&#x27;SampleString&#x27;</span>[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h2 id="有条件的函数的调用"><a href="#有条件的函数的调用" class="headerlink" title="有条件的函数的调用"></a>有条件的函数的调用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am Function 1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am Function 2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 复杂写法</span></span><br><span class="line"><span class="keyword">let</span> checkValue = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> (checkValue === <span class="number">3</span>) &#123;</span><br><span class="line">  fn1()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  fn2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简短写法</span></span><br><span class="line">(checkValue === <span class="number">3</span> ? fn1 : fn2)()</span><br></pre></td></tr></table></figure>

<h2 id="Math-Floor-简写"><a href="#Math-Floor-简写" class="headerlink" title="Math.Floor 简写"></a>Math.Floor 简写</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> val = <span class="string">&#x27;123.95&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(val)) <span class="comment">// 常规写法</span></span><br><span class="line"><span class="built_in">console</span>.log(~~val) <span class="comment">// 简写</span></span><br></pre></td></tr></table></figure>

<h2 id="Math-pow-简写"><a href="#Math-pow-简写" class="headerlink" title="Math.pow 简写"></a>Math.pow 简写</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 简写 8  </span></span><br></pre></td></tr></table></figure>

<h2 id="字符串转换为数字"><a href="#字符串转换为数字" class="headerlink" title="字符串转换为数字"></a>字符串转换为数字</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&#x27;100&#x27;</span>)</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">&quot;100&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">&quot;100.2&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="amp-amp-运算"><a href="#amp-amp-运算" class="headerlink" title="&amp;&amp; 运算"></a>&amp;&amp; 运算</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (value === <span class="number">1</span>)  <span class="built_in">console</span>.log(<span class="string">&#x27;Value is one&#x27;</span>)</span><br><span class="line"><span class="comment">// &amp;&amp; 运算</span></span><br><span class="line">value &amp;&amp; <span class="built_in">console</span>.log(<span class="string">&#x27;Value is one&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  只要“&amp;&amp;”前面是false，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”前面的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  只要“&amp;&amp;”前面是true，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”后面的值</span></span><br></pre></td></tr></table></figure>

<h2 id="toString-简写"><a href="#toString-简写" class="headerlink" title="toString 简写"></a>toString 简写</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someNumber = <span class="number">123</span></span><br><span class="line"><span class="built_in">console</span>.log(someNumber.toString()) <span class="comment">// &quot;123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;someNumber&#125;</span>`</span>) <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用对象的形式代替-switch-语法"><a href="#使用对象的形式代替-switch-语法" class="headerlink" title="使用对象的形式代替 switch 语法"></a>使用对象的形式代替 switch 语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch 写法</span></span><br><span class="line"><span class="keyword">let</span> animal = <span class="string">&#x27;dog&#x27;</span></span><br><span class="line"><span class="keyword">let</span> name</span><br><span class="line"><span class="keyword">switch</span>(animal) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;dog&#x27;</span>:</span><br><span class="line">    name = <span class="string">&#x27;wangcai&#x27;</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;cat&#x27;</span>:</span><br><span class="line">    name = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;pig&#x27;</span>:</span><br><span class="line">    name = <span class="string">&#x27;paige&#x27;</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    name = <span class="string">&#x27;jerry&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  对象的形式，实际上是使用策略模式重构代码</span></span><br><span class="line"><span class="comment">// case1</span></span><br><span class="line"><span class="keyword">const</span> fn1 = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> animalsList = &#123;</span><br><span class="line">    <span class="string">&#x27;dog&#x27;</span>: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;wangcai&#x27;</span> &#125;,</span><br><span class="line">    <span class="string">&#x27;cat&#x27;</span>: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;tom&#x27;</span> &#125;,</span><br><span class="line">    <span class="string">&#x27;pig&#x27;</span>: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;peppa pig&#x27;</span> &#125;,</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;jerry&#x27;</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> animalsList[name] !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> animalsList[name]()</span><br><span class="line">&#125;</span><br><span class="line">fn1(<span class="string">&#x27;dog&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// case2</span></span><br><span class="line"><span class="keyword">const</span> animalsList2 = &#123;</span><br><span class="line">  <span class="string">&#x27;dog&#x27;</span>: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;wangcai&#x27;</span> &#125;,</span><br><span class="line">  <span class="string">&#x27;cat&#x27;</span>: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;tom&#x27;</span> &#125;,</span><br><span class="line">  <span class="string">&#x27;pig&#x27;</span>: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;peppa&#x27;</span> &#125;,</span><br><span class="line">  <span class="string">&#x27;default&#x27;</span>: <span class="function">() =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&#x27;jerry&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn2 = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> animalsList2[name]</span><br><span class="line">&#125;</span><br><span class="line">fn2(<span class="string">&#x27;cat&#x27;</span>)()</span><br></pre></td></tr></table></figure>

<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>(22+ 高频实用的 JavaScript 片段 （2020年）)[<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/kmelc879Eadfr9YFntkAUg]">https://mp.weixin.qq.com/s/kmelc879Eadfr9YFntkAUg]</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/21/JavaScript/this%E6%8C%87%E5%90%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/21/JavaScript/this%E6%8C%87%E5%90%91/" class="post-title-link" itemprop="url">javaScript中的this指向</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-21 16:12:22" itemprop="dateCreated datePublished" datetime="2019-03-21T16:12:22+08:00">2019-03-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h1><p>this的指向有4种类型</p>
<h2 id="形式”test-”"><a href="#形式”test-”" class="headerlink" title="形式”test()”"></a>形式”test()”</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>直接不带任何引用形式去调用函数，则this会指向全局对象，因为没有其他影响去改变this，this默认就是指向全局对象（浏览器是window，Node中是global）的。这个结论是在非严格模式的情况下，严格模式下这个this其实是undefined的。</p>
<h2 id="形式”xxx-text-”"><a href="#形式”xxx-text-”" class="headerlink" title="形式”xxx.text()”"></a>形式”xxx.text()”</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line">obj.test()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种形式相对于第一中，this指向已经很明显，谁去调用这个函数的，这个函数中的this就绑定到谁身上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj0 = &#123;</span><br><span class="line">    a: <span class="number">3</span>,</span><br><span class="line">    obj </span><br><span class="line">&#125;</span><br><span class="line">obj0.obj.test()</span><br></pre></td></tr></table></figure>

<p>虽然比上面复杂了一点，但是结果依然和上面的一样，this指向obj，指向直接调用的对象,结果依然是2。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> testCopy = obj.test</span><br><span class="line">testCopy()</span><br></pre></td></tr></table></figure>
<p>道理同上，虽然说换了一个名字，但是调用的是window，所以结果是1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(obj.test)  <span class="comment">//输出1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="形式“test-call-xxx-test-apply-xxx-test-bind-”"><a href="#形式“test-call-xxx-test-apply-xxx-test-bind-”" class="headerlink" title="形式“test.call(xxx) / test.apply(xxx) / test.bind()”"></a>形式“test.call(xxx) / test.apply(xxx) / test.bind()”</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> testCopy = obj.test</span><br><span class="line">testCopy.call(obj)<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>可以看到，我们通过call（apply跟call的区别只是传参，作用是一样的，bind有点区别，bind能让我们的函数延迟执行，apply与call调用就执行，所以bind这样的形式我们也称为函数柯里化，这些就不是我们这里要说的啦）来调用testCopy，并且传入了你想要this指向的上下文，那么this指向你要的对象。看到这里，我们也可以想象第一、二种形式其实可以转化成call/apply的形式</p>
<h2 id="“new-test-”形式"><a href="#“new-test-”形式" class="headerlink" title="“new test()”形式"></a>“new test()”形式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> test(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(b.a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>new这个操作符其实是new了一个新对象出来，而被new的test我们称为构造函数，我们可以在这个构造函数里定义一下将要到来的新对象的一些属性。所以构造函数里的this指的就是将要被new出来的新对象。</p>
<h2 id="箭头函数中的this指向"><a href="#箭头函数中的this指向" class="headerlink" title="箭头函数中的this指向"></a>箭头函数中的this指向</h2><p><strong>箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定</strong>所谓的定义时候绑定，就是this是继承自父执行上下文中的this！！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line">obj.test()      <span class="comment">//  输出1</span></span><br></pre></td></tr></table></figure>

<p><strong>它this指向的是它的外层作用域this的指向。</strong>。外层作用域是整个window，所以输出的是1.</p>
<p><strong>注意：简单对象（非函数）是没有执行上下文的！</strong></p>
<h3 id="改变箭头函数的this的指向"><a href="#改变箭头函数的this的指向" class="headerlink" title="改变箭头函数的this的指向"></a>改变箭头函数的this的指向</h3><ol>
<li>使用双冒号::进行绑定,但是该方法目前只是在ES7的提案中，虽然babel转码器已经支持但是仍未成为标准，所以在实际使用中可能会报错</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象作为上下文环境绑定到右边的函数上</span></span><br><span class="line">foo::bar</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">bar.bind(foo)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用call</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;jack&quot;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	name: <span class="string">&quot;nick&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> 	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"> 		<span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line"> 	&#125;,<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo()       <span class="comment">//  输出jack</span></span><br><span class="line">foo.call(obj)       <span class="comment">//  输出nick</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>箭头函数导致this总是指向函数定义生效时所在的对象。上面的call改变了this的执行上下文，所以指向了obj</p>
<p>箭头函数可以让setTimeout里面的this绑定定义时所在的作用域，而不是指向运行时所在的作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.s1 = <span class="number">0</span></span><br><span class="line">		<span class="built_in">this</span>.s2 = <span class="number">0</span></span><br><span class="line">		<span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="built_in">this</span>.s1 ++ ,<span class="number">1000</span>)</span><br><span class="line">		<span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">this</span>.s2++</span><br><span class="line">		&#125;,<span class="number">1000</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> timer = <span class="keyword">new</span> Timer()</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(timer.s1),<span class="number">3100</span>)		<span class="comment">//s1: 3</span></span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(timer.s2),<span class="number">3100</span>)		<span class="comment">//s2: 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前者的this绑定定义时所在的作用域，即Timer函数，tihs.s1更新了3次</span></span><br><span class="line"><span class="comment">// 后者运行时的this指向全局对象，this.s2更新0次</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="apply、call-和-bind-的作用。"><a href="#apply、call-和-bind-的作用。" class="headerlink" title="apply、call 和 bind 的作用。"></a>apply、call 和 bind 的作用。</h2><p>apply和call、bind的目的就是为了改变函数内部this的指向。</p>
<p>除了第⼀个参数外， call 可以接收⼀个参数列表， apply 只接受⼀个参数数组。bind是es5的语法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> person = &#123;</span><br><span class="line">      name: <span class="string">&#x27;zero&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">printInfo</span>(<span class="params">age, job</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, age, job);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    printInfo(<span class="number">20</span>, <span class="string">&#x27;前端工程师&#x27;</span>);        <span class="comment">// 打印：global 20 前端工程师,因为默认的上下文是window，所以this.name是全局定义的global，如果我们想打印出来zero的话，就需要改变函数执行的上下文</span></span><br><span class="line"></span><br><span class="line">    printInfo.call(person, <span class="number">20</span>, <span class="string">&#x27;前端工程师&#x27;</span>);<span class="comment">// zero 20 前端工程师</span></span><br><span class="line">    printInfo.apply(person, [<span class="number">20</span>, <span class="string">&#x27;前端工程师&#x27;</span>]);<span class="comment">// zero 20 前端工程师</span></span><br><span class="line"><span class="comment">// 这两种方式是一样的，第一个参数都是传进去的上下文，this.name取的是person.name，所以打印出来的名字就是zero了，后面的为age和job，只是参数传递的方式不一样，apply比较特殊，把要传的参数放在数组里面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而bind和以上两种有区别，bind是es5定义的新方法，用来返回一个有自己上下文的函数，用法也比较类似：</span></span><br><span class="line">    printInfo.bind(person)(<span class="number">20</span>, <span class="string">&#x27;前端工程师&#x27;</span>);<span class="comment">// zero 20 前端工程师</span></span><br><span class="line"><span class="comment">// printInfo.bind(person)这一块是返回的以peron为上下文的函数，后面的(20, &#x27;前端工程师&#x27;)是函数调用</span></span><br></pre></td></tr></table></figure>

<p>bind后函数不会立即执行，而只是返回一个改变了上下文的函数副本，而call和apply是直接执行函数，所以我们可以通过 bind 实现柯⾥化</p>
<h2 id="apply、call-和-bind-的应用"><a href="#apply、call-和-bind-的应用" class="headerlink" title="apply、call 和 bind 的应用"></a>apply、call 和 bind 的应用</h2><ol>
<li>数组之间的追加(使用a.concat(b) 会返回一个新的数组，不会影响原来的数组)</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(a, b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a)    <span class="comment">//[4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="built_in">console</span>.log(b)    <span class="comment">// [7, 8, 9]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取数组中的最大值和最小值，利用他们扩充作用域拥有Math的min和max方法</li>
</ol>
<p>由于没有什么对象调用这个方法，所以第一个参数可以写作null或者本身</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span>  numbers = [<span class="number">5</span>, <span class="number">458</span> , <span class="number">120</span> , -<span class="number">215</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  maxInNumbers = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, numbers),   <span class="comment">//458   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458</span></span><br><span class="line"><span class="comment">// console.log(Math.max([5, 458 , 120 , -215 ]))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>验证是否是数组（前提是toString（）方法没有被重写过）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(fn) <span class="comment">// &quot;[object Function]&quot;  函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(date) <span class="comment">// &quot;[object Date]&quot;    日期 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr) <span class="comment">// &quot;[object Array]&quot;    数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[hbc]at/gi</span>;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(reg) <span class="comment">// &quot;[object RegExp]&quot;   正则</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>让伪数组拥有数组的方法</li>
</ol>
<ul>
<li>Array.prototype.slice.call()</li>
<li>[].prototype.slice.call()</li>
<li>Array.from()</li>
<li>扩展运算符[…()]</li>
</ul>
<h1 id="bind-apply-call-的区别"><a href="#bind-apply-call-的区别" class="headerlink" title="bind / apply / call 的区别"></a>bind / apply / call 的区别</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">a,b,c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    <span class="built_in">console</span>.log(a,b,c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    name: <span class="string">&quot;segmentFault&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">a.call(b,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 segmentFault和 1,2,3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">a,b,c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    <span class="built_in">console</span>.log(a,b,c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.apply(b,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment">//输出segmentFault和1,2,3</span></span><br></pre></td></tr></table></figure>

<p>使用 bind 之后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    name: <span class="string">&quot;segmentFault&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">a.bind(b, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><strong>此时控制台并没有代码输出，因为bind会重新生成并且返回一个函数，这个函数的this指向第一个参数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    name: <span class="string">&quot;segmentFault&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = a.bind(b, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">c() <span class="comment">//此时输出segmentFault</span></span><br></pre></td></tr></table></figure>

<h1 id="手写-apply-call-bind"><a href="#手写-apply-call-bind" class="headerlink" title="手写 apply/call/bind"></a>手写 apply/call/bind</h1><ol>
<li>手写 apply</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// context 是上下文，args 是携带的参数</span></span><br><span class="line">    <span class="comment">// 这里默认不传就是给window,也可以用es6给参数设置默认参数</span></span><br><span class="line">    context = context || <span class="built_in">window</span></span><br><span class="line">    args = args ? args : []</span><br><span class="line">    <span class="comment">// 给context新增一个独一无二的属性以免覆盖原有属性</span></span><br><span class="line">    <span class="keyword">const</span> key = <span class="built_in">Symbol</span>()</span><br><span class="line">    context[key] = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 通过隐式绑定的方式调用函数</span></span><br><span class="line">    <span class="keyword">const</span> result = context[key](...args)</span><br><span class="line">    <span class="comment">// 删除添加的属性</span></span><br><span class="line">    <span class="keyword">delete</span> context[key]</span><br><span class="line">    <span class="comment">// 返回函数调用的返回值</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>手写 call</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递参数从一个数组变成逐个传参了,不用...扩展运算符的也可以用arguments代替</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里默认不传就是给 window,也可以用 es6 给参数设置默认参数</span></span><br><span class="line">    context = context || <span class="built_in">window</span></span><br><span class="line">    args = args ? args : []</span><br><span class="line">    <span class="comment">//给context 对象新增一个独一无二的属性以免覆盖原有属性</span></span><br><span class="line">    <span class="keyword">const</span> key = <span class="built_in">Symbol</span>()</span><br><span class="line">    context[key] = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">//通过隐式绑定的方式调用函数</span></span><br><span class="line">    <span class="keyword">const</span> result = context[key](...args)</span><br><span class="line">    <span class="comment">//删除添加的属性</span></span><br><span class="line">    <span class="keyword">delete</span> context[key]</span><br><span class="line">    <span class="comment">//返回函数调用的返回值</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果要改变一个函数的 this 指向，则需要把那个函数变成一个对象上的属性</strong>，也就是在这里的 <code>context[key] = this</code>。</p>
<ol start="3">
<li>手写 bind</li>
</ol>
<p>bind 和 apply 的区别在于，bind 是返回一个绑定好的函数，apply 是直接调用。</p>
<p>其实就是返回一个函数，里面执行了 apply 上述的操作而已。不过有一个需要判断的点，因为返回新的函数，要考虑到使用 new 去调用，并且 new 的优先级比较高，所以需要判断 new 的调用。</p>
<p>还有一个特点就是 bind 调用的时候可以传参，调用之后生成的新的函数也可以传参，效果是一样的，所以这一块也要做处理。<br>因为上面已经实现了 apply，这里就借用一下，实际上不借用就是把代码 copy 过来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">this</span></span><br><span class="line">  args = args ? args : []</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">newFn</span>(<span class="params">...newFnArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> newFn) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> fn(...args, ...newFnArgs)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(context, [...args,...newFnArgs])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>(50行javaScript代码实现简单版的 call , apply ,bind 【中级前端面试基础必备】)[<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020044435]">https://segmentfault.com/a/1190000020044435]</a><br>(<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903891092389901#heading-7)[%E9%9D%A2%E8%AF%95%E6%84%9F%E6%82%9F,%E6%89%8B%E5%86%99bind,apply,call]">https://juejin.im/post/6844903891092389901#heading-7)[面试感悟,手写bind,apply,call]</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/26/JavaScript/javaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/26/JavaScript/javaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">JavaScript运行机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-26 14:26:24" itemprop="dateCreated datePublished" datetime="2019-02-26T14:26:24+08:00">2019-02-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-16 01:05:16" itemprop="dateModified" datetime="2021-04-16T01:05:16+08:00">2021-04-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>首先必须了解JS是单线程的（语言核心），最主要的原因就是为了避免DOM的（浏览器需要渲染 DOM，JS 可以修改 DOM 结构 ），虽然在 HTML5 中的 webWorker 支持多线程，但是仍然不支持对 DOM 的操作，所以最佳的解决方案是异步，依赖 EventLoop 实现。异步虽然存在很多问题，但是依然在不断完善中。</strong></p>
<h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><ul>
<li><p>进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位（进程是一个工厂，工厂有它的独立资源，并且工厂之间相互独立）</p>
</li>
<li><p>线程：是进程中的一部分，一个没有线程的进程也可以被看作是单线程的，是CPU调度的一个基本单位（线程是工厂中的工人，多个工人协作完成任务，一个工厂可以有一个或者多个工人，工人之间共享空间）</p>
</li>
</ul>
<p>进程之间的通信方式：</p>
<ul>
<li>无名管道：半双工通信方式，数据只能单向流动并且只能在具有亲缘关系的进程间使用</li>
<li>有名管道：也是半双工通信方式，但是允许没有亲缘进程之间的通信</li>
<li>高级管道：将另一个程序当作一个新的程序在当前程序进程中启动，则这个进程算是当前程序的子进程</li>
<li>信号：用于通知接受进程某个事件已经发生</li>
</ul>
<h2 id="js单线程的优缺点"><a href="#js单线程的优缺点" class="headerlink" title="js单线程的优缺点"></a>js单线程的优缺点</h2><p>优点：JS 是单线程运⾏的，可以达到节省内存，节约上下⽂切换时 间，没有锁的问题的好处</p>
<p>缺点：相对其他语言效率较低。</p>
<h1 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h1><p>因为 Javascript 是单线程的，所以意味着任务需要一个接着一个完成。但是如果前面的任务执行时间很长，那么后面的任务就得一直阻塞着，这样用户体验十分差。<br>JavaScript 的设计者考虑到了这一点，所以他将 JavaScript 的任务分为两种，在主线程上执行的任务”同步任务”，被主线程挂载起来的任务”异步任务”,后者一般是放在一个叫<strong>任务队列</strong>的数据结构中。</p>
<p>那么一般异步执行运行机制如下(也是JavaScript的运行机制)：</p>
<p>(1)所有同步任务都在主线程上执行，形成一个<strong>执行栈</strong>。</p>
<p>(2)主线程之外，还有一个“任务队列”,只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。</p>
<p>(3)一旦“执行栈”中的所有同步任务执行完毕了，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p>
<p>(4)主线程不断重复上面的三步。（事件循环，轮询执行异步队列中的函数）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">test();</span><br><span class="line">test2();</span><br><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="comment">//test2</span></span><br><span class="line"><span class="comment">//setTimeout;</span></span><br></pre></td></tr></table></figure>

<h1 id="事件和回调函数"><a href="#事件和回调函数" class="headerlink" title="事件和回调函数"></a>事件和回调函数</h1><p>test()和test2()属于“执行栈”中的同步任务，而<strong>定时器则是任务队列里面的异步任务</strong>，那么定时器就是属于异步任务中的一种，在讲定时器之前先认识一下任务队列里面的另外一个重要成员，事件。其实<strong>任务队列就是一个事件队列</strong>，因为一般我们绑定一个事件，比如点击事件等等，都是在某一个时刻才触发执行的，这个时候就得放到任务队列里面，等待执行，而在某个DOM节点上绑定了事件，就要有相应的回调函数,它们是相辅相成的。<br>所谓回调函数，就是那些被挂载起来，等待执行的代码，主线程执行任务队列里面的异步任务，其实就是执行这些回调函数。<br>一般只有主线程所有任务都执行完毕了，才会执行任务队列里面的异步任务，一般是按照队列的“先进先出”顺序执行，但是因为存在定时器，所以主线程要检查执行时间，只有到了规定的时间，才能返回主线程。</p>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>定时器主要由 setTimeout() 和 setInterval() 两个函数来完成，它们的内部运行机制完全一样，不同的只是，前者一次性执行，而后者反复执行。定时器，属于任务队列中的异步任务，所以才会出现上面的问题，再看几个例子就能理解了，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>);&#125;,<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码的执行结果是1,3,2，因为只有 setTimeout 里面的代码是异步任务，其它都是主线程里的同步任务，所以只有执行完了主线程中的所有任务，才会执行setTimeout 中的任务。</p>
<p><strong>但是因为JS的运行机制原因，会导致定时器的运行时间不够准确</strong>，所以可以通过时间戳的方法，使延迟的时间减去函数的运行时间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="keyword">var</span> message = <span class="built_in">document</span>.getElementById(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> count = <span class="number">1000</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">		message.innerHTML = count--;</span><br><span class="line">		<span class="keyword">var</span> finish = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">		<span class="built_in">setTimeout</span>(animate, <span class="number">1000</span> - (finish-start));</span><br><span class="line">	&#125;</span><br><span class="line">   animate();</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="定时器例子1"><a href="#定时器例子1" class="headerlink" title="定时器例子1"></a>定时器例子1</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test1 每2秒运行一次， test2 每3秒运行一次</span></span><br><span class="line"><span class="comment">//求test2第二次运行是在第几秒？  </span></span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">      &#125;,<span class="number">3000</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line"><span class="comment">//test1 第一次运行是在第二秒。test2 第一次运行需要等待test1 运行结束之后才能开始，所以在第五秒运行test2</span></span><br><span class="line"><span class="comment">//然后test2 的运行结果会被缓存，那么第二次运行就是 2+3+2 在第7秒运行，第三次运行就是2+3+2+2 在第九秒运行</span></span><br></pre></td></tr></table></figure>

<h2 id="定时器例子2"><a href="#定时器例子2" class="headerlink" title="定时器例子2"></a>定时器例子2</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">      &#125;,<span class="number">2000</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">    &#125;,<span class="number">5000</span>)</span><br><span class="line"><span class="comment">//  第一次5秒时先输出5，然后过2秒再输出2，再过3秒输出5，再过2秒输出2。525252循环下去</span></span><br><span class="line"><span class="comment">// test2第一次运行是在5+2 第7s，第二次运行是在5+2+5 在12秒运行</span></span><br></pre></td></tr></table></figure>

<h2 id="定时器例子3"><a href="#定时器例子3" class="headerlink" title="定时器例子3"></a>定时器例子3</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">      &#125;,<span class="number">5000</span>)</span><br><span class="line"><span class="comment">//先输出5，然后再过1秒输出1，接下去循环每秒输出1</span></span><br></pre></td></tr></table></figure>

<h2 id="定时器例子4"><a href="#定时器例子4" class="headerlink" title="定时器例子4"></a>定时器例子4</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">        &#125;,<span class="number">5000</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line"><span class="comment">//先输出1，然后再过5秒输出5，接下去循环每5秒输出5</span></span><br></pre></td></tr></table></figure>


<h1 id="Even-Loop"><a href="#Even-Loop" class="headerlink" title="Even Loop"></a>Even Loop</h1><p>javascript提供的与 <strong>“任务队列”</strong> 有关的方法有：setTimeout、setInterval、process.nextTick和setImmediate。</p>
<p>process.nextTick方法可以在当前“执行栈”的尾部——下一次Event Loop(主线程读取“任务队列”)之前——触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。setImmediate方法则是在当前“任务队列”的尾部添加事件，也即是说，它指定的任务总是在下一次Event Loop时执行。</p>
<p>在JavaScript中，异步任务被详细分为两种，一种宏任务（MacroTask）也叫Task，一种叫微任务（MicroTask）。</p>
<p><strong>MacroTask（宏任务）</strong></p>
<p>setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。</p>
<p><strong>MicroTask（微任务）</strong></p>
<p>Process.nextTick（Node独有）、<strong>Promise</strong>、Object.observe(废弃)、MutationObserver</p>
<p>接下来介绍浏览器的 JavaScript 代码的具体流程：</p>
<ol>
<li>执行全局 Script 同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；</li>
<li>全局 Script 同步代码执行完毕后，调用栈Stack会清空；</li>
<li>从微队列 microtask queue 中取出位于队首的回调任务，放入调用栈 Stack 中执行，执行完后 microtask queue 长度减1；</li>
<li>继续取出位于队首的任务，放入调用栈 Stack 中执行，以此类推，直到直到把 microtask queue 中的所有任务都执行完毕。<strong>注意，如果在执行 microtask 的过程中，又产生了 microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；</strong></li>
<li>microtask queue中的所有任务都执行完毕，此时 microtask queue 为空队列，调用栈 Stack 也为空；</li>
<li>取出宏队列 macrotask queue 中位于队首的任务，放入 Stack 中执行；</li>
<li>执行完毕后，调用栈 Stack 为空；</li>
<li>重复第3-7个步骤；</li>
<li>重复第3-7个步骤；</li>
<li>……</li>
</ol>
<p>可以看到，这就是浏览器的事件循环 Event Loop</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">  resolve(<span class="number">5</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p>按照上面的步骤，将各个任务代入同步任务、宏队列和微队列中，就可以得出结果1、4、7、5、2、3、6。需要特别注意的是在这里的console.log(“4”)其实是同步任务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果是：script start -&gt; script end -&gt; promise1 -&gt; promise2 -&gt; setTimeout</p>
<p>为了验证是否真的掌握还是要再举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>) </span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这里需要先理解async/await。实际上转换了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>)</span><br><span class="line"> <span class="comment">// Promise.resolve() 将代码插入微任务队列尾部</span></span><br><span class="line"> <span class="comment">// resolve 再次插入微任务队列尾部</span></span><br><span class="line"> resolve(<span class="built_in">Promise</span>.resolve())</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>async/await 在底层转换成了 promise 和 then 回调函数。<br>也就是说，这是 promise 的语法糖。<br>每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。<br>async/await 的实现，离不开 Promise。从字面意思来理解，async 是“异步”的简写，而 await 是 async wait 的简写可以认为是等待异步方法执行完成。</p>
<p>输出的结果是：<br> script start<br> async2 end<br> Promise<br> script end<br> async1 end<br> promise1<br> promise2<br> setTimeout</p>
<p>详细过程：</p>
<ul>
<li>首先，打印script start，调用async1()时，返回一个Promise，所以打印出来async2 end。</li>
<li>每个 await，会新产生一个promise,但这个过程本身是异步的，所以该await后面不会立即调用。</li>
<li>继续执行同步代码，打印Promise和script end，将then函数放入微任务队列中等待执行。</li>
<li>同步执行完成之后，检查微任务队列是否为null，然后按照先入先出规则，依次执行。</li>
<li>然后先执行打印promise1,此时then的回调函数返回undefined，此时又有then的链式调用，又放入微任务队列中，再次打印promise2。</li>
<li>再回到await的位置执行返回的 Promise 的 resolve 函数，这又会把 resolve 丢到微任务队列中，打印async1 end。</li>
<li>当微任务队列为空时，执行宏任务,打印setTimeout。<br>这里的主要问题是把async和await弄清楚。。。</li>
</ul>
<p>小结：执行顺序：同步代码 =&gt; 微任务(.then) =&gt; 宏任务 </p>
<h1 id="javaScript和Java、C-的区别"><a href="#javaScript和Java、C-的区别" class="headerlink" title="javaScript和Java、C++的区别"></a>javaScript和Java、C++的区别</h1><ol>
<li>从静态类型看还是动态类型看</li>
</ol>
<ul>
<li><p><strong>静态类型，编译的时候就能够知道每个变量的类型，编程的时候也需要给定类型。</strong>如Java中的整型int，浮点型float等。</p>
</li>
<li><p><strong>动态类型，运行的时候才知道每个变量的类型，编程的时候无需显示指定类型，</strong>如JavaScript中的var、PHP中的$。JavaScript、Ruby、Python都属于动态类型语言。</p>
</li>
</ul>
<p><strong>静态类型还是动态类型对语言的性能有很大影响。</strong> </p>
<p>对于静态类型，在编译后会大量利用已知类型的优势，如int类型，占用4个字节，编译后的代码就可以用内存地址加偏移量的方法存取变量，而地址加偏移量的算法汇编很容易实现。 </p>
<p>对于动态类型，会当做字符串通通存下来，之后存取就用字符串匹配。 </p>
<ol start="2">
<li>从编译型还是解释型来看</li>
</ol>
<p><strong>编译型语言，像C、C++，在程序执行之前，有一个单独的编译过程，将程序翻译成机器语言，以后执行这个程序的时候，就不用再进行编译了。</strong>用户只使用这些编译好的本地代码，这些本地代码由系统加载器执行，由操作系统的CPU直接执行，无需其他额外的虚拟机等。 </p>
<p><strong>解释型语言，是在运行的时候将程序翻译成机器语言，所以运行速度相对于编译型语言要慢。用户使用脚本解释器将脚本文件解释执行，没有编译过程。</strong>对于JavaScript，随着Java虚拟机JIT技术的引入，工作方式也发生了改变。可以将抽象语法树转成中间表示（字节码），再转成本地代码，如JavaScriptCore，这样可以大大提高执行效率。但是在 V8 引擎下，⼜引⼊了 TurboFan 编译器，他会在特定的情况下进⾏优化，将代码编译成执⾏效率更⾼的 Machine Code（机器码） ，当然这个编译器并不是 JS 必须 需要的，只是为了提⾼代码执⾏性能，所以总的来说 JS 更偏向于解释型语⾔。</p>
<p><strong>Java语言，分为两个阶段。</strong>Java语言，分为两个阶段。第一阶段，Java编译后，生成字节码，字节码与平台无关。第二阶段，在运行的时候，由JVM将字节码再翻译成机器语言。</p>
<h1 id="为什么JS中-0-1-0-2-不等于-0-3"><a href="#为什么JS中-0-1-0-2-不等于-0-3" class="headerlink" title="为什么JS中 0.1+0.2 不等于 0.3"></a>为什么JS中 0.1+0.2 不等于 0.3</h1><p>JS中的数字是用IEEE 754 双精度 64 位浮点数来存储的，它由64位组成,但是当<strong>十进制小数的二进制表示</strong>的有限数字超过 52 位时，在 JavaScript 里是不能精确存储的，超过的会被舍弃，所以存在误差。</p>
<p>0.1 在⼆进制中是⽆限循环的⼀些数字，其实不只是 0.1 ，其实很多⼗进制⼩数⽤⼆进制表示都是⽆限循环的。这样其实没什么 问题，但是 JS 采⽤的浮点数标准却会裁剪掉我们的数字。</p>
<ul>
<li>第0位：符号位， s 表示 ，0表示正数，1表示负数；</li>
<li>第1位到第11位：储存指数部分， e 表示 ；</li>
<li>第12位到第63位：储存小数部分（即有效数字），f 表示</li>
</ul>
<p>如果想要使得  0.1+0.2  == 0.3，在ES6中，已经为我们提供了这样一个属性：Number.EPSILON，小于这个范围内的误差则可以认为两个数字是相等的</p>
<p>或者 (0.1<em>1000+0.2</em>1000)/1000==0.3 //true</p>
<h1 id="Node的应⽤场景"><a href="#Node的应⽤场景" class="headerlink" title="Node的应⽤场景"></a>Node的应⽤场景</h1><p>特点：</p>
<ol>
<li>它是⼀个 Javascript 运⾏环境 </li>
<li>依赖于 Chrome V8 引擎进⾏代码解释 </li>
<li>事件驱动 </li>
<li>⾮阻塞 I/O </li>
<li>单进程，单线程</li>
</ol>
<p>优点：</p>
<p>⾼并发（最重要的优点）</p>
<p>缺点：</p>
<ol>
<li>只⽀持单核 CPU ，不能充分利⽤ CPU </li>
<li>单进程，单线程，一旦这个进程崩掉，那么整个web服务就崩掉了。</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5c3d8956e51d4511dc72c200">一次弄懂Event Loop（彻底解决此类面试问题）</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016278115?utm_source=tag-newest#articleHeader8">带你彻底弄懂 Event Loop</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/23/JavaScript/%E5%9F%BA%E7%A1%80%E9%9B%B6%E7%A2%8E%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/23/JavaScript/%E5%9F%BA%E7%A1%80%E9%9B%B6%E7%A2%8E%E7%82%B9/" class="post-title-link" itemprop="url">零碎知识点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-23 18:06:21" itemprop="dateCreated datePublished" datetime="2019-02-23T18:06:21+08:00">2019-02-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-11 22:17:47" itemprop="dateModified" datetime="2021-04-11T22:17:47+08:00">2021-04-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数组Array的对象方法"><a href="#数组Array的对象方法" class="headerlink" title="数组Array的对象方法"></a>数组Array的对象方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//改变数组的api</span></span><br><span class="line"></span><br><span class="line">arr.splice(index,num)	<span class="comment">//=&gt;实现数组的增arr.splice(index,0,newItem)删arr.splice(index,1,newItem)改arr.splice(index,1)</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a-b&#125;)		<span class="comment">//=&gt;实现数组的排序  升序</span></span><br><span class="line">arr.pop() <span class="comment">//删除一个数组中的最后的一个元素</span></span><br><span class="line">arr.shift() <span class="comment">//删除数组的第一个元素</span></span><br><span class="line">arr.push() <span class="comment">//向数组的末尾添加元素</span></span><br><span class="line">arr.unshift()</span><br><span class="line">arr.reverse() <span class="comment">//颠倒数组中元素的顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不改变数组的api</span></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line">	arr.slice(begin,end) <span class="comment">//浅拷贝数组的元素</span></span><br><span class="line"><span class="comment">//	begin(可选) 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为0。</span></span><br><span class="line"><span class="comment">//	end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line">	arr.join() <span class="comment">//数组转字符串</span></span><br><span class="line"><span class="comment">//str(可选): 指定要使用的分隔符，默认使用逗号作为分隔符。</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line">toLocaleString() <span class="comment">//数组转字符串</span></span><br><span class="line"><span class="comment">//定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//4.</span></span><br><span class="line">arr.toString() <span class="comment">//数组转字符串 不推荐</span></span><br><span class="line"><span class="comment">//定义: toString() 方法可把数组转换为由逗号链接起来的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.</span></span><br><span class="line">arr.cancat()</span><br><span class="line"><span class="comment">//定义： 方法用于合并两个或多个数组，返回一个新数组。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.</span></span><br><span class="line">arr.indexOf()<span class="comment">//查找数组是否存在某个元素，返回下标</span></span><br><span class="line"><span class="comment">//定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="JS中的类型转换"><a href="#JS中的类型转换" class="headerlink" title="JS中的类型转换"></a>JS中的类型转换</h1><h2 id="显式类型的转换（强制类型转换）"><a href="#显式类型的转换（强制类型转换）" class="headerlink" title="显式类型的转换（强制类型转换）"></a>显式类型的转换（强制类型转换）</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ol>
<li>toString()方法(但是注意null和undefined两个值没有toString，调用该方法会报错)，当数字调用该方法的时候，可以在括号内传入转换的进制数。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">a.toString()<span class="comment">//&quot;123&quot;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">null</span>;</span><br><span class="line">b.toString()<span class="comment">//&quot;报错&quot;</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">undefined</span></span><br><span class="line">c.toString()<span class="comment">//&quot;报错&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iNum = <span class="number">10</span>;</span><br><span class="line">alert(iNum.toString(<span class="number">2</span>));        <span class="comment">//输出 &quot;1010&quot;</span></span><br><span class="line">alert(iNum.toString(<span class="number">8</span>));        <span class="comment">//输出 &quot;12&quot;</span></span><br><span class="line">alert(iNum.toString(<span class="number">16</span>));       <span class="comment">//输出 &quot;A&quot; </span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>String()方法，对于number和Boolean的转换，实际上调用的是toString的方法，但是对于null和undefined，会直接转换为null和undefined</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="literal">null</span>)    <span class="comment">//null</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">undefined</span>)   <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><ol>
<li>使用number函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;324&#x27;</span>) <span class="comment">// 324</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;324abc&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">5</span>]) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>parseInt() &amp; parseFloat()</li>
</ol>
<ul>
<li>Boolean()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">alert(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> y = <span class="built_in">Boolean</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (y) &#123;</span><br><span class="line">alert(<span class="string">&#x27;hello&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">false</span>)  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)) <span class="comment">// true,这里实际上是传递的一个对象</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：在JS中，只有0，-0，NaN，””，undefined,null这六个值转换为布尔值时，结果才会是false。而所有的对象转化为布尔值时，结果都会是true！</strong><br>所以上面题目的第一部分，有new关键字，所以X就是一个新对象，结果就会输出hi。<br>题目的第二部分，没有new关键字，所以就是进行显示类型的转换，0转换为false，结果域加new的时候相反。</p>
<h1 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h1><ol>
<li>自动转换为布尔值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abc</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;abc&#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;  <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>自动转换为数值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> * <span class="string">&#x27;2&#x27;</span> <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">true</span> - <span class="number">1</span>  <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> - <span class="number">1</span>   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>自动转换为字符串</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="number">1</span> <span class="comment">// &#x27;51&#x27;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">true</span> <span class="comment">// &quot;5true&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">false</span> <span class="comment">// &quot;5false&quot;</span></span><br><span class="line"> <span class="string">&#x27;5&#x27;</span> - <span class="literal">true</span>  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>js中的四则运算</p>
<ul>
<li>运算中其中⼀⽅为字符串，那么就会把另⼀⽅也转换为字符串 </li>
<li>如果⼀⽅不是字符串或者数字，那么会将它转换为数字或者字符串</li>
</ul>
<h1 id="JavaScript中的类型检测"><a href="#JavaScript中的类型检测" class="headerlink" title="JavaScript中的类型检测"></a>JavaScript中的类型检测</h1><ol>
<li>typeof</li>
</ol>
<p>使用typeof，返回的结果有：String number boolean undefined Object function symbol</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;a&#x27;</span>)   <span class="comment">//  String</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2</span>)     <span class="comment">//  number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>)  <span class="comment">//  boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>)   <span class="comment">//  undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Object</span>)    <span class="comment">//  Object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>)    <span class="comment">//  Object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>)    <span class="comment">//  function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>)  <span class="comment">//  function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Symbol</span>)    <span class="comment">//  function</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>)   //  报错</span></span><br><span class="line"><span class="function"> <span class="title">console</span>.<span class="title">log</span>(<span class="params"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()</span>)    //  <span class="title">symbol</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>instanceof</li>
</ol>
<p>判断某个对象的原型链上是否存在其构造函数的prototype的属性</p>
<p>所以instanceof的原理，可以理解为，实例对象的__proto__属性和构造函数的prototype属性指向的是不是同一个地址</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;312&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str <span class="keyword">instanceof</span> <span class="built_in">String</span>)		<span class="comment">//false，因为str只是一个以string为数据类型的值，但并不属于String对象的实例</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>()</span><br><span class="line"><span class="built_in">console</span>.log(str <span class="keyword">instanceof</span> <span class="built_in">String</span>)		<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>)       <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Object</span>)      <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Object.prototype.toString.call()</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//除了能够判断基本类型之外，还能判断原生引用另外类型</span></span><br><span class="line"><span class="built_in">Function</span> <span class="function"><span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(“test”);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(fn); <span class="comment">// &quot;[object Function]&quot;  函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(date); <span class="comment">// &quot;[object Date]&quot;    日期 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr); <span class="comment">// &quot;[object Array]&quot;    数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[hbc]at/gi</span>;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(reg); <span class="comment">// &quot;[object RegExp]&quot;   正则</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;Rose&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr); <span class="comment">// &quot;[object Object]&quot;     自定义类型</span></span><br><span class="line">conslole.log(person <span class="keyword">instanceof</span> Person)    <span class="comment">//在这里使用instanceof更合理</span></span><br></pre></td></tr></table></figure>

<h1 id="值类型与引用类型的差别"><a href="#值类型与引用类型的差别" class="headerlink" title="值类型与引用类型的差别"></a>值类型与引用类型的差别</h1><ol>
<li>基本类型在内存中占据固定大小的空间，因此被保存在栈内存中</li>
<li>从一个变量向另一个变量复制基本类型的值，复制的是值的副本</li>
<li>引用类型的值是对象，保存在堆内存</li>
<li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针</li>
<li>从一个变量向另一个变量复制引用类型的值的时候，复制是引用指针，因此两个变量最终都指向同一个对象</li>
</ol>
<h1 id="判断是否是数组的几种方法"><a href="#判断是否是数组的几种方法" class="headerlink" title="判断是否是数组的几种方法"></a>判断是否是数组的几种方法</h1><ol>
<li>使用instanceof方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[]</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>) </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用constructor方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([].constructor == <span class="built_in">Array</span>);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用Object.prototype.toString.call(arr)</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr))		<span class="comment">//[object Array]</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Array.isArray()</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr))				<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Array.prototype.isPrototypeOf(obj)</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf([])   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leslie choi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
