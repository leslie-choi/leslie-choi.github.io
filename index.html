<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="404 not found">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="404 not found">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="404 not found">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>404 not found</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">404 not found</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/25/css/移动端常见问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/25/css/移动端常见问题/" itemprop="url">移动端常见问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-25T20:29:25+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/CSS/" itemprop="url" rel="index">
                    <span itemprop="name">CSS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="300毫秒延迟的由来和解决方法"><a href="#300毫秒延迟的由来和解决方法" class="headerlink" title="300毫秒延迟的由来和解决方法"></a>300毫秒延迟的由来和解决方法</h1><ol>
<li><p>300 毫秒延迟的主要原因是解决双击缩放。双击缩放，顾名思义，即用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 那么这和 300 毫秒延迟有什么联系呢？ 假定这么一个场景。用户在 iOS Safari 里边点击了一个链接。由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。 <strong>鉴于iPhone的成功，其他移动浏览器都复制了 iPhone Safari 浏览器的多数约定，包括双击缩放，几乎现在所有的移动端浏览器都有这个功能。</strong></p>
</li>
<li><p>解决方案</p>
</li>
</ol>
<ul>
<li>粗暴型，禁用缩放，添加viewport meta标签</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用fastclick</li>
</ul>
<p>移动端事件触发顺序：在移动端，手指点击一个元素，会经过：touchstart –&gt; touchmove -&gt; touchend –&gt;click。</p>
<p>fastclick.js的原理是：FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即触发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉。</p>
<h1 id="SPA单页面应用优化"><a href="#SPA单页面应用优化" class="headerlink" title="SPA单页面应用优化"></a>SPA单页面应用优化</h1><ol>
<li>SSR服务端渲染直出</li>
</ol>
<p>服务端渲染主要有两个目的，一是 SEO，二是加快内容展现。<br>在带来这两个好处的同时，<strong>我们也需要评估服务端渲染的成本，首先我们需要服务端的支持，因此涉及到了服务构建、部署等，同时 web 项目是一个流量较大的网站，也需要考虑服务器的负载，以及相应的缓存策略，</strong>特别像我们行业，由于地理位置的不同，不同用户看到的页面也是不一样的，也就是所谓的千人千面，这也为缓存造成了一定困难。</p>
<p>ssr是Server-Side Rendering的简写，即由服务端负责渲染页面直出，亦即同构应用。程序的大部分代码都可以在服务端和客户端运行。在服务端vue组件渲染为html字符串，然后直接返回给客户端，在客户端生成dom和操作dom。</p>
<p>能在服务端渲染为html字符串得益于vue组件结构是基于vnode的。vnode是dom的抽象表达，它不是真实的dom，它是由js对象组成的树，每个节点代表了一个dom。因为vnode，所以在服务端vue可以把js对象解析为html字符串。同样在客户端vnode因为是存在内存之中的，操作内存总比操作dom快的多，每次数据变化需要更新dom时，新旧vnode树经过diff算法，计算出最小变化集，大大提高了性能。</p>
<p><strong>服务端渲染 SSR 的优缺点如下：</strong></p>
<p>(1) 服务端渲染的优点：</p>
<ul>
<li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面</li>
<li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间</li>
</ul>
<p>(2) 服务端渲染的缺点：</p>
<ul>
<li>更多的开发条件限制： <strong>例如服务端渲染只支持 beforCreate 和 created 两个钩子函数</strong>，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
<li>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>
<ol start="2">
<li>使用预渲染</li>
</ol>
<p>所谓预渲染，就是在项目的构建过程中，通过一些渲染机制，比如 puppeteer或者 jsdom 将页面在构建的过程中就渲染好，然后插入到 html 中，这样在页面启动之前首先看到的就是预渲染的页面了。<br>预渲染渲染的页面数据是在构建过程中就已经打包到了 html 中， 当真实访问页面的时候，真实数据可能已经和预渲染的数据有了很大的出入，而且预渲染的页面也是一个不可交互的页面，在页面没有启动之前，用户无法和预渲染的页面进行任何交互，预渲染页面中的数据反而会影响到用户获取真实的信息，当涉及到一些价格、金额、地理位置的地方甚至会导致用户做出一些错误的决定。</p>
<ol start="3">
<li>使用骨架图</li>
</ol>
<p>骨架页面（Skeleton Page）指的是当你打开一个移动端 web 页面，在页面解析和数据加载之前，首先给用户展示页面的大概样式。在骨架页面中，图片、文字、图标都将通过灰色矩形块或圆形块来展示，在真实页面展示之前，用户能够感知到即将加载页面的基本 CSS 样式和页面布局。</p>
<p>当然骨架图可以自己写，也可以使用插件vue-skeleton-webpack-plugin。</p>
<ol start="4">
<li>使用offline-plugin搭配webpack轻松实现PWA进行优化</li>
</ol>
<p>使用PWA的离线缓存，类似于HTTP cache缓存，但是相对来说缓存更可控。</p>
<h1 id="科普PWA"><a href="#科普PWA" class="headerlink" title="科普PWA"></a>科普PWA</h1><p>PWA(Progressive web apps, 渐进式Web应用)</p>
<ul>
<li>可以生成桌面小图标，不需要打开浏览器，方便用户访问</li>
<li>通过网络缓存提升页面访问速度，达到渐进式的页面甚至离线访问，提升用户体验</li>
<li>实现类似app的推送功能，生成系统通知推送给用户</li>
</ul>
<p>service worker是实现PWA的核心，service worker是一个独立的浏览器线程，不会对当前程序的执行线程造成阻塞，通过service worker可以实现页面离线访问、用户消息推送等功能。<br>使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p>
<p>Service Worker 实现缓存功能一般分为三个步骤：</p>
<ul>
<li>首先需要先注册 Service Worker</li>
<li>然后监听到 install 事件以后就可以缓存需要的文件</li>
<li>下次用户访问的时候就可以通过<strong>拦截请求的方式</strong>查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据</li>
</ul>
<p>PWA确实是当下很热门的技术，因为它提升了web应用的体验，甚至达到可以和原生app体验相提并论，但是它的问题就是兼容性问题，相信如果兼容性问题得到解决，这种技术一定会被大面积推广到实际应用。iOS11.3之前都不支持，因此vue cli3脚手架在集成时默认在ios下是关闭的</p>
<h1 id="移动端资源压缩"><a href="#移动端资源压缩" class="headerlink" title="移动端资源压缩"></a>移动端资源压缩</h1><p>我们常将网络性能优化措施归结为三大方面：减少请求数、减小请求资源体积、提升网络传输速率。</p>
<ol>
<li>JS 压缩</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">        minimizer: [</span><br><span class="line">            <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">                cache: <span class="literal">true</span>,</span><br><span class="line">                parallel: <span class="literal">true</span>,</span><br><span class="line">                sourceMap: <span class="literal">true</span> <span class="comment">// set to true if you want JS source maps</span></span><br><span class="line">            &#125;),</span><br><span class="line">            ...Plugins</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>HTML 压缩：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: __dirname + <span class="string">'/views/index.html'</span>, <span class="comment">// new 一个这个插件的实例，并传入相关的参数</span></span><br><span class="line">            filename: <span class="string">'../index.html'</span>,</span><br><span class="line">            minify: &#123;</span><br><span class="line">                removeComments: <span class="literal">true</span>,</span><br><span class="line">                collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">                removeRedundantAttributes: <span class="literal">true</span>,</span><br><span class="line">                useShortDoctype: <span class="literal">true</span>,</span><br><span class="line">                removeEmptyAttributes: <span class="literal">true</span>,</span><br><span class="line">                removeStyleLinkTypeAttributes: <span class="literal">true</span>,</span><br><span class="line">                keepClosingSlash: <span class="literal">true</span>,</span><br><span class="line">                minifyJS: <span class="literal">true</span>,</span><br><span class="line">                minifyCSS: <span class="literal">true</span>,</span><br><span class="line">                minifyURLs: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            chunksSortMode: <span class="string">'dependency'</span></span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>提取公共资源：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123; <span class="comment">// 抽离第三方插件</span></span><br><span class="line">          test: <span class="regexp">/node_modules/</span>, <span class="comment">// 指定是 node_modules 下的第三方包</span></span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          name: <span class="string">'common/vendor'</span>, <span class="comment">// 打包后的文件名，任意命名    </span></span><br><span class="line">          priority: <span class="number">10</span> <span class="comment">// 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包</span></span><br><span class="line">        &#125;,</span><br><span class="line">        utils: &#123; <span class="comment">// 抽离自定义公共代码</span></span><br><span class="line">          test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          name: <span class="string">'common/utils'</span>,</span><br><span class="line">          minSize: <span class="number">0</span> <span class="comment">// 只要超出 0 字节就生成一个新包</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>提取 css 并压缩：</li>
</ol>
<p>在使用 webpack 的过程中，我们通常会以模块的形式引入 css 文件（webpack 的思想不就是万物皆模块嘛），但是在上线的时候，我们还需要将这些 css 提取出来，并且压缩，这些看似复杂的过程只需要简单的几行配置就行：<br>（PS: 我们需要用到mini-css-extract-plugin ，所以还得大家自行 npm install）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [..., &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            use: [</span><br><span class="line">                _mode === <span class="string">'development'</span> ? <span class="string">'style-loader'</span> : MiniCssExtractPlugin.loader, &#123;</span><br><span class="line">                    loader: <span class="string">'css-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        importLoaders: <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        ident: <span class="string">'postcss'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>将 webpack 开发环境修改为生产环境：</li>
</ol>
<p>在使用 webpack 打包项目时，它常常会引入一些调试代码，以作相关调试，我们在上线时不需要这部分内容，通过配置剔除：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool: <span class="string">'false'</span></span><br></pre></td></tr></table></figure>
<p>最后，我们还应该在服务器上开启 Gzip 传输压缩，它能将我们的文本类文件体积压缩至原先的四分之一，效果立竿见影，还是切换到我们的 nginx 配置文档，添加如下两项配置项目：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip on;</span><br><span class="line">gzip_types text/plain application/javascriptapplication/x-javascripttext/css application/xml text/javascriptapplication/x-httpd-php application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml;</span><br></pre></td></tr></table></figure>
<p><strong>特别注意！不要对图片文件进行 Gzip 压缩！</strong></p>
<ol start="7">
<li>使用雪碧图</li>
</ol>
<p>雪碧图的概念大家一定在生活中经常听见，其实雪碧图是减小请求数的显著运用。而且很奇妙的是，多张图片聘在一块后，总体积会比之前所有图片的体积之和小（你可以亲自试试）。这里给大家推荐一个自动化生成雪碧图的工具：<a href="https://www.toptal.com/developers/css/sprite-generator（图片来自官网首页）" target="_blank" rel="noopener">https://www.toptal.com/developers/css/sprite-generator（图片来自官网首页）</a></p>
<p>只要你添加相关资源文件，他就会自动帮你生成雪碧图以及对应的 CSS 样式。</p>
<ol start="8">
<li>使用字体图标（iconfont）</li>
</ol>
<p>无论是压缩后的图片，还是雪碧图，终归还是图片，只要是图片，就还是会占用大量网络传输资源。但是字体图标的出现，却让前端开发者看到了另外一个神奇的世界。</p>
<p>我最喜欢用的是阿里矢量图标库（网址：<a href="http://www.iconfont.cn/），里面有大量的矢量图资源，而且你只需要像在淘宝采购一样把他们添加至购物车就能把它们带回家，整理完资源后还能自动生成CDN" target="_blank" rel="noopener">http://www.iconfont.cn/），里面有大量的矢量图资源，而且你只需要像在淘宝采购一样把他们添加至购物车就能把它们带回家，整理完资源后还能自动生成CDN</a> 链接，可以说是完美的一条龙服务了。（图片来自官网首页）</p>
<p>图片能做的很多事情，矢量图都能作，<strong>而且它只是往 HTML 里插入字符和 CSS 样式而已，和图片请求比起来资源占用完全不在一个数量级，</strong>如果你的项目里有小图标，就是用矢量图吧。</p>
<h1 id="1像素边框问题"><a href="#1像素边框问题" class="headerlink" title="1像素边框问题"></a>1像素边框问题</h1><ol>
<li><p>物理像素<br>移动设备出厂时，不同设备自带的不同像素，也称硬件像素；</p>
</li>
<li><p>逻辑像素<br>即css中像素，和设备屏幕的像素没有必然的关系</p>
</li>
<li><p>dpr(devicePixelRatio)设备像素比</p>
</li>
</ol>
<p>dpr = 物理像素/css像素</p>
<p>这就是为什么移动端css里面写了1px, 实际看起来比1px粗. 其实原因很好理解。因为css中的1px并不等于移动设备的1px，而是变成了2px。一般设计是根据iphone6的dpr = 2标准进行设计的。</p>
<p>解决方法：</p>
<ul>
<li><p>使用border-image</p>
</li>
<li><p>伪类 + transform</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">li&#123;<span class="attr">position</span>: relative;&#125;</span><br><span class="line"></span><br><span class="line">li:after&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom:<span class="number">0</span>;</span><br><span class="line">    left:<span class="number">0</span>;</span><br><span class="line">    content: <span class="string">''</span>;</span><br><span class="line">    width:<span class="number">100</span>%;</span><br><span class="line">    height:<span class="number">1</span>px;</span><br><span class="line">    border-top:<span class="number">1</span>px solid black;</span><br><span class="line">    transform: scaleY(<span class="number">0.5</span>);<span class="comment">//注意兼容性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>viewport + rem</li>
</ul>
<p>同时通过设置对应viewport的rem基准值，这种方式就可以像以前一样轻松愉快的写1px了。</p>
<p>在devicePixelRatio = 2 时，输出viewport：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在devicePixelRatio = 3 时，输出viewport：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这种兼容方案相对比较完美，适合新的项目，老的项目修改成本过大</p>
<p>使用rem布局时，个人习惯将字体设置为50px(浏览器默认是16px)，这样在换算成rem单位的时候，就可以直接乘以0.2就好了。（50px换算成10rem）</p>
<p><a href="https://juejin.im/post/5bcc169ae51d450e85308d86" target="_blank" rel="noopener">首页白屏的引发的思考(一)</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247489586&amp;idx=1&amp;sn=2168d42df837521da50b3ed7f8932698&amp;chksm=f951ad71ce262467728b7940de1a2311c523f264f4ca7e705712bf655a844fab93706cbe1ca3&amp;token=1792152421&amp;lang=zh_CN#rd" target="_blank" rel="noopener">首屏时间从12.67s到1.06s，我是如何做到的？</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/21/前后端通信方式/ajax、axios、fetch的区别/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/前后端通信方式/ajax、axios、fetch的区别/" itemprop="url">ajax、axios、fetch的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-21T11:43:20+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>背景</strong></p>
<p>前端的技术发展速度非常的快，异步请求也是其重要的体现之一，从最早的原生XHR，再到JqueryAjax的统治时代，再到近来，fetch、axios等技术也开始出现并大量投入使用。</p>
<h1 id="原生Ajax"><a href="#原生Ajax" class="headerlink" title="原生Ajax"></a>原生Ajax</h1><p>Ajax是指一种<strong>创建交互式网页应用</strong>的网页开发技术，并且可以做到无需重新加载整个网页的情况下，能够更新部分网页，也叫作局部更新。是最早出现的发送后端请求技术，隶属于原始js中，核心是使用XMLHttpRequest对象，多个请求之间如果有先后关系的话，就会出现回调地狱。</p>
<p><strong>使用步骤：</strong><br>1.创建XmlHttpRequest对象<br>2.调用open方法设置基本请求信息<br>3.设置发送的数据，发送请求（send）<br>4.注册监听的回调函数（onreadystatechange）<br>5.拿到返回值，对页面进行更新</p>
<p><strong>状态值：</strong></p>
<p>0    请求还未初始化，还未调用open()          —-未初始化<br>1    请求已建立但未发送，还未调用send()       —-载入<br>2    接受原始响应数据，为解析做准备            —-载入完成<br>3    正在解析数据                             —-解析<br>4    响应完成，数据解析完成                     —-解析完成</p>
<p><strong>优点：可以实现局部刷新，并且原生支持不需要使用任何插件</strong></p>
<p><strong>缺点：可能破坏浏览器后退功能，并且会出现回调地狱</strong></p>
<h1 id="Jquery-Ajax"><a href="#Jquery-Ajax" class="headerlink" title="Jquery Ajax"></a>Jquery Ajax</h1><p>jquery的ajax就是在原生的ajax的基础上进行了封装，并且添加上了对JSONP的支持。</p>
<p>优点：</p>
<ul>
<li>使用方便</li>
</ul>
<p>缺点：</p>
<ul>
<li>本身是针对mvc的编程模式，不太适合目前mvvm的编程模式</li>
<li>jQuery本身比较大，如果单纯的使用ajax可以自己封装一个，不然会影响性能体验</li>
<li>回调地狱</li>
</ul>
<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>axios是vue官方推荐使用的一个库，<strong>axios 一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，</strong>不是原生js,使用时需要对其进行安装，符合最新的ES规范，它本身具有以下优点：</p>
<ul>
<li>支持 Promise API</li>
<li>客户端支持防止CSRF</li>
<li>自动转换JSON数据</li>
<li>从 node.js 创建 http 请求</li>
<li>拦截请求和响应</li>
<li>从浏览器中创建 XMLHttpReques</li>
</ul>
<p>PS:防止CSRF:就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，假冒的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。</p>
<h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><p>fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(url).then(fun2)</span><br><span class="line">        .then(fun3)</span><br><span class="line">        .....</span><br><span class="line">        .catch(fun)</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>解决回调地狱</li>
<li>使用起来更加简洁<br>缺点：</li>
<li>API 偏底层，需要封装</li>
<li>默认不带Cookie，需要手动添加</li>
<li>浏览器支持情况不是很友好，需要第三方的ployfill</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ajax是最早出现发送后端请求的技术，属于原生js范畴,核心是使用XMLHttpRequest对象,使用较多并有先后顺序的话，容易产生回调地狱。</p>
<p>fetch号称可以代替ajax的技术，是基于es6中的Promise对象设计的，参数和jQuery中的ajax类似，它并不是对ajax进一步封装，它属于原生js范畴。没有使用XMLHttpRequest对象。</p>
<p>axios不是原生js,使用时需要对其进行安装，客户端和服务器端都可以使用，可以在请求和响应阶段进行拦截，基于promise对象。<br>axios既提供了并发的封装，也没有fetch的各种问题，而且体积也较小，当之无愧现在最应该选用的请求的方式。这大概就是目前官方推荐使用axios的原因了吧。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.csdn.net/jennyya/article/details/83687622" target="_blank" rel="noopener">ajax、fetch、axios区别</a><br><a href="https://www.jianshu.com/p/8bc48f8fde75" target="_blank" rel="noopener">ajax和axios、fetch的区别</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/27/vue/vue常见面试题目/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/27/vue/vue常见面试题目/" itemprop="url">vue常见面试题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-27T10:43:20+08:00">
                2019-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MVVM的理解"><a href="#MVVM的理解" class="headerlink" title="MVVM的理解"></a>MVVM的理解</h1><p>MVVM 模式，顾名思义即 Model-View-ViewModel 模式,是一个软件架构设计模式。</p>
<ol>
<li><p>Model 层: 对应数据层模型，它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。</p>
</li>
<li><p>View 层：作为视图模板存在，在 MVVM 里，整个 View 是一个动态模板。除了定义结构、布局外，它展示的是 ViewModel 层的数据和状态。View 层不负责处理状态，View 层做的是 数据绑定的声明、 指令的声明、 事件绑定的声明。</p>
</li>
<li><p>ViewModel 层(核心):MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，<strong>因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</strong> 这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。<br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/MVVM.png" alt="markdown"></p>
<h2 id="MVVM的优缺点"><a href="#MVVM的优缺点" class="headerlink" title="MVVM的优缺点"></a>MVVM的优缺点</h2></li>
</ol>
<p><strong>优点</strong></p>
<ol>
<li><p>分离视图（View）和模型（Model）,降低代码耦合，提高视图或者逻辑的重用性。</p>
</li>
<li><p>提高可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码</p>
</li>
<li><p>自动更新dom: 利用双向绑定,数据更新后视图自动更新，让开发者从繁琐的手动更新dom中解放</p>
</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><p>Bug很难被调试: 因为使用双向绑定的模式，当你看到界面异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的</p>
</li>
<li><p>一个大的模块中model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存</p>
</li>
<li><p>对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高</p>
</li>
</ol>
<h2 id="MVVM和MVC的区别是什么？与其他框架（jquery）的区别是什么？哪些场景适合？"><a href="#MVVM和MVC的区别是什么？与其他框架（jquery）的区别是什么？哪些场景适合？" class="headerlink" title="MVVM和MVC的区别是什么？与其他框架（jquery）的区别是什么？哪些场景适合？"></a>MVVM和MVC的区别是什么？与其他框架（jquery）的区别是什么？哪些场景适合？</h2><p>mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</p>
<p>区别：vue数据驱动，通过数据来显示视图层而不是节点操作。<br>场景：数据操作比较多的场景，更加便捷</p>
<h1 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h1><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是Vue的生命周期。</p>
<ol>
<li><p>beforeCreate:挂载元素el和数据对象都是为undefined<br>dom元素都没有被创建出来，在这个期间我们一般不做事情</p>
</li>
<li><p>created：挂载元素el未初始化，但是data和methods都已经被初始化好了（最重要）<br>数据和data中的数据绑定完成，这里我们可以做初级的数据获取，ajax请求最好放在created里面，因为此时已经可以访问this了，请求到数据就可以直接放在data里面。</p>
</li>
<li><p>beforeMount：挂载元素el和data已经初始化，但是此时是虚拟dom节点</p>
</li>
<li><p>mounted：Vue实例挂载完成，数据成功渲染（最重要）<br>官方实例的异步请求是在mounted生命周期中调用的，而实际上也可以在created生命周期中调用(推荐，因为在服务端并没有这个钩子)。</p>
</li>
</ol>
<p>只要执行完整个mounted，就表示整个Vue实例已经完成初始化。此时组件已经脱离了创建阶段，进入运行阶段<br>运行阶段的两个生命周期函数，这两个事件会根据data数据的改变，有选择性触发0到多次</p>
<ol start="5">
<li><p>beforeUpdate：表示界面还没有被更新，但是数据被更新了</p>
</li>
<li><p>update： 事件执行的时候，页面和data数据已经保持同步，都是最新的</p>
</li>
<li><p>beforeDestroy：执行该函数的时候，实例身上的所有data和所有的methods以及过滤器、指令等等都处于可用状态，还没有真正执行销毁的过程</p>
</li>
<li><p>Destroyed：执行到该函数的时候，组件中的而所有数据、方法、指令过滤器都不可用</p>
</li>
</ol>
<p>除了以上8个比较常见的生命周期之外，vue其实还有其他3个生命周期</p>
<p>如果我们在组件中使用了keep-alive用来缓存组件,避免多次加载相应的组件,减少性能消耗，那么这个时候生命周期会多出来两个，并且上面的8个生命周期钩子将会失效。</p>
<ol start="9">
<li><p>activated：被包裹的组件被激活的状态下使用的生命周期钩子。</p>
</li>
<li><p>deactivated：在被包裹的组件停止的时候停用。</p>
</li>
<li><p>errorCaptured: 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</p>
</li>
</ol>
<h1 id="Vue组件之间的通信"><a href="#Vue组件之间的通信" class="headerlink" title="Vue组件之间的通信"></a>Vue组件之间的通信</h1><ul>
<li><strong>props/$emit+v-on: 通过props将数据自上而下传递，而通过$emit和v-on来向上传递信息。</strong> （适用于父子组件之间的通信）</li>
<li>EventBus: 通过EventBus进行信息的发布与订阅</li>
<li><strong>vuex: 是全局数据管理库，可以通过vuex管理全局的数据流</strong></li>
<li>$attrs/$listeners: Vue2.4中加入的$attrs/$listeners可以进行跨级的组件通信 （适用于 隔代组件通信）</li>
<li>provide/inject：祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。（适用于 隔代组件通信）</li>
</ul>
<h1 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h1><p>单向数据流指只能从一个方向修改数据，姑且我们可以这样理解，如下图所示。一个父组件下有两个子组件1和子组件2，父组件可以向子组件传递数据。假如子组件都获取到了父组件的name，在子组件1中对name重新修改之后，子组件2和父组件中的值并不会发生改变，这正是因为Vue中的机制是单向数据流，子组件不能直接改变父组件的状态。但反过来，如果是父组件中的name修改了，当然两个子组件中的name也就改变了。</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/FtoC.png" alt="markdown"></p>
<h1 id="Vuex状态管理"><a href="#Vuex状态管理" class="headerlink" title="Vuex状态管理"></a>Vuex状态管理</h1><p>Vuex 是单向数据流的一种实现。</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/dangxiang.png" alt="markdown"></p>
<p>一个应用可以看作是由上面三部分组成: View, Actions,State,数据的流动也是从View =&gt; Actions =&gt; State =&gt;View 以此达到数据的单向流动。但是，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：</p>
<ul>
<li>多个视图依赖于同一状态。</li>
<li>来自不同视图的行为需要变更同一状态。</li>
</ul>
<p>当项目较大, 组件嵌套过多的时候,使用传参的方式会变得非常繁琐 多组件共享同一个State会在数据传递时出现很多问题.Vuex就是为了解决这些问题而产生的。<br>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。</p>
<ol>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。<br>主要包括以下几个模块：</li>
</ol>
<ul>
<li>State：存放基本数据，可以在这里设置默认的初始状态。用 this.$store.state 来访问。</li>
<li>Getters：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li>
<li>Mutations：是唯一更改 store 中状态的方法，且必须是同步函数。用 this.$store.commit(‘xxx’, data) 来通知 Mutations 来改状态。</li>
<li>Actions：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。用 this.$store.dispatch(‘xxx’, data) 来存触发 Action。</li>
<li>Modules：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中,模块化vuex。</li>
</ul>
<p><strong>完整流程：</strong></p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/vuex.png" alt="markdown"></p>
<p>Vuex原理<br>一个实例化的Vuex.Store由state, mutations和actions三个属性组成:</p>
<ul>
<li>state中保存着共有数据</li>
<li>改变state中的数据有且只有通过mutations中的方法,且mutations中的方法必须是同步的</li>
<li>如果要写异步的方法,需要些在actions中, 并通过commit到mutations中进行state中数据的更改</li>
</ul>
<h1 id="Vue实现双向数据绑定"><a href="#Vue实现双向数据绑定" class="headerlink" title="Vue实现双向数据绑定"></a>Vue实现双向数据绑定</h1><p>是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。在vue3.0中通过Proxy代理对象进行类似的操作。</p>
<p>Vue主要通过以下4个步骤实现双向数据绑定</p>
<ul>
<li>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</li>
<li>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</li>
<li>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</li>
<li>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</li>
</ul>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/observer.png" alt="markdown"><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> name=<span class="string">"数据绑定"</span> id=<span class="string">"dataBinding"</span>&gt;</span><br><span class="line">&lt;span id=<span class="string">"data"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">mounted() &#123;</span></span><br><span class="line"><span class="xml">    this.showData()</span></span><br><span class="line"><span class="xml">&#125;,</span></span><br><span class="line"><span class="xml">methods:&#123;</span></span><br><span class="line"><span class="xml">      showData()&#123;</span></span><br><span class="line"><span class="xml">          var obj1 = &#123;&#125;;                        //新建一个对象obj1</span></span><br><span class="line"><span class="xml">          Object.defineProperty(obj1,'hello',&#123;  //为obj定义一个名为 hello 的访问器属性 </span></span><br><span class="line"><span class="xml">              set: function(newVal)&#123;</span></span><br><span class="line"><span class="xml">                  document.getElementById('dataBinding').value = newVal;</span></span><br><span class="line"><span class="xml">                  document.getElementById('data').innerHTML = newVal;</span></span><br><span class="line"><span class="xml">              &#125;,</span></span><br><span class="line"><span class="xml">              get: function()&#123;</span></span><br><span class="line"><span class="xml">                  return</span></span><br><span class="line"><span class="xml">              &#125;</span></span><br><span class="line"><span class="xml">          &#125;);</span></span><br><span class="line"><span class="xml">          document.addEventListener('keyup',function(e)&#123;</span></span><br><span class="line"><span class="xml">              obj1.hello = e.target.value;</span></span><br><span class="line"><span class="xml">          &#125;);</span></span><br><span class="line"><span class="xml">          console.log(obj1);</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="computed和watch有什么区别"><a href="#computed和watch有什么区别" class="headerlink" title="computed和watch有什么区别?"></a>computed和watch有什么区别?</h1><ul>
<li><strong>computed:</strong></li>
</ul>
<p>computed是计算属性,也就是计算值,它更多用于计算值的场景<br>computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算<br>computed适用于计算比较消耗性能的计算场景</p>
<ul>
<li><strong>watch:</strong></li>
</ul>
<p>更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作<br>无缓存性，页面重新渲染时值不变化也会执行</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"demo"</span>&gt;&#123;&#123; fullName &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: '#demo',</span></span><br><span class="line"><span class="regexp">  data: &#123;</span></span><br><span class="line"><span class="regexp">    firstName: 'Foo',</span></span><br><span class="line"><span class="regexp">    lastName: 'Bar',</span></span><br><span class="line"><span class="regexp">    fullName: 'Foo Bar'</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  watch: &#123;</span></span><br><span class="line"><span class="regexp">    firstName: function (val) &#123;</span></span><br><span class="line"><span class="regexp">      this.fullName = val + ' ' + this.lastName</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    lastName: function (val) &#123;</span></span><br><span class="line"><span class="regexp">      this.fullName = this.firstName + ' ' + val</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  computed: &#123;</span></span><br><span class="line"><span class="regexp">    fullName: function () &#123;</span></span><br><span class="line"><span class="regexp">      return this.firstName + ' ' + this.lastName</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure>
<p>虽然说methods和computed、watch都可以完成相同的功能，但是需要根据不同的场景选择对应的方法，大多数场景下，使用computed属性，能够在简化代码的同时，提高性能。</p>
<p>小结:</p>
<ul>
<li>当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的</li>
</ul>
<h1 id="computed实现原理"><a href="#computed实现原理" class="headerlink" title="computed实现原理"></a>computed实现原理</h1><ul>
<li>初始化data，使用Object.defineProperty将这些属性转化为getter/setter</li>
<li>初始化computed，遍历computed里面的每个属性，每一个computed属性都是一个watch实例。每个属性提供的函数作为属性的getter，然后使用Object.defineProterty转化</li>
<li>Object.defineProterty依赖收集，用于依赖发生变化的时候，触发属性重新计算</li>
<li>若出现当前computed计算属性嵌套其他computed计算属性时，先计算其他的依赖收集</li>
</ul>
<h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><ol>
<li>什么是虚拟DOM</li>
</ol>
<p>虚拟DOM其实就是一个JavaScript对象。通过这个JavaScript对象来描述真实DOM。</p>
<ol start="2">
<li>为什么要使用虚拟DOM</li>
</ol>
<p>优点：</p>
<ul>
<li><p>保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此框架的虚拟 DOM至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</p>
</li>
<li><p>无需手动操作DOM: 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，极大提高开发效率</p>
</li>
<li><p>跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等</p>
</li>
</ul>
<p>缺点:</p>
<ul>
<li>无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化,比如VScode采用直接手动操作DOM的方式进行极端的性能优化</li>
</ul>
<h1 id="虚拟DOM的实现原理"><a href="#虚拟DOM的实现原理" class="headerlink" title="虚拟DOM的实现原理"></a>虚拟DOM的实现原理</h1><ul>
<li><p>用JS对象描述出DOM树的结构，然后在初始化构建中，用这个描述树去构建真正的DOM，并实际展现到页面中</p>
</li>
<li><p>使用diff算法，当有数据状态变更时，重新构建一个新的JS的DOM树，通过新旧对比DOM树的变化diff，<strong>并记录两棵树差异</strong></p>
</li>
<li><p>使用patch算法，将两个虚拟 DOM 对象的差异应用到真正的 DOM 树，视图也就更新了。所以虚拟dom的本质可以理解为在JS和DOM之间做了一个缓存。 </p>
</li>
</ul>
<h1 id="如何理解Vue的响应式系统？"><a href="#如何理解Vue的响应式系统？" class="headerlink" title="如何理解Vue的响应式系统？"></a>如何理解Vue的响应式系统？</h1><p>响应式系统简述:</p>
<ul>
<li>任何一个 Vue Component 都有一个与之对应的 Watcher 实例。</li>
<li>Vue 的 data 上的属性会被添加 getter 和 setter 属性。</li>
<li>当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, <strong>getter 方法会被调用</strong> , 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)</li>
<li>data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新。</li>
</ul>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/vueWatcher.png" alt="markdown"></p>
<h1 id="谈谈你对-keep-alive-的了解？"><a href="#谈谈你对-keep-alive-的了解？" class="headerlink" title="谈谈你对 keep-alive 的了解？"></a>谈谈你对 keep-alive 的了解？</h1><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p>
<ul>
<li>一般结合路由和动态组件一起使用，用于缓存组件；</li>
<li>提供 include 和 exclude 属性(另外还有max参数，设置最大缓存组件的个数)，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，<strong>其中 exclude 的优先级比 include 高；</strong></li>
<li>对应两个生命周期钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li>
</ul>
<h1 id="组件中的data为什么是一个函数"><a href="#组件中的data为什么是一个函数" class="headerlink" title="组件中的data为什么是一个函数?"></a>组件中的data为什么是一个函数?</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// data</span></span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">	message: <span class="string">"子组件"</span>,</span><br><span class="line">	childName:<span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new Vue</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span>,</span><br><span class="line">  components: &#123;App&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>因为<strong>组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响</strong>，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 <strong>new Vue 的实例，是不会被复用的</strong>，因此不存在引用对象的问题。</p>
<h1 id="vue-ssr-服务端渲染"><a href="#vue-ssr-服务端渲染" class="headerlink" title="vue-ssr 服务端渲染"></a>vue-ssr 服务端渲染</h1><p>ssr是Server-Side Rendering的简写，即由服务端负责渲染页面直出，亦即同构应用。程序的大部分代码都可以在服务端和客户端运行。在服务端vue组件渲染为html字符串，然后直接返回给客户端，在客户端生成dom和操作dom。</p>
<p>能在服务端渲染为html字符串得益于vue组件结构是基于vnode的。vnode是dom的抽象表达，它不是真实的dom，它是由js对象组成的树，每个节点代表了一个dom。因为vnode所以在服务端vue可以把js对象解析为html字符串。同样在客户端vnode因为是存在内存之中的，操作内存总比操作dom快的多，每次数据变化需要更新dom时，新旧vnode树经过diff算法，计算出最小变化集，大大提高了性能。</p>
<p><strong>服务端渲染 SSR 的优缺点如下：</strong></p>
<p>(1) 服务端渲染的优点：</p>
<ul>
<li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面</li>
<li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间</li>
</ul>
<p>(2) 服务端渲染的缺点：</p>
<ul>
<li>更多的开发条件限制： <strong>例如服务端渲染只支持 beforCreate 和 created 两个钩子函数</strong>，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
<li>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>
<h1 id="vue-router-路由模式有几种？"><a href="#vue-router-路由模式有几种？" class="headerlink" title="vue-router 路由模式有几种？"></a>vue-router 路由模式有几种？</h1><p>vue-router 有 3 种路由模式：hash、history、abstract</p>
<ul>
<li>hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li>
<li>history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li>
<li>abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li>
</ul>
<h1 id="router的实现原理"><a href="#router的实现原理" class="headerlink" title="router的实现原理"></a>router的实现原理</h1><p><strong>更新视图而不重新请求页面</strong>,vue-router在实现单页面前端路由时，提供了两种方式：Hash模式和History模式；根据mode参数来决定采用哪一种方式。</p>
<ol>
<li>Hash模式：</li>
</ol>
<p>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。 hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说hash 出现在 URL 中，但<strong>不会被包含在 http 请求中，对后端完全没有影响</strong>，因此改变 hash 不会重新加载页面；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。hash 模式的原理是 <strong>onhashchange 事件(监测hash值变化)</strong>，可以在 window 对象上监听这个事件，从而进行页面的跳转和渲染</p>
<ol start="2">
<li>History模式：</li>
</ol>
<p>由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入”mode: ‘history’，不过这种模式需要后台再进行配置，如果后台配置不正确，访问页面则会返回404错误。HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p>
<p>history 路由模式的实现主要基于存在下面几个特性：</p>
<ul>
<li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li>
<li>我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li>
<li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li>
</ul>
<ol start="3">
<li>vue-router的使用方式</li>
</ol>
<ul>
<li>npm i vue-router -S下载路由</li>
<li>在main.js中引入 import VueRouter from ‘vue-router’;</li>
<li>安装插件Vue.use(VueRouter);</li>
<li>创建路由对象并配置路由规则 let router = new VueRouter({routes:[{path:’/home’,component:Home}]});</li>
<li>将其路由对象传递给Vue的实例，options中加入 router:router</li>
<li>在app.vue中留坑 <router-view></router-view><br>（router-view即页面中需要切换的部分）</li>
</ul>
<h1 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h1><p>有的时候，我们需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。</p>
<p>为此我们有很多种方法可以植入路由的导航过程：<strong>全局的, 单个路由独享的, 或者组件级的</strong></p>
<h2 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h2><ul>
<li>router.beforeEach 全局前置守卫 进入路由之前</li>
<li>router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用</li>
<li>router.afterEach 全局后置钩子 进入路由之后</li>
</ul>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js 入口文件</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span>; <span class="comment">// 引入路由</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123; </span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">router.beforeResolve(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'afterEach 全局后置钩子'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>to,from,next 这三个参数：</p>
<p>to和from是将要进入和将要离开的路由对象,路由对象指的是平时通过this.$route获取到的路由对象。</p>
<p>next:Function 这个参数是个函数，且必须调用，否则不能进入路由(页面空白)。</p>
<ul>
<li><p>next() 进入该路由。</p>
</li>
<li><p>next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。</p>
</li>
<li><p>next 跳转新路由，当前的导航被中断，重新开始一个新的导航。</p>
</li>
</ul>
<h2 id="路由独享守卫"><a href="#路由独享守卫" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h2><p>beforeEnter</p>
<p>如果你不想全局配置守卫的话，你可以为某些路由单独配置守卫</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/foo'</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123; </span><br><span class="line">        <span class="comment">// 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="路由组件内的守卫"><a href="#路由组件内的守卫" class="headerlink" title="路由组件内的守卫"></a>路由组件内的守卫</h2><ul>
<li>beforeRouteEnter 进入路由前</li>
<li>beforeRouteUpdate (2.2) 路由复用同一个组件时</li>
<li>beforeRouteLeave 导航离开该组件的对应路由时调用，我们用它来禁止用户离开，比如还未保存草稿，或者在用户离开前，将setInterval销毁，防止离开之后，定时器还在调用。</li>
</ul>
<h2 id="完整的路由导航解析流程"><a href="#完整的路由导航解析流程" class="headerlink" title="完整的路由导航解析流程"></a>完整的路由导航解析流程</h2><p>完整的路由导航解析流程(不包括其他生命周期)：</p>
<ul>
<li>触发进入其他路由。</li>
<li>调用要离开路由的组件守卫beforeRouteLeave</li>
<li>调用局前置守卫：beforeEach</li>
<li>在重用的组件里调用 beforeRouteUpdate</li>
<li>调用路由独享守卫 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在将要进入的路由组件中调用beforeRouteEnter</li>
<li>调用全局解析守卫 beforeResolve</li>
<li>导航被确认。</li>
<li>调用全局后置钩子的 afterEach 钩子。</li>
<li>触发DOM更新(mounted)。</li>
<li>执行beforeRouteEnter 守卫中传给 next 的回调函数</li>
</ul>
<h1 id="触发钩子的完整顺序"><a href="#触发钩子的完整顺序" class="headerlink" title="触发钩子的完整顺序"></a>触发钩子的完整顺序</h1><p>将路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件：</p>
<ol>
<li>beforeRouteLeave:路由组件的组件离开路由前钩子，可取消路由离开。</li>
<li>beforeEach: 路由全局前置守卫，可用于登录验证、全局路由loading等。</li>
<li>beforeEnter: 路由独享守卫</li>
<li>beforeRouteEnter: 路由组件的组件进入路由前钩子。</li>
<li>beforeResolve:路由全局解析守卫</li>
<li>afterEach:路由全局后置钩子</li>
<li>beforeCreate:组件生命周期，不能访问this。</li>
<li>created:组件生命周期，可以访问this，不能访问dom。</li>
<li>beforeMount:组件生命周期</li>
<li>deactivated: 离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</li>
<li>mounted:访问/操作dom。</li>
<li>activated:进入缓存组件，进入a的嵌套子组件(如果有的话)。</li>
<li>执行beforeRouteEnter回调函数next。</li>
</ol>
<h1 id="SPA单页面应用的优缺点"><a href="#SPA单页面应用的优缺点" class="headerlink" title="SPA单页面应用的优缺点"></a>SPA单页面应用的优缺点</h1><p>SPA分为2种。 第一种，SPA即指水疗、芳香按摩、沐浴、去死角等等。现代SPA主要透过人体的五大感官功能，即听觉（疗效音乐）、味觉（花草茶、健康饮食）、触觉（按摩）、视觉等达到全方位的放松，将精、气、神三者合一，实现身心的放松。</p>
<p>第二种，spa指的是single page application，就是只有一张Web页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序，它在加载页面时，不会加载整个页面，而是只更新某个指定的容器中内容。 浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。因此，对单页应用来说模块化的开发和设计显得相当重要。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h2><ol>
<li>用户体验好,快,内容的改变不需要重新加载整个页面</li>
<li>基于上面一点,spa相对于服务器压力小</li>
<li>良好的前后端分离</li>
<li>同一套后端程序代码,不用修改就可以用web界面,手机,平板等多种客户端</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h2><p>1.不利于seo：右键点击SEO应用查看源码，所有的页面和业务逻辑都封装在app.js中，对于搜索引擎来说，只能够抓取到app.js中的代码，有的搜索引擎会执行js查看页面内容，有的却无法执行，所以无法知道页面的具体内容，故而对SEO不友好。</p>
<p>2.初次加载耗时相对增多</p>
<p>3.导航不可用,如果一定要导航需要自行实现前进,后退</p>
<p>而前端路由router就是管理SPA单页面应用的路径管理器。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起url和页面之间的映射关系。</p>
<h1 id="Vue框架怎么实现对象和数组的监听（源码）"><a href="#Vue框架怎么实现对象和数组的监听（源码）" class="headerlink" title="Vue框架怎么实现对象和数组的监听（源码）"></a>Vue框架怎么实现对象和数组的监听（源码）</h1><p>如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是  Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observe a list of Array items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observe(items[i])  <span class="comment">// observe 功能为监测数据的变化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对属性进行递归遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val) <span class="comment">// observe 功能为监测数据的变化</span></span><br></pre></td></tr></table></figure>
<p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是<strong>通过遍历数组 和递归遍历对象</strong>，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p>
<h1 id="Vue-中的-key-有什么作用？"><a href="#Vue-中的-key-有什么作用？" class="headerlink" title="Vue 中的 key 有什么作用？"></a>Vue 中的 key 有什么作用？</h1><p><strong>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。没有设置key时，有些节点不会复用，而是直接创建新的，删除旧的。</strong></p>
<p>首先讲一下diff算法的处理方法，对操作前后的dom树同一层的节点进行对比，一层一层对比，如下图：</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/key1.png" alt="markdown"></p>
<p>当某一层有很多相同的节点时，也就是列表节点时，Diff算法的更新过程默认情况下也是遵循以上原则。</p>
<p>比如以下的情况，想要在B和C之间添加一个F<br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/key2.png" alt="markdown"></p>
<p>在没有绑定key的时候，diff算法执行起来是这样子的</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/key3.png" alt="markdown"></p>
<p>即把C更新成F，D更新成C，E更新成D，最后再插入E，这样导致了节点没有得到复用，也造成了误差<br>所以我们需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/key4.png" alt="markdown"></p>
<p><strong>准确: 如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug</strong></p>
<p><strong>快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度O(n),Map的时间复杂度仅仅为O(1)</strong></p>
<h1 id="Vue中的diff算法"><a href="#Vue中的diff算法" class="headerlink" title="Vue中的diff算法"></a>Vue中的diff算法</h1><p>vue和react的虚拟DOM的Diff算法大致相同，其核心是基于两个简单的假设：</p>
<ol>
<li>两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。</li>
<li>同一层级的一组节点，他们可以通过唯一的id进行区分。</li>
</ol>
<p>基于以上这两点假设，使得虚拟DOM的Diff算法的复杂度从O(n^3)降到了O(n)</p>
<p>Vue中的diff算法，就是用来比较虚拟DOM和需要渲染的真实DOM之间的差异。所以下面这张图可以很好的解释这个过程。<strong>比较只会在同个层级之间进行，不会跨层级比较</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 之前 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>           <span class="comment">&lt;!-- 层级1 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>            <span class="comment">&lt;!-- 层级2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span> aoy <span class="tag">&lt;/<span class="name">b</span>&gt;</span>   <span class="comment">&lt;!-- 层级3 --&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>diff<span class="tag">&lt;/<span class="name">Span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">P</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 之后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>            <span class="comment">&lt;!-- 层级1 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>             <span class="comment">&lt;!-- 层级2 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">b</span>&gt;</span> aoy <span class="tag">&lt;/<span class="name">b</span>&gt;</span>        <span class="comment">&lt;!-- 层级3 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>diff<span class="tag">&lt;/<span class="name">Span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最理想的就是将<span>直接移动到<p>的后边，这是最优的操作。但是实际的diff操作是移除</p><p>里的<span>，然后再创建一个新的<span>插到<p>的后边。<br>因为新加的<span>在层级2，旧的在层级3，属于不同层级的比较。</span></p>
<p>diff算法的过程其实就是调用patch函数，就像是打补丁一样修改真实DOM。<br>patch函数有两个参数，vnode和oldVnode，也就是新旧两个虚拟节点。</p>
<h2 id="sameVnode"><a href="#sameVnode" class="headerlink" title="sameVnode"></a><strong>sameVnode</strong></h2><p>在这之前，我们先了解完整的vnode都有什么属性，举个一个简单的例子:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// body下的 &lt;div id="v" class="classA"&gt;&lt;div&gt; 对应的 oldVnode 就是</span></span><br><span class="line">&#123;</span><br><span class="line">  el:  div  <span class="comment">//对真实的节点的引用，本例中就是document.querySelector('#id.classA')</span></span><br><span class="line">  tagName: <span class="string">'DIV'</span>,   <span class="comment">//节点的标签</span></span><br><span class="line">  sel: <span class="string">'div#v.classA'</span>  <span class="comment">//节点的选择器</span></span><br><span class="line">  data: <span class="literal">null</span>,       <span class="comment">// 一个存储节点属性的对象，对应节点的el[prop]属性，例如onclick , style</span></span><br><span class="line">  children: [], <span class="comment">//存储子节点的数组，每个子节点也是vnode结构</span></span><br><span class="line">  text: <span class="literal">null</span>,    <span class="comment">//如果是文本节点，对应文本节点的textContent，否则为null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>来到patch的第一部分，sameVnode函数就是看这两个节点是否值得比较：<br>判断两个Vnode节点是否是同一个节点，需要满足下面的条件</p>
<ul>
<li>key相同</li>
<li>tag（当前节点的标签名）相同</li>
<li>isComment（是否为注释节点）相同</li>
<li>是否data（当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息）都有定义</li>
<li>当标签是 input 的时候，type必须相同</li>
</ul>
<p>当两个VNode的tag、key、isComment都相同，并且同时定义或未定义data的时候，且如果标签为input则type必须相同。这时候这两个VNode则算sameVnode，可以直接进行patchVnode操作。</p>
<h2 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a><strong>patchVnode</strong></h2><p>patchVnode的规则是这样的：</p>
<ol>
<li><p>如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的VNode是clone或者是标记了once（标记v-once属性，只渲染一次），那么只需要替换elm以及componentInstance即可。</p>
</li>
<li><p>新老节点均有children子节点，则对子节点进行diff操作，调用updateChildren，这个updateChildren也是diff的核心。</p>
</li>
<li><p>如果老节点没有子节点而新节点存在子节点，先清空老节点DOM的文本内容，然后为当前DOM节点加入子节点。</p>
</li>
<li><p>当新节点没有子节点而老节点有子节点的时候，则移除该DOM节点的所有子节点。</p>
</li>
<li><p>当新老节点都无子节点的时候，只是文本的替换。</p>
</li>
</ol>
<h2 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a><strong>updateChildren</strong></h2><p>首先代码很复杂，所以在这里直接上图。</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/diff1.png" alt="markdown"></p>
<p>首先，在新老两个VNode节点的左右头尾两侧都有一个变量标记，在遍历过程中这几个变量都会向中间靠拢。当oldStartIdx &gt; oldEndIdx或者newStartIdx &gt; newEndIdx时结束循环。</p>
<p>首先，在新老两个VNode节点的左右头尾两侧都有一个变量标记，在遍历过程中这几个变量都会向中间靠拢。当oldStartIdx &gt; oldEndIdx或者newStartIdx &gt; newEndIdx时结束循环。</p>
<p>索引与VNode节点的对应关系： oldStartIdx =&gt; oldStartVnode oldEndIdx =&gt; oldEndVnode newStartIdx =&gt; newStartVnode newEndIdx =&gt; newEndVnode</p>
<p>在遍历中，如果存在key，并且满足sameVnode，会将该DOM节点进行复用，否则则会创建一个新的DOM节点。</p>
<p>首先，oldStartVnode、oldEndVnode与newStartVnode、newEndVnode两两比较一共有2*2=4种比较方法。</p>
<h3 id="sameVnode-oldStartVnode-newStartVnode-或者sameVnode-oldEndVnode-newEndVnode"><a href="#sameVnode-oldStartVnode-newStartVnode-或者sameVnode-oldEndVnode-newEndVnode" class="headerlink" title="sameVnode(oldStartVnode, newStartVnode)或者sameVnode(oldEndVnode, newEndVnode)"></a>sameVnode(oldStartVnode, newStartVnode)或者sameVnode(oldEndVnode, newEndVnode)</h3><p>当新老VNode节点的start或者end满足sameVnode时，也就是sameVnode(oldStartVnode, newStartVnode)或者sameVnode(oldEndVnode, newEndVnode)，直接将该VNode节点进行patchVnode即可。</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/diff2.png" alt="markdown"></p>
<h3 id="sameVnode-oldStartVnode-newEndVnode"><a href="#sameVnode-oldStartVnode-newEndVnode" class="headerlink" title="sameVnode(oldStartVnode, newEndVnode)"></a>sameVnode(oldStartVnode, newEndVnode)</h3><p>如果oldStartVnode与newEndVnode满足sameVnode</p>
<p>这时候说明oldStartVnode已经跑到了oldEndVnode后面去了，进行patchVnode的同时还需要将真实DOM节点移动到oldEndVnode的后面</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/diff3.png" alt="markdown"></p>
<h3 id="sameVnode-oldEndVnode-newStartVnode"><a href="#sameVnode-oldEndVnode-newStartVnode" class="headerlink" title="sameVnode(oldEndVnode, newStartVnode)"></a>sameVnode(oldEndVnode, newStartVnode)</h3><p>如果oldEndVnode与newStartVnode满足sameVnode</p>
<p>这说明oldEndVnode跑到了oldStartVnode的前面，进行patchVnode的同时真实的DOM节点移动到了oldStartVnode的前面</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/diff4.png" alt="markdown"></p>
<h3 id="sameVnode-newStartVnode"><a href="#sameVnode-newStartVnode" class="headerlink" title="sameVnode(?, newStartVnode)"></a>sameVnode(?, newStartVnode)</h3><p>则通过createKeyToOldIdx会得到一个oldKeyToIdx，里面存放了一个key为旧的VNode，value为对应index序列的哈希表。从这个哈希表中可以找到是否有与newStartVnode一致key的旧的VNode节点，如果同时满足sameVnode，patchVnode的同时会将这个真实DOM（elmToMove）移动到oldStartVnode对应的真实DOM的前面。</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/diff5.png" alt="markdown"></p>
<p>当然也有可能newStartVnode在旧的VNode节点找不到一致的key，或者是即便key相同却不是sameVnode，这个时候会调用createElm创建一个新的DOM节点</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/diff6.png" alt="markdown"></p>
<p>到这里循环已经结束了，那么剩下我们还需要处理多余或者不够的真实DOM节点。</p>
<h3 id="处理剩余节点"><a href="#处理剩余节点" class="headerlink" title="处理剩余节点"></a>处理剩余节点</h3><ol>
<li>当结束时oldStartIdx &gt; oldEndIdx，这个时候老的VNode节点已经遍历完了，但是新的节点还没有。说明了新的VNode节点实际上比老的VNode节点多，也就是比真实DOM多，需要将剩下的（也就是新增的）VNode节点插入到真实DOM节点中去，此时调用addVnodes（批量调用createElm的接口将这些节点加入到真实DOM中去）。</li>
</ol>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/diff7.png" alt="markdown"></p>
<ol start="2">
<li>同理，当newStartIdx &gt; newEndIdx时，新的VNode节点已经遍历完了，但是老的节点还有剩余，说明真实DOM节点多余了，需要从文档中删除，这时候调用removeVnodes将这些多余的真实DOM删除。</li>
</ol>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/diff8.png" alt="markdown"></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>尽量不要跨层级的修改dom</li>
<li>设置key可以最大化的利用节点</li>
<li>diff的效率并不是每种情况下都是最优的</li>
</ul>
<h1 id="webpack的plugin与loader区别"><a href="#webpack的plugin与loader区别" class="headerlink" title="webpack的plugin与loader区别"></a>webpack的plugin与loader区别</h1><p><strong>loader：</strong></p>
<p>用于对模块源码的转换，loader描述了webpack如何处理非javascript模块，并且在buld中引入这些依赖。loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，SCSS转换为CSS</p>
<p><strong>plugin：</strong></p>
<p>对于plugin，它就是一个扩展器，它丰富了wepack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，<strong>而是直接对整个构建过程起作用。，</strong>不仅局限于资源的加载。</p>
<h1 id="内置的过渡动画"><a href="#内置的过渡动画" class="headerlink" title="内置的过渡动画"></a>内置的过渡动画</h1><ul>
<li><p>v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</p>
</li>
<li><p>v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</p>
</li>
<li><p>v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。</p>
</li>
<li><p>v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</p>
</li>
<li><p>v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</p>
</li>
<li><p>v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。</p>
</li>
</ul>
<p>对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 transition，则 v- 是这些类名的默认前缀。如果你使用了 <transition name="my-transition">，那么 v-enter 会替换为 my-transition-enter。</transition></p>
<h1 id="vue-3-0-新特性"><a href="#vue-3-0-新特性" class="headerlink" title="vue 3.0 新特性"></a>vue 3.0 新特性</h1><h2 id="基于-Proxy-的观察者机制"><a href="#基于-Proxy-的观察者机制" class="headerlink" title="基于 Proxy 的观察者机制"></a>基于 Proxy 的观察者机制</h2><p>在vue 3.0之前是使用Object.defineProperty，那为什么要使用Proxy替代Object.defineProperty呢，主要是Object.defineProperty存在以下问题：</p>
<ol>
<li>在Vue中，Object.defineProperty无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。Vue 框架是<strong>通过遍历数组 和递归遍历对象</strong>，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听，部分方法如下：</li>
</ol>
<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()</li>
</ul>
<p>由于只针对了以上八种方法进行了hack处理,所以其他数组的属性也是检测不到的，还是具有一定的局限性。</p>
<ol start="2">
<li>Object.defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue里，是通过递归以及遍历data 对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象，不管是对操作性还是性能都会有一个很大的提升。</li>
</ol>
<p>所以使用Proxy的优点如下：</p>
<ul>
<li>可以劫持整个对象，并返回一个新对象</li>
<li>Proxy可以直接监听对象而非属性</li>
<li>Proxy可以直接监听数组的变化</li>
<li>Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的</li>
<li>Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</li>
</ul>
<p><strong>Object.defineProperty的优势</strong></p>
<ul>
<li>兼容性好,支持IE9</li>
</ul>
<h2 id="PWA-支持"><a href="#PWA-支持" class="headerlink" title="PWA 支持"></a>PWA 支持</h2><p>当我们选择启用 PWA 功能时，在打包生成的代码时会默认生成 service-worker.js 和 manifest.json 相关文件。熟悉PWA的同学都知道service-worker.js 和 manifest.json 是PWA的重要配置文件。</p>
<h2 id="使用图形化界面"><a href="#使用图形化界面" class="headerlink" title="使用图形化界面"></a>使用图形化界面</h2><p>你也可以通过 vue ui 命令以图形化界面创建和管理项目：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure>
<h2 id="项目改变"><a href="#项目改变" class="headerlink" title="项目改变"></a>项目改变</h2><p>相比 vue-cli 2.X 创建的目录，vue-cli 3.0 创建的目录看不见 webpack 的配置<br>需要手动配置 webpack：在根目录下新建一个 vue.config.js 文件</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>虚拟DOM重写</li>
<li>优化 slots 的生成：在 Vue 中，当父组件重新渲染时，其子组件也必须重新渲染。使用Vue 3，可以单独重新渲染父级和子级。</li>
<li>静态树提升(Static Tree Hoisting)</li>
<li>静态属性提升</li>
</ul>
<h1 id="vue自定义指令"><a href="#vue自定义指令" class="headerlink" title="vue自定义指令"></a>vue自定义指令</h1><p>使用 Vue.directive(id, [definition]) 定义全局的指令来进行自定义指令</p>
<p>参数1 ：指令的名称，注意，在定义的时候，指令的名称前面，不需要加 v-前缀，但是： 在调用的时候，必须在置顶的名称前加上 v-前缀来进行调用</p>
<p>参数2：是一个对象， 这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Vue.directive(<span class="string">"focus"</span>, &#123;</span><br><span class="line">    <span class="comment">// 注意： 在每个函数中， 第一个参数永远是el， 表示被绑定了指令的那个元素，这个el参数，是一个原生的JS对象</span></span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123; <span class="comment">// 每当指令绑定到元素上的时候，会立即执行这个bind函数，只执行一次</span></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123; <span class="comment">// inserted 表示元素插入到DOM中的时候，会执行inserted函数【触发一次】</span></span><br><span class="line">        el.focus()</span><br><span class="line">    &#125;,</span><br><span class="line">    updated: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123; <span class="comment">// 当VNode更新的时候，会执行updated，可能会触发多次</span></span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注意： Vue中所有的指令，在调用的时候，都以 v- 开头 --&gt;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> v-model=<span class="string">"keywords"</span> v-focus&gt;</span><br></pre></td></tr></table></figure>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a><strong>参考文章：</strong></h1><p><a href="https://juejin.im/post/5d59f2a451882549be53b170" target="_blank" rel="noopener">30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度）</a><br><a href="https://github.com/aooy/blog/issues/2" target="_blank" rel="noopener">解析vue2.0的diff算法</a><br><a href="https://github.com/answershuto/learnVue/blob/master/docs/VirtualDOM与diff(Vue实现" target="_blank" rel="noopener">VirtualDOM与diff(Vue实现)</a>)</p>
</span></span></p></span></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/23/css/HTML/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/23/css/HTML/" itemprop="url">HTML</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-23T15:19:35+08:00">
                2019-07-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/CSS/" itemprop="url" rel="index">
                    <span itemprop="name">CSS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h1><p>在我的理解为：根据内容，使用最合适的HTML标签。<br>场景：加入一个文章标题，要求这个标题的字体比正文的要大一些，还要加粗。能够实现这种效果的方法有很多，比如用CSS样式进行渲染。这样的效果看起来像是一个标题，但是他对浏览器来说，只是一个被渲染过的文本，无法知道他是一个标题。若要让浏览器知道他是一个标题，应该用hn标签来进行标记。<br>从这个例子可以总结出： 语义化的HTML文档，不关心内容的显示效果。 说的通俗一点： 标题脱了CSS这层外衣，它还是一个标题。</p>
<h2 id="语义化标签的优势"><a href="#语义化标签的优势" class="headerlink" title="语义化标签的优势"></a>语义化标签的优势</h2><ul>
<li>代码结构清晰，方便阅读，有利于团队合作开发。</li>
<li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。</li>
<li>有利于搜索引擎优化（SEO）。</li>
</ul>
<h2 id="HTML5新增的语义化标签"><a href="#HTML5新增的语义化标签" class="headerlink" title="HTML5新增的语义化标签"></a>HTML5新增的语义化标签</h2><ul>
<li>header：页眉通常包括网站标志、主导航、全站链接以及搜索框</li>
<li>nav：标记导航，仅对文档中重要的链接群使用</li>
<li>main：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能</li>
<li>article：定义外部的内容，其中的内容独立于文档的其余部分</li>
<li>section：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分</li>
<li>footer：页脚，只有当父级是body时，才是整个页面的页脚</li>
</ul>
<h1 id="meta标签的理解和总结"><a href="#meta标签的理解和总结" class="headerlink" title="meta标签的理解和总结"></a>meta标签的理解和总结</h1><p>meta常用于定义页面的说明，关键字，最后修改日期，和其它的元数据。它不会显示在页面上，但是机器却可以识别。<br>这些元数据将服务于浏览器（如何布局或重载页面），搜索引擎和其它网络服务。</p>
<p><strong>组成：meta标签一共有两个属性，分别是http-equiv属性和name属性</strong></p>
<h2 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h2><p>name属性主要用于描述网页，比如网页的关键词，叙述等。与之对应的属性值为content，content中的内容是对name填入类型的具体描述，便于搜索引擎抓取。<br>meta标签中name属性语法格式是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"参数"</span> <span class="attr">content</span>=<span class="string">"具体的描述"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>A. keywords(关键字)</strong><br>说明：用于告诉搜索引擎，你网页的关键字。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"Lxxyx,博客，文科生，前端"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>B. description(网站内容的描述)</strong><br>说明：用于告诉搜索引擎，你网站的主要内容。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"文科生，热爱前端与编程。目前大二，这是我的前端博客"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>C. viewport(移动端的窗口)</strong><br>说明：这个概念较为复杂，具体的会在下篇博文中讲述。<br>这个属性常用于设计移动端网页。在用bootstrap,AmazeUI等框架时候都有用过viewport。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>C. viewport(移动端的窗口)</strong><br>说明：robots用来告诉爬虫哪些页面需要索引，哪些页面不需要索引。<br>content的参数有all,none,index,noindex,follow,nofollow。默认是all。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"none"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>E. author(作者)</strong><br>说明：用于标注网页作者</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"leslie,leslie_choi@yeah.net"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>G. copyright(版权)</strong><br>说明：用于标注版权信息</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"copyright"</span> <span class="attr">content</span>=<span class="string">"leslie"</span>&gt;</span> //代表该网站为leslie个人版权所有。</span><br></pre></td></tr></table></figure>
<h2 id="http-equiv属性"><a href="#http-equiv属性" class="headerlink" title="http-equiv属性"></a>http-equiv属性</h2><p>equiv的全称是”equivalent”，意思是相等，相当于。<br>所以在这里的作用就是相当于HTTP的作用，类似于定义http参数。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"参数"</span> <span class="attr">content</span>=<span class="string">"具体的描述"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>A. content-Type(设定网页字符集)(推荐使用HTML5的方式)</strong></li>
</ul>
<p>说明：用于设定网页字符集，便于浏览器解析与渲染页面</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8"</span>&gt;</span>  //旧的HTML，不推荐</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span> //HTML5设定网页字符集的方式，推荐使用UTF-8</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>B. X-UA-Compatible(浏览器采取何种版本渲染当前页面)</strong></li>
</ul>
<p>说明：用于告知浏览器以何种版本来渲染页面。（一般都设置为最新模式，在各大框架中这个设置也很常见。）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span>/&gt;</span> //指定IE和Chrome使用最新版本渲染当前页面</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>C.cache-control(指定请求和响应遵循的缓存机制)</strong></li>
</ul>
<p><strong>用法一：指导浏览器如何缓存某个响应以及缓存多长时间。</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"cache-control"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>共有以下几种用法：</p>
<p>1、no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。</p>
<p>2、no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）</p>
<p>3、public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果</p>
<p>4、private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）</p>
<p>5、maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。</p>
<p><strong>用法二：禁止百度自动转码。</strong></p>
<p>用于禁止当前页面在移动端浏览时，被百度自动转码。虽然百度的本意是好的，但是转码效果很多时候却不尽人意。所以可以在head中加入例子中的那句话，就可以避免百度自动转码了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Cache-Control"</span> <span class="attr">content</span>=<span class="string">"no-siteapp"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>D. expires(网页到期时间)</strong></li>
</ul>
<p>用于设定网页的到期时间，过期后网页必须到服务器上重新传输。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"expires"</span> <span class="attr">content</span>=<span class="string">"Sunday 26 October 2016 01:00 GMT"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>refresh(自动刷新并指向某页面)</strong></li>
</ul>
<p>网页将在设定的时间内，自动刷新并调向设定的网址。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"2；URL=http://www.baidu.com"</span>&gt;</span> //意思是2秒后跳转</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Set-Cookie(cookie设定)</strong> </li>
</ul>
<p>如果网页过期。那么这个网页存在本地的cookies也会被自动删除。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Set-Cookie"</span> <span class="attr">content</span>=<span class="string">"name, date"</span>&gt;</span> //格式</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Set-Cookie"</span> <span class="attr">content</span>=<span class="string">"User=Lxxyx; path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT"</span>&gt;</span> //具体范例</span><br></pre></td></tr></table></figure>
<h1 id="H5和CSS3的新特性"><a href="#H5和CSS3的新特性" class="headerlink" title="H5和CSS3的新特性"></a>H5和CSS3的新特性</h1><h2 id="html5有哪些新特性"><a href="#html5有哪些新特性" class="headerlink" title="html5有哪些新特性"></a>html5有哪些新特性</h2><ol>
<li>拖拽释放(Drag and drop) API </li>
<li>语义化更好的内容标签（header,nav,footer,aside,article,section）</li>
<li>音频、视频API(audio,video)</li>
<li>画布(Canvas) API</li>
<li>地理(Geolocation) API</li>
<li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；sessionStorage 的数据在浏览器关闭后自动删除。</li>
<li>sessionStorage 的数据在浏览器关闭后自动删除</li>
<li>表单控件，calendar、date、time、email、url、search  </li>
<li>新的技术webworker, websocket, Geolocation</li>
</ol>
<h2 id="CSS3-新增属性"><a href="#CSS3-新增属性" class="headerlink" title="CSS3 新增属性"></a>CSS3 新增属性</h2><ol>
<li>颜色：新增RGBA，HSLA模式</li>
<li>文字阴影（text-shadow、）</li>
<li>边框： 圆角（border-radius）边框阴影： box-shadow</li>
<li>盒子模型：box-sizing</li>
<li>背景：background-size 设置背景图片的尺寸background-origin 设置背景图片的原点。background-clip 设置背景图片的裁切区域，以”，”分隔可以设置多背景，用于自适应布局</li>
<li>渐变：linear-gradient、radial-gradient</li>
<li>过渡：transition，可实现动画</li>
<li>自定义动画</li>
<li>在CSS3中唯一引入的伪元素是 ：：selection.</li>
<li>媒体查询，多栏布局</li>
<li>border-image</li>
<li>2D转换：transform：translate(x，y) rotate(x，y) skew(x，y) scale(x，y)</li>
</ol>
<h2 id="H5中已经废弃的标签"><a href="#H5中已经废弃的标签" class="headerlink" title="H5中已经废弃的标签"></a>H5中已经废弃的标签</h2><ul>
<li>br 换行，已经被 p 标签进行替换</li>
<li>hr 画线</li>
<li>font、big、center</li>
<li>在企业开发中，不到万不得已 不要轻易使用被废弃的标签</li>
<li>strong ：定义重要性强调的文字</li>
<li>ins 定义插入的文字</li>
<li>em 定义强调的文字</li>
<li>del定义被删除的文字</li>
<li>frame 等等</li>
</ul>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a href="https://juejin.im/entry/588074c62f301e00696b481d" target="_blank" rel="noopener">关于 HTML 中 meta 标签的理解和总结</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/13/JavaScript/提高页面性能/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/13/JavaScript/提高页面性能/" itemprop="url">提高页面性能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-13T22:12:24+08:00">
                2019-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们常将网络性能优化措施归结为三大方面：减少请求数、减小请求资源体积、提升网络传输速率。</p>
<h1 id="一、资源压缩合并，减少HTTP请求"><a href="#一、资源压缩合并，减少HTTP请求" class="headerlink" title="一、资源压缩合并，减少HTTP请求"></a>一、资源压缩合并，减少HTTP请求</h1><p>比如可以使用webpack将多个文件压缩成一个文件，并且对代码进行压缩。</p>
<h1 id="二、非核心代码异步加载"><a href="#二、非核心代码异步加载" class="headerlink" title="二、非核心代码异步加载"></a>二、非核心代码异步加载</h1><p>通常对于大型应用来说，完整加载所有javascript代码是十分耗时的工作。在页面渲染的这样一个过程中，有一个关键点是如果在解析内容的过程中遇到了脚本标签，如：<script src="example.js"></script>，浏览器就会暂停内容的解析，转而开始下载脚本。并且只有等脚本下载完并执行结束后，渲染引擎才会继续解析。那么这样一来，页面显示的时间必然会被延长。因此我们需要优化的点就是尽可能地让页面更早地被渲染出来。要解决上面说到的脚本加载问题，通常有三种解决方案：将脚本放在HTML末尾、动态加载脚本以及异步加载脚本。</p>
<ol>
<li>异步加载的方式：</li>
</ol>
<ul>
<li>动态脚本加载：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.src = <span class="string">"js/test.js"</span>;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(script);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>异步加载的方式</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defer &lt;script src=<span class="string">"defer.js"</span> defer&gt; &lt;/script&gt;</span><br><span class="line"><span class="keyword">async</span> &lt;script src=<span class="string">"defer.js"</span> <span class="keyword">async</span>&gt; &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>defer是在HTML渲染完之后（DOM结构完全生成，以及其他脚本执行完成之后）才会执行，如果是多个，则按照加载的顺序执行，优先级比async高</li>
<li>async是在下载完脚本之后立即执行，渲染引擎会中断，执行完脚本之后才会继续渲染，如果是多个，执行顺序和加载顺序无关</li>
</ul>
<h2 id="解决异步加载脚本的问题"><a href="#解决异步加载脚本的问题" class="headerlink" title="解决异步加载脚本的问题"></a>解决异步加载脚本的问题</h2><p>如何处理加载过程中这些脚本的互相依赖关系，就成了实现异步加载过程中所需要考虑的问题。一方面，对于页面中那些独立的脚本，如用户统计等插件就可以放心大胆地使用异步加载。而另一方面，对于那些确实需要处理依赖关系的脚本，业界已经有很成熟的解决方案了。如采用AMD规范的RequireJS,CMD规范的seaJS，或者使用ES6中的模块化开发。另一方面，也可以使用promise技术来实现处理异步脚本加载过程中de的依赖问题：</p>
<p>针对每个脚本依赖都会创建一个promise对象来管理其状态。采用动态插入脚本的方式来管理脚本，然后利用脚本onload和onreadystatechange(兼容性处理)事件来监听脚本是否加载完成。一旦加载完毕，就会触发promise的resovle方法。最后，针对依赖的处理，是promise的all方法，这个方法只有在所有promise对象都resolved的时候才会触发resolve方法，这样一来，我们就可以确保在执行回调之前，所有依赖的脚本都已经加载并执行完毕。</p>
<h1 id="三、利用浏览器缓存（最重要的一步）-gt-缓存的分类-gt-缓存的原理"><a href="#三、利用浏览器缓存（最重要的一步）-gt-缓存的分类-gt-缓存的原理" class="headerlink" title="三、利用浏览器缓存（最重要的一步） -&gt; 缓存的分类 -&gt; 缓存的原理"></a>三、利用浏览器缓存（最重要的一步） -&gt; 缓存的分类 -&gt; 缓存的原理</h1><ol>
<li>缓存的分类</li>
</ol>
<ul>
<li>强缓存发现本地有请求文件的副本，直接使用，也就是说如果我们在服务端更新了文件，并不会被浏览器所得知，就无法替换失效的缓存</li>
<li>协商缓存则需要和服务器进行交流，通过确认之后才可以使用</li>
</ul>
<p>a 强缓存：不会向服务器发送请求，直接从缓存中读取资源，返回状态码200</p>
<ul>
<li><p>Expires Wed, 22 Oct 2018 08:41:00 GMT<br><strong>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点，如果过期则会再次请求</strong></p>
</li>
<li><p>Cache—Control:max-age=300<br><strong>代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</strong></p>
</li>
</ul>
<p>但是如果服务器同时下发了两个，则以相对时间为准。</p>
<p>b 协商缓存：会去服务器比对，若没改变才直接读取本地缓存，返回的状态码是 304。<br>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p>
<p><strong>Last-Modified 和 If-Modified-Since</strong></p>
<p>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；<br>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，<strong>值就是Last-Modified中的值</strong> ；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。 </p>
<p>存在的弊端：</p>
<ul>
<li><p>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源</p>
</li>
<li><p>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</p>
</li>
<li><p>某些服务器不能精确的得到文件的最后修改时间。</p>
</li>
</ul>
<p><strong>Etag 和 If-None-Match</strong><br>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成，类似一个哈希值)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。<br>如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p>
<p><strong>PS：强缓存的优先级会比协商缓存优先级高，cache-control优先级 &gt; expire，Etag优先级 &gt; Last-modified</strong></p>
<p><strong>那有了Etag是不是可以放弃last-Modified了呢？</strong></p>
<ul>
<li><p>对那些一秒内修改特别频繁的文件，使用etag强验证的话，就需要占用服务器cpu资源频繁进行etag的计算，这样可能就不好用了。</p>
</li>
<li><p>只是给代码加上注释，但是服务器实质的内容并没有一点改变，如果使用Etag扫描全部文件可能会耗费大量性能，所以应该根据场景选择对应方案。</p>
</li>
</ul>
<h1 id="四、利用cdn"><a href="#四、利用cdn" class="headerlink" title="四、利用cdn"></a>四、利用cdn</h1><p>CDN又称为内容分发网络，使内容传输的更快，更稳定。<br>也就是说，<strong>把静态资源文件和动态网页分集群部署</strong>，静态资源会被部署到CDN节点上，网页中引用的资源也会变成对应的部署路径。<br>CDN 的核心点有两个: 一个是缓存，一个是回源。</p>
<ul>
<li>缓存<br>将从根服务器请求来的资源按要求缓存。</li>
<li>回源<br>当有用户访问某个资源的时候，如果被解析到的那个 CDN 节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。没有人访问，CDN 节点不会主动去源站请求资源。</li>
</ul>
<p>原理：不同地区的用户会访问到离自己最近的相同网络线路上的CDN节点，当请求达到CDN节点后，节点会判断自己的内容缓存是否有效，如果有效，则立即响应缓存内容给用户，从而加快响应速度。如果CDN节点的缓存失效，它会根据服务配置去我们的内容源服务器获取最新的资源响应给用户，并将内容缓存下来以便响应给后续访问的用户。因此，一个地区内只要有一个用户先加载资源，在CDN中建立了缓存，该地区的其他后续用户都能因此而受益。<br>不同地区的用户访问同一个域名却能得到不同CDN节点的IP地址，这要依赖于CDN服务商提供的智能域名解析服务，浏览器发起域名查询时，这种智能DNS服务会根据用户IP计算并返回离它最近的同网络CDN节点IP，引导浏览器与此节点建立连接以获取资源。</p>
<p>优点：</p>
<ul>
<li>CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低</li>
<li>大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源站的负载</li>
<li>提高网络访问的稳定性</li>
</ul>
<h1 id="五、预解析DNS"><a href="#五、预解析DNS" class="headerlink" title="五、预解析DNS"></a>五、预解析DNS</h1><p>还有一个可以优化网页速度的方式是利用dns的预解析技术。同preload类似，DNS Prefetch在网络层面上优化了资源加载的速度。<br>我们知道，针对DNS的前端优化，主要分为减少DNS的请求次数，还有就是进行DNS预先获取。DNS prefetch就是为了实现这后者。其用法也很简单，只要在link标签上加上对应的属性就行了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-dns-prefetch-control"</span> <span class="attr">content</span>=<span class="string">"on"</span> /&gt;</span> /* 这是用来告知浏览器当前页面要做DNS预解析，可以选择on或者off */</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//example.com"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>复制代码在支持该标准的浏览器上，会自动对链接中的地址域名做DNS解析缓存。不过，像Goolge、火狐这样的现代浏览器即使不设置这个属性，也能在后台做自动预解析。如果你的页面中需要大量访问不同域名的资源，可以利用这项技术加快资源的获取，从而获得更好的用户体验。需要注意的是，DNS预解析虽好，但是也不能滥用。如果对多页面重复DNS预解析，会增加DNS的查询次数。</p>
<h1 id="六、使用SSR（server-side-render）服务端渲染，数据直接输出到HTML中"><a href="#六、使用SSR（server-side-render）服务端渲染，数据直接输出到HTML中" class="headerlink" title="六、使用SSR（server side render）服务端渲染，数据直接输出到HTML中"></a>六、使用SSR（server side render）服务端渲染，数据直接输出到HTML中</h1><p>ssr是Server-Side Rendering的简写，即由服务端负责渲染页面直出，亦即同构应用。程序的大部分代码都可以在服务端和客户端运行。在服务端vue组件渲染为html字符串，然后直接返回给客户端，在客户端生成dom和操作dom。</p>
<p>能在服务端渲染为html字符串得益于vue组件结构是基于vnode的。vnode是dom的抽象表达，它不是真实的dom，它是由js对象组成的树，每个节点代表了一个dom。因为vnode，所以在服务端vue可以把js对象解析为html字符串。同样在客户端vnode因为是存在内存之中的，操作内存总比操作dom快的多，每次数据变化需要更新dom时，新旧vnode树经过diff算法，计算出最小变化集，大大提高了性能。</p>
<p><strong>服务端渲染 SSR 的优缺点如下：</strong></p>
<p>(1) 服务端渲染的优点：</p>
<ul>
<li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面</li>
<li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间</li>
</ul>
<p>(2) 服务端渲染的缺点：</p>
<ul>
<li>更多的开发条件限制： <strong>例如服务端渲染只支持 beforCreate 和 created 两个钩子函数</strong>，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
<li>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>
<h1 id="七、渲染优化"><a href="#七、渲染优化" class="headerlink" title="七、渲染优化"></a>七、渲染优化</h1><ul>
<li>css放在head里面，JS放在body的底部</li>
<li>懒加载（图片懒加载、下拉加载更多）</li>
<li>减少对DOM查询，对DOM查询做缓存</li>
<li>减少DOM操作，多个操作尽量合并在一起执行</li>
</ul>
<h1 id="八、事件节流"><a href="#八、事件节流" class="headerlink" title="八、事件节流"></a>八、事件节流</h1><h1 id="九、使用DOMContentLoaded，尽早执行操作"><a href="#九、使用DOMContentLoaded，尽早执行操作" class="headerlink" title="九、使用DOMContentLoaded，尽早执行操作"></a>九、使用DOMContentLoaded，尽早执行操作</h1><p>相比window.oonload，需要页面的全部资源加载完成才会执行，包括了图片还有视频等等<br>而DOMContentLoaded，只要DOM渲染完成即可执行，此时的图片和视频可能还没有加载完</p>
<h1 id="十、减少对DOM的操作"><a href="#十、减少对DOM的操作" class="headerlink" title="十、减少对DOM的操作"></a>十、减少对DOM的操作</h1><ul>
<li><p>缓存DOM查询</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未缓存 DOM 查询</span></span><br><span class="line">    <span class="keyword">var</span> i</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>).length;i++)&#123;</span><br><span class="line">        <span class="comment">//todo</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//缓存 DOM 查询   使用一个变量接收查询到的DOM</span></span><br><span class="line">    <span class="keyword">var</span> pList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>)</span><br><span class="line">    <span class="keyword">var</span> i</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; pList.length;i++)&#123;</span><br><span class="line">        <span class="comment">//todo</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并DOM的操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">element.style.borderColor = <span class="string">'#f00'</span>;</span><br><span class="line">element.style.borderStyle = <span class="string">'solid'</span>;</span><br><span class="line">element.style.borderWidth = <span class="string">'1px'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line">element.style.cssText += <span class="string">'border: 1px solid #f00;'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参考文章：</p>
<p><a href="https://www.jianshu.com/p/54cc04190252" target="_blank" rel="noopener">深入理解浏览器的缓存机制</a><br><a href="https://juejin.im/post/59a50dc1f265da246e6e108f" target="_blank" rel="noopener">web前端资源文件的部署和优化</a><br><a href="https://juejin.im/post/59b73ef75188253db70acdb5" target="_blank" rel="noopener">前端性能优化之加载技术</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/06/css/浏览器的渲染机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/06/css/浏览器的渲染机制/" itemprop="url">浏览器的渲染机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-06T16:06:24+08:00">
                2019-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/CSS/" itemprop="url" rel="index">
                    <span itemprop="name">CSS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="DOCTYPE及其作用"><a href="#DOCTYPE及其作用" class="headerlink" title="DOCTYPE及其作用"></a>DOCTYPE及其作用</h1><p>由于历史的原因，浏览器对页面的渲染方式是不一样的。在W3C标准出来之前，浏览器对页面的渲染没有同一的标准，产生了差异，quirks mod（混杂模式或者兼容模式），但在W3C标准出台之后，浏览器对页面的渲染有了同一的标准即（严格模式或标准模式）。但是为了保证以前就得页面仍然正常显示，有的浏览器就保存了这两种渲染模式（标准兼容模式）。那么究竟采用哪一种方式进行渲染，就要看DOCTYPE生命中的DTD。</p>
<p><strong>文档类型定义（DTD）Document Type Definition</strong> </p>
<p>简单说 DOCTYPE 是用来声明<strong>文档类型和DTD规范</strong> 的,告知浏览器的解析器用什么文档标准解析这个文档。，一个主要用途就是文件的合法性验证。如果文件代码不合法，那么浏览器解析的时候就会出错。<br>是一系列的语法规则，用来定义XML或者HTML的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式。<br>html5不基于 SGML，因此不需要对DTD进行引用，也就没有严格模式与宽松模式的区别，html5有相对宽松的语法，事实上，已经尽可能大的实现了向后兼容（老版本）。</p>
<p>常见的html的DOCTYPE</p>
<p>HTML5 &lt;!DOCTYPE html&gt;</p>
<p>HTML4 严格模式 &lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “<a href="http://www.w3.org/TR/html4/strict.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</a> </p>
<p>HTML4 宽松模式 &lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “<a href="http://www.w3.org/TR/html4/loose.dtd&quot;&gt;" target="_blank" rel="noopener">http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</a></p>
<p>这里可以看到严格模式和宽松模式的区别主要在于后缀的dtd文件的引用。严格模式不包含展示性和弃用元素（比如font），宽松模式包含所有的HTML元素和属性。</p>
<h1 id="浏览器的渲染机制"><a href="#浏览器的渲染机制" class="headerlink" title="浏览器的渲染机制"></a>浏览器的渲染机制</h1><p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/tree.png" alt="markdown"></p>
<p>要了解浏览器的渲染机制，需要先明白以下的概念：</p>
<ol>
<li>DOM：Document Object Model，浏览器将HTML解析成树形的数据结构，简称DOM。</li>
<li>CSSOM：CSS Object Model，浏览器将CSS解析成树形的数据结构，简称CSSOM。</li>
<li>Render Tree: DOM和CSSOM合并后生成Render Tree(但是如果遇到script标签的时候，会执行并阻塞渲染)</li>
<li>Layout: 计算出Render Tree每个节点的具体位置。（布局）</li>
<li>Painting：通过显卡，开始调用 GPU 绘制，合成图层，将Layout后的节点内容分别呈现到屏幕上。（渲染）</li>
</ol>
<p>PS：</p>
<ul>
<li>css加载不会阻塞DOM树的解析</li>
<li>css加载会阻塞DOM树的渲染（白屏）</li>
<li>css加载会阻塞后面js语句的执行</li>
</ul>
<h1 id="重排（回流）Reflow-（引起DOM树重新计算的行为）"><a href="#重排（回流）Reflow-（引起DOM树重新计算的行为）" class="headerlink" title="重排（回流）Reflow （引起DOM树重新计算的行为）"></a>重排（回流）Reflow <strong>（引起DOM树重新计算的行为）</strong></h1><p>DOM结构中的各个元素都有自己的盒子，这些都需要浏览器根据各种样式来计算，并根据计算结果将元素放到它该出现的位置，这个过程称为reflow。<br>以下是触发reflow的几种方法：</p>
<ol>
<li>增加、删除、修改DOM节点的时候，会导致Reflow</li>
<li>移动DOM的位置，或者生成动画的时候</li>
<li>修改CSS样式的时候</li>
<li>Resize窗口的时候（移动端没有这个问题），或者滚动的时候</li>
<li>修改网页的默认字体时</li>
</ol>
<h1 id="重绘Repaint-（元素样式的改变触发浏览器的行为）"><a href="#重绘Repaint-（元素样式的改变触发浏览器的行为）" class="headerlink" title="重绘Repaint （元素样式的改变触发浏览器的行为）"></a>重绘Repaint <strong>（元素样式的改变触发浏览器的行为）</strong></h1><p>当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称为Repaint</p>
<p>触发Repaint</p>
<ol>
<li>DOM改动</li>
<li>CSS改动</li>
</ol>
<p>重排一定会导致重绘（改变网页的位置），但是重绘不一定会导致重排（如颜色的改变）。</p>
<p>减少重排的几个方法：</p>
<ul>
<li>样式集中改变，减少对DOM的操作</li>
<li>对于多次重排的元素，使用absolute或者fixed脱离文档流</li>
<li>尽量减少使用table布局，因为一个小的改动会导致整个table的重新布局，通常要浪费同等元素的时间的3倍</li>
<li>不要在布局信息改变的时候做DOM查询</li>
<li>动画元素脱离文档流，减少回流的Render Tree的规模</li>
</ul>
<h1 id="输入URL到浏览器显示页面发生了什么"><a href="#输入URL到浏览器显示页面发生了什么" class="headerlink" title="输入URL到浏览器显示页面发生了什么"></a>输入URL到浏览器显示页面发生了什么</h1><ol>
<li>输入网址github.com</li>
<li>DNS查找域名的IP地址<br>DNS 的作用就是通过域名查询到具体的 IP。</li>
</ol>
<p>因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。</p>
<ul>
<li>请求发起后，游览器首先会解析这个域名，首先它会查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。</li>
<li>如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS(域名分布系统)服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</li>
<li>查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询</li>
<li>根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程</li>
<li>本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，<strong>也不会直接返回域名和IP地址的对应关系</strong>，而是告诉本地DNS服务器，你的域名的解析服务器的地址</li>
<li>最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</li>
</ul>
<p>本地硬盘host文件=&gt;本地DNS服务器(中国移动，中国电信)=&gt;根DNS服务器=&gt;域服务器=&gt;返回给本地DNS服务器，并作缓存。</p>
<ol start="3">
<li>建立TCP链接<br>TCP链接涉及到客户端和服务端之间的三次握手</li>
<li>浏览器向web服务器发起Http请求</li>
<li>HTTP服务器处理</li>
<li>关闭TCP链接<br>关闭TCP链接涉及客户端和服务端之间的四次挥手</li>
<li>浏览器解析资源</li>
<li>浏览器布局渲染</li>
</ol>
<h1 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h1><p>传统的 javascript 动画是通过定时器 setTimeout 或者 setInterval 实现的。但是定时器动画一直存在两个问题，第一个就是动画的循时间环间隔不好确定，设置长了动画显得不够平滑流畅，设置短了浏览器的重绘频率会达到瓶颈，推荐的最佳循环间隔是17ms（大多数电脑的显示器刷新频率是60Hz，1000ms/60）；第二个问题是定时器第二个时间参数只是指定了多久后将动画任务添加到浏览器的UI线程队列中，如果<strong>UI线程处于忙碌状态，那么动画不会立刻执行。</strong>为了解决这些问题，H5 中加入了 requestAnimationFrame</p>
<p><strong>优点：</strong></p>
<ol>
<li>requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率</li>
<li>在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量</li>
<li>requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销</li>
</ol>
<p>须注意的是，requestAnimationFrame也属于宏任务。使用方法和setTimeout一样。</p>
<h1 id="浏览器的工作原理"><a href="#浏览器的工作原理" class="headerlink" title="浏览器的工作原理"></a>浏览器的工作原理</h1><h2 id="进程和线程的概念"><a href="#进程和线程的概念" class="headerlink" title="进程和线程的概念"></a>进程和线程的概念</h2><ul>
<li><p>进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位（进程是一个工厂，工厂有它的独立资源，并且工厂之间相互独立）</p>
</li>
<li><p>线程：是进程中的一部分，一个没有线程的进程也可以被看作是单线程的，是CPU调度的一个基本单位（线程是工厂中的工人，多个工人协作完成任务，一个工厂可以有一个或者多个工人，工人之间共享空间）</p>
</li>
</ul>
<p>进程之间的通信方式：</p>
<ul>
<li>无名管道：半双工通信方式，数据只能单向流动并且只能在具有亲缘关系的进程间使用</li>
<li>有名管道：也是半双工通信方式，但是允许没有亲缘进程之间的通信</li>
<li>高级管道：将另一个程序当作一个新的程序在当前程序进程中启动，则这个进程算是当前程序的子进程</li>
<li>信号：用于通知接受进程某个事件已经发生</li>
</ul>
<h2 id="浏览器的进程"><a href="#浏览器的进程" class="headerlink" title="浏览器的进程"></a>浏览器的进程</h2><h3 id="浏览器的单进程时代"><a href="#浏览器的单进程时代" class="headerlink" title="浏览器的单进程时代"></a>浏览器的单进程时代</h3><p>在前端处于刀耕火种的年代，微软通过在它的电脑设备上绑定了ie浏览器，逐渐的打败了昔日强敌网景，独霸整个pc时代。以ie6为例，这款浏览器就是典型的单进程浏览器，而且还是单线程浏览器。所以你可以想象，这个浏览器是奇慢无比，一个网页挂了就会导致浏览器里所有的页面都挂了。于是乎在后面的ie浏览器，通过多线程技术来试图提升浏览器的速度，但其实单进程无论怎么魔改，都会涉及到这些问题：</p>
<ol>
<li>不稳定。毕竟只要一个线程挂了就整个浏览器挂了，所以整个浏览器很不稳定。</li>
<li>不流畅。比如在通过网络获取资源，到渲染流程，如果浏览器上还有插件则还要考虑插件的运行，如果有一个脚本是死循环的，则导致所有页面都要等待这个脚本执行完毕，会导致整个页面十分的不流畅。并且单进程浏览器关闭一个页面也会存在内存泄漏的问题，毕竟不是多进程。多进程关掉一个页面相当于关掉一个进程，系统会自动回收资源。所以这样子会导致浏览器开的越久就越占用内存。</li>
<li>不安全。上面说到线程是可以共享进程里的资源的，如果一个插件是恶意的，它可以影响到整个浏览器，甚至可以控制你的电脑，来盗取账号密码。除了插件外，还有一些脚本可以通过钻漏洞来获取权限，引发很多严重的后果。</li>
</ol>
<h3 id="浏览器的多进程时代"><a href="#浏览器的多进程时代" class="headerlink" title="浏览器的多进程时代"></a>浏览器的多进程时代</h3><p>现代浏览器以chrome浏览器为例，目前的浏览器的多进程架构大致上是这样的：</p>
<ol>
<li>浏览器进程。该进程主要是负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>
<li>网络进程。该进程主要负责页面的网络资源加载，比如在地址栏输入一个网页地址，网络进程会将请求后得到的资源交给渲染进程处理。</li>
<li>渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。（浏览器的渲染进程是多线程的）</li>
<li>GPU进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>
<li>插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ol>
<p>Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限</p>
<h1 id="webWorker实现多线程"><a href="#webWorker实现多线程" class="headerlink" title="webWorker实现多线程"></a>webWorker实现多线程</h1><p>Web Worker 是HTML5标准的一部分，这一规范定义了一套 API，它允许一段JavaScript程序运行在主线程之外的另外一个线程中。工作线程允许开发人员编写能够长时间运行而不被用户所中断的后台程序， 去执行事务或者逻辑，并同时保证页面对用户的及时响应，可以将一些大量计算的代码交给web worker运行而不冻结用户界面，web worker 就是为了解决这种花费大量时间的复杂运算而诞生的！</p>
<ul>
<li><p>创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</p>
</li>
<li><p>JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</p>
</li>
</ul>
<p>所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，<br>只待计算出结果后，将结果通信给主线程即可。<br>而且注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a href="https://juejin.im/post/5d765572e51d45621320318e" target="_blank" rel="noopener">现代浏览器工作原理（一）——浏览器进程</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/03/前后端通信方式/手撕webSocket/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/03/前后端通信方式/手撕webSocket/" itemprop="url">手撕websocket</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-03T12:56:15+08:00">
                2019-07-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p>
<p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p>
<p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p>
<p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p>
<p>其他特点包括：</p>
<p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p>
<p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p>
<p>（3）数据格式比较轻量，性能开销小，通信高效。</p>
<p>（4）可以发送文本，也可以发送二进制数据。</p>
<p>（5）没有同源限制，客户端可以与任意服务器通信。</p>
<p>（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'wss://echo.websocket.org'</span>);</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Connection open ...'</span>);</span><br><span class="line">    ws.send(<span class="string">'Hello WebSockets!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Received Message: '</span>, evt.data);</span><br><span class="line">    ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Connection closed.'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// url（必选），options（可选）</span></span><br><span class="line">fetch(<span class="string">'/some/url/'</span>, &#123;</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 出错了，等价于 then 的第二个参数，但这样更好用更直观</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>参考文章：<br><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/02/前后端通信方式/手撕Jsonp/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/02/前后端通信方式/手撕Jsonp/" itemprop="url">手撕jsonp</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-02T10:22:15+08:00">
                2019-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="实现jsonp通信"><a href="#实现jsonp通信" class="headerlink" title="实现jsonp通信"></a>实现jsonp通信</h1><p>JSONP(JSON with Padding) 是一种跨域请求方式。主要原理是利用了script 标签可以跨域请求的特性，由其 src 属性发送请求到服务器，服务器返回 JavaScript 代码，浏览器接受响应，然后就直接执行了，这和通过 script 标签引用外部文件的原理是一样的。</p>
<p>JSONP由两部分组成：<strong>回调函数和数据</strong> ，回调函数一般是在浏览器控制，作为参数发往服务器端（当然，你也可以固定回调函数的名字，但客户端和服务器端的名称一定要一致）。当服务器响应时，服务器端就会把该函数和数据拼成字符串返回。<br>JSONP的请求过程：</p>
<p>请求阶段：浏览器创建一个 script 标签，并给其src 赋值(类似 <a href="http://example.com/api/?callback=jsonpCallback）。" target="_blank" rel="noopener">http://example.com/api/?callback=jsonpCallback）。</a><br>发送请求：当给script的src赋值时，浏览器就会发起一个请求。<br>数据响应：服务端将要返回的数据作为参数和函数名称拼接在一起(格式类似”jsonpCallback({name: ‘abc’})”)返回。当浏览器接收到了响应数据，由于发起请求的是 script，所以相当于直接调用 jsonpCallback 方法，并且传入了一个参数。</p>
<p>最简单版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>)</span><br><span class="line">script.src = <span class="string">'http://github.com&amp;callback=callback'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">ress</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对请求data进行格式化处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formateData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        <span class="comment">//避免有&amp;,=,?字符，对这些字符进行序列化</span></span><br><span class="line">        arr.push(<span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + data[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">'&amp;'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//跨域jsonp请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//先对params进行处理，防止为空</span></span><br><span class="line">    params = params || &#123;&#125;;</span><br><span class="line">    params.data = params.data || &#123;&#125;;</span><br><span class="line">    <span class="comment">//后台传递数据时调用的函数名</span></span><br><span class="line">    <span class="keyword">var</span> callbackName = params.jsonp;</span><br><span class="line">    <span class="comment">// 拿到dom元素head，先不进行操作</span></span><br><span class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.querySelector(<span class="string">'head'</span>);</span><br><span class="line">    <span class="comment">//创建script元素，先不进行操作</span></span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    <span class="comment">//传递给后台的data数据中，需要包含回调参数callback。</span></span><br><span class="line">    <span class="comment">//callback的值是 一个回调函数的函数名，后台通过该回调函数名调用传递数据，这个参数名的key由双方约定，默认为callback</span></span><br><span class="line">    params.data[<span class="string">'callback'</span>] = callbackName;</span><br><span class="line">    <span class="comment">//对data数据进行格式化</span></span><br><span class="line">    <span class="keyword">var</span> data = formateData(params.data);</span><br><span class="line">    <span class="comment">//设置script请求的url跟数据</span></span><br><span class="line">    script.src = <span class="string">`<span class="subst">$&#123;params.url&#125;</span>?<span class="subst">$&#123;data&#125;</span>`</span>;</span><br><span class="line">    <span class="comment">//全局函数 由script请求后台，被调用的函数，只有后台成功响应才会调用该函数</span></span><br><span class="line">    <span class="built_in">window</span>[callbackName] = <span class="function"><span class="keyword">function</span> (<span class="params">jsonData</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//请求移除scipt标签</span></span><br><span class="line">        head.removeChild(script);</span><br><span class="line">        clearTimeout(script.timer);</span><br><span class="line">        <span class="built_in">window</span>[callbackName] = <span class="literal">null</span>;</span><br><span class="line">        params.success &amp;&amp; params.success(jsonData)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//请求超时的处理函数</span></span><br><span class="line">    <span class="keyword">if</span> (params.time) &#123;</span><br><span class="line">        script.timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//请求超时对window下的[callbackName]函数进行清除，由于有可能下次callbackName发生改变了</span></span><br><span class="line">            <span class="built_in">window</span>[callbackName] = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//移除script元素，无论请求成不成功</span></span><br><span class="line">            head.removeChild(script)</span><br><span class="line">            <span class="comment">//这里不需要清除定时器了，clearTimeout(script.timer); 因为定时器调用之后就被清除了</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">//调用失败回调</span></span><br><span class="line">            params.error &amp;&amp; params.error(&#123;</span><br><span class="line">                message: <span class="string">'超时'</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//往head元素插入script元素，这个时候，script就插入文档中了，请求并加载src</span></span><br><span class="line">    head.appendChild(script);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//无论是请求超时，还是请求成功，都要移除script元素，script元素只有在第一次插入页面文档的时候，才会请求src</span></span><br><span class="line">    <span class="comment">//无论请求失败还是成功，都还是要移除window[callbackName]避免增加没用的全局方法，因为每次请求的callbackName可能是不同的</span></span><br><span class="line">    <span class="comment">//之前有个无聊的问题：为啥jsonp只能是get请求呢？看了实现过程，知道其实是因为script的加载就是get方式的~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    &lt;script&gt;</span><br><span class="line"><span class="comment">//这个是jsonp的请求demo</span></span><br><span class="line">        jsonp(&#123;</span><br><span class="line">            url: <span class="string">'http://127.0.0.1:3000/jsonp'</span>,</span><br><span class="line">            jsonp: <span class="string">'callback'</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                name: <span class="string">'jgchen'</span>,</span><br><span class="line">                stuNo: <span class="number">2016130201</span>,</span><br><span class="line">                method: <span class="string">'jsonp'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            success(res) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'jsonp success:'</span>,res);</span><br><span class="line">            &#125;,</span><br><span class="line">            error(err) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/14/JavaScript/DOM事件类/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/14/JavaScript/DOM事件类/" itemprop="url">DOM事件类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-14T23:56:24+08:00">
                2019-06-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/basic/" itemprop="url" rel="index">
                    <span itemprop="name">basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="DOM事件的级别"><a href="#DOM事件的级别" class="headerlink" title="DOM事件的级别"></a>DOM事件的级别</h1><p>(注意DOM1设计的时候，没有设计与事件相关的东西，所以在这里就没有谈及DOM1了)</p>
<ol>
<li>DOM0  - &gt;  element.onclik = function(){}</li>
<li>DOM2  - &gt;  element.addEventListener(‘click’,function(){},false)</li>
<li>DOM3  - &gt;  element.addEventListener(‘keyup’,function(){},false)<br>参数true则为事件捕获，参数false则为事件冒泡<br>DOM3和DOM2其实相差不多，只是DOM3的事件类型增加了很多，鼠标的移入移出和键盘的监听等等</li>
</ol>
<h1 id="DOM事件模型"><a href="#DOM事件模型" class="headerlink" title="DOM事件模型"></a>DOM事件模型</h1><ol>
<li>事件捕获<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;button&gt;</span><br><span class="line">        &lt;p&gt;点击捕获&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    var oP=document.querySelector('p');</span></span><br><span class="line"><span class="regexp">    var oB=document.querySelector('button');</span></span><br><span class="line"><span class="regexp">    var oD=document.querySelector('div');</span></span><br><span class="line"><span class="regexp">    var oBody=document.querySelector('body');</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    oP.addEventListener('click',function()&#123;</span></span><br><span class="line"><span class="regexp">        console.log('p标签被点击')</span></span><br><span class="line"><span class="regexp">    &#125;,true);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    oB.addEventListener('click',function()&#123;</span></span><br><span class="line"><span class="regexp">        console.log("button被点击")</span></span><br><span class="line"><span class="regexp">    &#125;,true);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    oD.addEventListener('click',  function()&#123;</span></span><br><span class="line"><span class="regexp">        console.log('div被点击')</span></span><br><span class="line"><span class="regexp">    &#125;,true);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    oBody.addEventListener('click',function()&#123;</span></span><br><span class="line"><span class="regexp">        console.log('body被点击')</span></span><br><span class="line"><span class="regexp">    &#125;,true);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>默认是false。<br>改为false即为冒泡了。输出的结果是body -&gt;  div -&gt; button -&gt; p。</p>
<ol start="2">
<li>事件冒泡</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box1"</span> onclick=<span class="string">"box1()"</span>&gt;</span><br><span class="line">    &lt;ul onclick=<span class="string">"ul()"</span>&gt;</span><br><span class="line">        &lt;li onclick=<span class="string">"li()"</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">box1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"box1被点击了"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ul</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"ul被点击了"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">li</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"li被点击了"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>点击li，则输出的结果为 li -&gt; ul -&gt; box1</p>
<p>说到事件代理，则有必要了解一下。事件代理也叫事件委托，利用冒泡阶段的运行机制实现的，就是把一个元素响应事件的函数委托到另一个元素，一般是把一组元素的事件委托到他的父元素上面，实际运用场景：可以在父元素层面阻止事件向子元素传播，也可以代替子元素执行某些操作。<br>优点：</p>
<ul>
<li>减少内存消耗，提高效率</li>
<li>动态事件绑定（）</li>
</ul>
<h1 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h1><p>一个完整的事件流包括了3个阶段，事件捕获 - &gt; 目标阶段 - &gt; 冒泡阶段 </p>
<h1 id="描述DOM事件捕获的具体流程"><a href="#描述DOM事件捕获的具体流程" class="headerlink" title="描述DOM事件捕获的具体流程"></a>描述DOM事件捕获的具体流程</h1><p>window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素<br>（冒泡则相反）</p>
<h1 id="Event对象的常见应用"><a href="#Event对象的常见应用" class="headerlink" title="Event对象的常见应用"></a>Event对象的常见应用</h1><ol>
<li>event.preventDefault()       - &gt; 阻止默认事件</li>
<li>event.stopPropagation()      - &gt; 阻止冒泡</li>
<li>event.stopImmediatePropagation()     - &gt; 事件的响应优先级。（场景：按钮绑定两个事件a和b，要求点击按钮的时候a事件触发的同时不会触发b，则可以在其中加入该代码）</li>
<li>event.currentTarget    - &gt; 指的是当前绑定的事件</li>
<li>event.target           - &gt; 事件代理情况下使用。（场景：有一个ul列表下面有很多的li标签，每个li都可以触发一个事件，那么可以将该事件委托在其父元素ul上，但是触发事件的时候，就要用到event.target判断是哪一个li触发了事件）</li>
</ol>
<h1 id="自定义事件（模拟事件）"><a href="#自定义事件（模拟事件）" class="headerlink" title="自定义事件（模拟事件）"></a>自定义事件（模拟事件）</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ev = <span class="built_in">document</span>.getElementsByClassName(<span class="string">"box1"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> eve = <span class="keyword">new</span> Event(<span class="string">'cusstome'</span>); <span class="comment">//eve类似于click，传入的参数是事件名称</span></span><br><span class="line">   ev.addEventListener(<span class="string">'custome'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   <span class="comment">//ev是获取到的DOM节点</span></span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"custome"</span>)</span><br><span class="line">   &#125;);</span><br><span class="line">   ev.dispatchEvent(eve);</span><br></pre></td></tr></table></figure>
<p>还有一个CustomEvent，用法一样，不过CustomerEvent()可以多传一个对象参数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/22/JavaScript/作用域链与闭包/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="leslie choi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404 not found">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/22/JavaScript/作用域链与闭包/" itemprop="url">javaScript中的作用域链与闭包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-22T19:21:12+08:00">
                2019-05-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/basic/" itemprop="url" rel="index">
                    <span itemprop="name">basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>JS中，只有全局作用域和局部作用域（eval开发中比较少使用不做讨论），并且作用域和执行上下文其实是完全不同的两个概念，在执行上下文这前两篇文章中也有谈到。<br><strong>作用域链，是由当前环境与上层环境的一系列变量对象组成，作用是保证了当前执行环境对符合访问权限的变量和函数的有序访问。</strong><br>还是老样子举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a + <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> b + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innerTest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure></p>
<p>我们可以直接用一个数组来表示作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scopeChain: [VO(innerTest), VO(test), VO(global)], <span class="comment">// 作用域链</span></span><br></pre></td></tr></table></figure></p>
<p>敲黑板记重点（这个确实也是我之前的一个误区）：很多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。以最前端为起点，最末端为终点的单方向通道其实是贴切的形容(这就和“链”这个字很贴切了，蛤蛤~)。如图<br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.PNG" alt="markdown"></p>
<p>所以作用域链的实质其实是指一个指向变量对象的指针列表，它只引用但是并不包含实际对象。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>JS中的闭包，真的是一个老生常谈的一个话题了。。。1000个人心中总有1000个哈姆雷特，就连《JavaScript高级程序设计》和《JavaScript权威指南》对闭包的解释，都会有一点点的差异。所以还是看了好多的博客，再根据自己的理解来，不再浅尝辄止，稍稍深入一点点来了解闭包。</p>
<ol>
<li>什么是闭包</li>
</ol>
<p>在JS中，<strong>函数内部可以直接读取全局变量，但是函数外部无法读取函数内部的局部变量。所以闭包的存在，就是指有权访问另一个函数作用域中的变量的函数。</strong></p>
<p>闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。</p>
<ol start="2">
<li>闭包的应用</li>
</ol>
<p>匿名自执行函数：我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量：造成全局对象过于庞大，影响访问速度（因为变量的取值是需要从原型链上遍历的）。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行次，其内部变量无需维护，可以用闭包。</p>
<p>结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p>
<p>========================================================================<br>但是，有时候需要得到函数内部的局部变量，就可以通过闭包的方法，利用js变量作用域的特点,如在函数内部定义子函数，对于子函数来说，父函数就是它的全局，子函数可以访问父函数里的变量(对于整个js代码来说又是局部变量)。</p>
<p>闭包由两个部分组成，最典型的就是函数模式的闭包了。<br>它由两部分组成。执行上下文(代号parent)，以及在该执行上下文中创建的函数（代号child）。<br>当child执行时，如果访问了parent中变量对象中的值，那么闭包就会产生。在这里可以把child函数当作一个闭包，这个函数是连接函数内部和外部的桥梁，所以在这里函数外部可以访问到函数内的num。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">50</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">var</span> f1 = parent();  <span class="comment">//将结果保存在全局里</span></span><br><span class="line">    </span><br><span class="line">    f1();       <span class="comment">//50</span></span><br></pre></td></tr></table></figure></p>
<p>在大多数理解中，包括许多著名的书籍，文章里都以函数child的名字代指这里生成的闭包。<strong>而在chrome中，则以执行上下文A的函数名代指闭包。</strong><br>闭包有个优点，就是可以缓存数据，延长作用域链（不会被垃圾回收机制回收）。由于闭包的内存不会被垃圾回收机制回收，所以在使用闭包的时候要谨慎。那又是为什么不会垃圾回收机制回收呢？<br>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innnerFoo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> innnerFoo; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = foo();</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p>
<p>在正常情况下，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。<br>上面的例子中。foo()执行完毕之后，按照常理，其执行环境生命周期会结束，所占内存被垃圾收集器释放。但是通过返回innerFoo，函数innerFoo的引用被保留了下来，将foo复制给了全局变量fn。这个行为，导致了foo中的变量对象a，也被保留了下来。于是，函数fn执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。<br>所以可以把foo当成一个闭包，下图是foo的作用域链：<br><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/foo.PNG" alt="markdown"></p>
<p>经典例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">        alert(x+y+(++tmp));</span><br><span class="line">    &#125;</span><br><span class="line">    bar(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">2</span>);            <span class="comment">//永远是16</span></span><br><span class="line">foo(<span class="number">2</span>);            <span class="comment">//永远是16</span></span><br><span class="line">foo(<span class="number">2</span>);            <span class="comment">//永远是16</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">        alert(x+y+(++tmp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo(<span class="number">2</span>);</span><br><span class="line">bar(<span class="number">10</span>);        <span class="comment">//16</span></span><br><span class="line">bar(<span class="number">10</span>);        <span class="comment">//17</span></span><br><span class="line">bar(<span class="number">10</span>);        <span class="comment">//18</span></span><br></pre></td></tr></table></figure>
<p>由于闭包的使用内存不会被回收，所以滥用闭包在低版本IE浏览器中可能会导致内存泄漏<br>导致内存泄漏的几种情况：</p>
<ul>
<li>意外的全局变量（没有通过var声明，导致被挂在window上）：使用严格模式避免。</li>
<li>未销毁的定时器或者回调函数：手动删除定时器</li>
<li>不规范使用闭包(循环引用)：注意程序逻辑，避免“死循环”之类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">var</span> obj=<span class="built_in">document</span>.createElement(<span class="string">"XXX"</span>); </span><br><span class="line">    obj.οnclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="comment">//Even if it's a empty function </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转化为以下函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">var</span> obj=<span class="built_in">document</span>.createElement(<span class="string">"XXX"</span>); </span><br><span class="line">    obj.οnclick=onclickHandler; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onclickHandler</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="comment">//do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>stopPropagation()</code> 阻止事件冒泡。 这个事件不会阻止定义在元素上的其他事件。</li>
<li><code>stopImmediatePropagation()</code> 会彻底的阻止事件， 在其之后的绑定在元素上的其他监听事件都不会触发</li>
<li><code>preventDefault()</code> 阻止事件的默认动作</li>
</ul>
<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>必要性：由于字符串、对象和数组没有固定大小，所以当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。</p>
<p>现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数（已经淘汰）。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个<strong>引用类型</strong>赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;; <span class="comment">//a的引用次数为0，需要时一个引用类型的值</span></span><br><span class="line"><span class="keyword">var</span> b = a; <span class="comment">//a的引用次数为1</span></span><br><span class="line"><span class="keyword">var</span> c = a;<span class="comment">//a的引用次数为2</span></span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;;  <span class="comment">//a的引用次数减1 为 1</span></span><br></pre></td></tr></table></figure>
<p>但是引用计数存在以下问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> objA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="keyword">var</span> objB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">    objA.someOtherObject = objB;</span><br><span class="line">    objB.anotherObject = objA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，<strong>objA和objB通过各自的属性相互引用；</strong>也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA和objB还将会继续存在，<strong>因为他们的引用次数永远不会是0,陷入死循环。</strong>这样的相互引用如果说很大量的存在就会导致大量的内存泄露。</p>
<h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>这是javascript中最常用的垃圾回收方式。当变量进入执行环境时（例如在函数中声明一个变量），就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。</p>
<p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;<span class="comment">//被标记进入环境  </span></span><br><span class="line">&#125;</span><br><span class="line">test();<span class="comment">//执行结束后被标记离开环境 被回收</span></span><br></pre></td></tr></table></figure>
<p>该算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始（在JS中就是全局对象）扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。<br>此算法可以分为两个阶段，一个是标记阶段（mark），一个是清除阶段(sweep)。</p>
<ol>
<li>标记阶段，垃圾回收器会从根对象开始遍历。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。</li>
<li>清除阶段，垃圾回收器会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。</li>
</ol>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/swip.png" alt="markdown"></p>
<p>在标记阶段，从根对象1可以访问到B，从B又可以访问到E，那么B和E都是可到达对象，同样的道理，F、G、J和K都是可到达对象。</p>
<p>在回收阶段，所有未标记为可到达的对象都会被垃圾回收器回收。</p>
<p><strong>何时开始垃圾回收?</strong></p>
<p>通常来说，在使用标记清除算法时，未引用对象并不会被立即回收。取而代之的做法是，垃圾对象将一直累计到内存耗尽为止。当内存耗尽时，程序将会被挂起，垃圾回收开始执行。</p>
<p>补充: 从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。</p>
<p><strong>标记清除算法缺陷</strong></p>
<ul>
<li><p>那些无法从根对象查询到的对象都将被清除</p>
</li>
<li><p>垃圾收集后有可能会造成大量的内存碎片，像上面的图片所示，垃圾收集后内存中存在三个内存碎片，假设一个方格代表1个单位的内存，如果有一个对象需要占用3个内存单位的话，那么就会导致Mutator一直处于暂停状态，而Collector一直在尝试进行垃圾收集，直到Out of Memory</p>
</li>
</ul>
<h2 id="Chrome-V8-垃圾回收算法"><a href="#Chrome-V8-垃圾回收算法" class="headerlink" title="Chrome V8 垃圾回收算法"></a>Chrome V8 垃圾回收算法</h2><p>Chrome 浏览器所使用的 V8 引擎就是采用的分代回收策略。目的是通过区分「临时」与「持久」对象；多回收「临时对象区」（新生代younggeneration），少回收「持久对象区」（老生代 tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。</p>
<p>V8的内存分代:</p>
<p>在V8中，主要将内存分为新生代和老生代，新生代内存 存储的为存活时间较短的对象，老生代内存 存储的为存活时间较长或常驻内存的对象，如下图：</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/laji.png" alt="markdown"></p>
<h3 id="V8新生代算法（Scavenge）"><a href="#V8新生代算法（Scavenge）" class="headerlink" title="V8新生代算法（Scavenge）"></a>V8新生代算法（Scavenge）</h3><p>在分代基础上，新生代中的对象主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法<br>Cheney算法是一种采用复制的方式实现的垃圾回收算法。</p>
<p>它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。</p>
<p>当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而(From空间内的)非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换(即以前的From空间释放后变为To;To空间在复制存活的对象后,变为From空间)。简而言之，在垃圾回收过程中，就是通过将存活对象在两个semispace空间之间进行复制。</p>
<p>Scavenge的缺点:<br>只能使用堆内存中的一半，这是由划分空间和复制机制所决定的。</p>
<p>Scavenge的优点:<br>Scavenge由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现。 </p>
<p><strong>Scavenge是典型的牺牲空间换取时间的算法</strong>， 所以无法大规模地应用到所有的垃圾回收中。但可以发现，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。</p>
<h3 id="V8老生代算法（Mark-Sweep-标记清除-amp-amp-Mark-Compact-标记管理）"><a href="#V8老生代算法（Mark-Sweep-标记清除-amp-amp-Mark-Compact-标记管理）" class="headerlink" title="V8老生代算法（Mark-Sweep 标记清除 &amp;&amp; Mark-Compact 标记管理）"></a>V8老生代算法（Mark-Sweep 标记清除 &amp;&amp; Mark-Compact 标记管理）</h3><p>对于老生代中的对象，由于存活对象占较大比重，再采用Scavenge的方式会有两个问题：一个是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。为此，V8在老生代中主要采用Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。</p>
<h4 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep:"></a>Mark-Sweep:</h4><p>Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。与Scavenge相比，Mark-Sweep并不将内存空间划分为两半，所以不存在浪费一半空间的行为。与Scavenge复制活着的对象不同，Mark-Sweep在标记阶段遍历堆中所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。 可以看出，Scavenge中只复制活着的对象，而Mark-Sweep只清理死亡对象。 活对象在新生代中只占较小部分，死对象在老生代中只占较小部分，这是两种回收方式能高效处理的原因。</p>
<p>下图为Mark-Sweep在老生代空间中标记的示意图，黑色部分标记为死亡对象</p>
<p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/old.png" alt="markdown"></p>
<p>Mark-Sweep最大的问题:</p>
<p>在进行一次标记清除回收后，<strong>内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。</strong>(注意理解这句话,不要把内存想象成液体.而是固体,就像一个个散乱排列的麻将,需要进行排序处理–即后面要讲的 Mark-Compact)</p>
<h4 id="Mark-Compact"><a href="#Mark-Compact" class="headerlink" title="Mark-Compact:"></a>Mark-Compact:</h4><p>为了解决Mark-Sweep的内存碎片问题，Mark-Compact被提出来。Mark-Compact是标记整理的意思，是在Mark-Sweep的基础上演变而来的。它们的差别在于对象在标记为死亡后，<strong>在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。</strong>下图为Mark-Compact完成标记并移动存活对象后的示意图，白色格子为存活对象，深色格子为死亡对象，浅色格子为存活对象移动后留下的空洞。</p>
<h3 id="Mark-Sweep、Mark-Compact、Scavenge三种主要垃圾回收算法的简单对比"><a href="#Mark-Sweep、Mark-Compact、Scavenge三种主要垃圾回收算法的简单对比" class="headerlink" title="Mark-Sweep、Mark-Compact、Scavenge三种主要垃圾回收算法的简单对比"></a>Mark-Sweep、Mark-Compact、Scavenge三种主要垃圾回收算法的简单对比</h3><p><img src="https://leslie-blog.oss-cn-hongkong.aliyuncs.com/leslie_choi_blog/duibi.png" alt="markdown"></p>
<p>从表格上看，Mark-Sweep和Mark-Compact之间，由于Mark-Compact需要移动对象，所以它的执行速度不可能很快，所以在取舍上，V8主要使用Mark-Sweep，<strong>在空间不足以对从新生代中晋升过来的对象进行分配时才使用Mark-Compact。</strong></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.jianshu.com/p/21a16d44f150" target="_blank" rel="noopener">前端基础进阶（四）：详细图解作用域链与闭包</a><br><a href="https://juejin.im/post/5c6bba32f265da2db07382cf" target="_blank" rel="noopener">前端面试查漏补缺–(二) 垃圾回收机制</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">leslie choi</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leslie choi</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
